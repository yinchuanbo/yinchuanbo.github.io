<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>AI 人脸数据采集</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link id="prismTheme" rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700b3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
  </head>

  <body class="fade-in">
    <button
      class="toggle-sidebar"
      id="toggleSidebar"
      aria-label="Toggle Sidebar"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <div class="app-container">
      <!-- Sidebar Navigation -->
      <nav class="sidebar">
        <div class="sidebar-content">
          <div class="nav-section"><li class=""><a title="分享我在用的三个免费AI工具" href="/md/分享我在用的三个免费AI工具.html">02 分享我在用的三个免费AI工具</a></li><li class="active"><a title="AI 人脸数据采集" href="/md/AI 人脸数据采集.html">01 AI 人脸数据采集</a></li></div>
        </div>
      </nav>

      <!-- Main Content Area -->
      <main class="main-content">
        <header class="content-header">
          <div class="header-left">
            <h1 class="page-title">AI 人脸数据采集</h1>
            <p class="time">HaoTian · 2024-10-14 21:15:08</p>
          </div>
          <div class="header-right">
            <div class="tag-container">
              <span class="tag">AI</span>
            </div>
            <button
              id="themeToggle"
              class="theme-toggle"
              aria-label="Toggle theme"
            >
              <svg
                class="sun-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
              <svg
                class="moon-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
            </button>
            <button
              class="theme-toggle"
              aria-label="Toggle theme"
              style="width: 36px; height: 36px"
              onclick="window.location.href='/md';"
            >
              <svg
                t="1737442501710"
                class="icon"
                viewBox="0 0 1024 1024"
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
                p-id="5258"
                width="20"
                height="20"
              >
                <path
                  d="M883.773793 626.047476c-17.308201 0-31.408337 14.029528-31.408337 31.304983l0 207.437469c0 17.204847-14.098089 31.302937-31.406291 31.302937L203.040834 896.092865c-17.340947 0-31.408337-14.098089-31.408337-31.302937L171.632497 657.352459c0-17.275455-14.099113-31.304983-31.408337-31.304983-17.380856 0-31.444153 14.029528-31.444153 31.304983l0 207.437469c0 51.773154 42.261523 93.91188 94.260827 93.91188l617.918331 0c52.031027 0 94.259804-42.139749 94.259804-93.91188L915.21897 657.352459C915.21897 640.077004 901.152603 626.047476 883.773793 626.047476L883.773793 626.047476zM230.262826 614.286618c55.523571 0 104.556311-27.674293 134.394896-69.762877 32.487925 46.451962 86.303598 77.0744 147.343813 77.0744 61.036122 0 114.846678-30.623461 147.306974-77.0744 29.943986 42.018999 78.902024 69.762877 134.426619 69.762877 90.948385 0 164.968216-73.77526 164.968216-164.371628 0-11.062963-2.342348-22.859637-5.130857-35.178197-0.209778-1.134847 0.031722-2.26867-0.277316-3.38612l-0.629333-2.267647c-0.24764-0.924045-0.140193-1.535983-0.352017-2.547009-0.138146-0.505513-0.521886-0.87288-0.695848-1.39579l-85.364203-316.671313c-3.699252-13.645788-16.051581-23.172769-30.293957-23.172769L187.965487 65.296145c-14.238282 0-26.665313 9.526981-30.360472 23.24133L72.309374 405.1566c-0.103354 0.50756-0.48607 0.820692-0.62524 1.309832-0.210801 0.942465-0.107447 1.639337-0.349971 2.511193l-0.62524 2.373047c-0.318248 1.11745 0 2.25025-0.210801 3.38612-2.863211 12.31856-5.201465 24.115234-5.201465 35.178197C65.295634 540.511357 139.315464 614.286618 230.262826 614.286618L230.262826 614.286618z"
                  fill="currentColor"
                  p-id="5259"
                ></path>
              </svg>
            </button>
          </div>
        </header>

        <!-- Article Content -->
        <article
          class="content-body md md "
        >
          <img src="../imgs/92/02.webp" />

<p>该案例可以对两种场景进行人脸数据采集，一种乃视频中采集，根据对视频中人物面部数据采集来实现，效果如下：</p>
<img src="../imgs/92/03.webp" />

<p>另一种为实时数据采集，利用摄像头实时数据对人脸数据进行采集，这种场景通常用于门卫人脸系统，扫脸支付系统等，当然，随着安全问题的频发，支付扫脸或身份识别系统等较为重要的数据系统程序算法更为严谨，对于 face-api 而言，日常人脸数据采集已完全够用。</p>
<h2>核心代码 index.vue</h2>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h1 style=&quot;text-align: center;&quot;&gt;人脸数据采集&lt;/h1&gt;
    &lt;input
      hidden
      type=&quot;file&quot;
      @change=&quot;setImage&quot;
      accept=&quot;image/*&quot;
      ref=&quot;pickImage&quot;
    /&gt;

    &lt;!--  图片/视频 捕获区  --&gt;
    &lt;div class=&quot;detectBox&quot;&gt;
      &lt;img
        v-show=&quot;!data.trackVideoFaces &amp;&amp; !data.trackCameraFaces&quot;
        :src=&quot;data.base64&quot;
        alt=&quot;&quot;
        width=&quot;500&quot;
        ref=&quot;img&quot;
        id=&quot;myImg&quot;
        @load=&quot;detectFactory&quot;
      /&gt;

      &lt;video
        v-if=&quot;data.trackVideoFaces&quot;
        width=&quot;500&quot;
        ref=&quot;video&quot;
        id=&quot;myVideo&quot;
        muted
        playsinline
        preload
        loop
        @durationchange=&quot;video.play()&quot;
        @play=&quot;data.videoStatus = 1&quot;
        @pause=&quot;data.videoStatus = 0&quot;
      &gt;
        &lt;source src=&quot;./media/shylock.mp4&quot; type=&quot;video/mp4&quot; /&gt;
        &lt;!-- &lt;source src=&quot;./media/1.mp4&quot; type=&quot;video/mp4&quot;&gt; --&gt;
        抱歉，您的浏览器不支持嵌入式视频。
      &lt;/video&gt;

      &lt;video
        v-if=&quot;data.trackCameraFaces&quot;
        ref=&quot;video&quot;
        id=&quot;myVideo&quot;
        autoplay
        muted
        playsinline
        @play=&quot;data.videoStatus = 1&quot;
        @pause=&quot;data.videoStatus = 0&quot;
      /&gt;
      &lt;img
        src=&quot;./images/2.png&quot;
        alt=&quot;&quot;
        class=&quot;shadows&quot;
        ref=&quot;shadow&quot;
        v-if=&quot;data.trackCameraFaces&quot;
      /&gt;

      &lt;canvas ref=&quot;canvas&quot; /&gt;
      &lt;canvas ref=&quot;canvas2&quot; /&gt;
    &lt;/div&gt;

    &lt;section
      v-show=&quot;data.trackVideoFaces || data.trackCameraFaces&quot;
      class=&quot;timer&quot;
    &gt;
      &lt;p&gt;平均检测时长：{{ data.time }}&lt;/p&gt;
      &lt;p&gt;fps：{{ data.fps &gt; 200 ? &#39;200+&#39; : data.fps }}&lt;/p&gt;
    &lt;/section&gt;

    &lt;div class=&quot;bottomBox&quot;&gt;
      &lt;p&gt;
        &lt;van-switch
          v-model=&quot;data.trackVideoFaces&quot;
          :disabled=&quot;data.trackCameraFaces&quot;
          size=&quot;24&quot;
        /&gt;
        视频人脸追踪
      &lt;/p&gt;
      &lt;p&gt;
        &lt;van-switch
          v-model=&quot;data.trackCameraFaces&quot;
          :disabled=&quot;data.trackVideoFaces&quot;
          size=&quot;24&quot;
        /&gt;
        摄像头人脸追踪
      &lt;/p&gt;
    &lt;/div&gt;

    &lt;van-checkbox-group v-model=&quot;data.optionList&quot; @change=&quot;detectFactory&quot;&gt;
      &lt;van-checkbox name=&quot;showBorder&quot;&gt;开始采集&lt;/van-checkbox&gt;
      &lt;!-- &lt;van-checkbox name=&quot;showBorder&quot;&gt;显示人脸边界&lt;/van-checkbox&gt; --&gt;
      &lt;van-checkbox name=&quot;showMark&quot;&gt;显示人脸标记点&lt;/van-checkbox&gt;
    &lt;/van-checkbox-group&gt;

    &lt;!-- 摄像头列表 --&gt;
    &lt;van-popup
      :show=&quot;data.showCameraList&quot;
      position=&quot;bottom&quot;
      round
      :close-on-click-overlay=&quot;false&quot;
    &gt;
      &lt;van-picker
        title=&quot;摄像头列表&quot;
        :columns=&quot;data.cameraList&quot;
        @confirm=&quot;getVideoStream&quot;
        @cancel=&quot;data.showCameraList = false; data.trackCameraFaces = false&quot;
      /&gt;
    &lt;/van-popup&gt;

    &lt;!-- 人脸检测器配置 --&gt;
    &lt;van-popup
      :show=&quot;data.showConfig&quot;
      position=&quot;bottom&quot;
      round
      :close-on-click-overlay=&quot;false&quot;
    &gt;
      &lt;van-picker
        title=&quot;人脸检测器配置&quot;
        :columns=&quot;data.columns&quot;
        @confirm=&quot;selectHandle&quot;
        @cancel=&quot;data.showConfig = false&quot;
        @change=&quot;handleColumnDisabled&quot;
      /&gt;
    &lt;/van-popup&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import * as faceapi from &quot;face-api.js&quot;;
  import { onMounted, reactive, toRefs, watch } from &quot;vue&quot;;

  import { Toast } from &quot;vant&quot;;

  const data = reactive({
    base64: &quot;&quot;,
    similarity: 0, // 相似度
    detectList: [], // 检测项
    optionList: [], // 辅助项
    showSimilar: false, // 人脸相似度比较
    trackVideoFaces: false, // 视频人脸追踪
    trackCameraFaces: false, // 摄像头人脸追踪
    videoStream: &quot;&quot;, // 摄像头视频流
    videoStatus: 0, // 0：暂停，1：播放
    genderTranslator: {
      male: &quot;男&quot;,
      female: &quot;女&quot;,
    },
    expressionTranslator: {
      neutral: &quot;正常&quot;,
      happy: &quot;开心&quot;,
      sad: &quot;伤心&quot;,
      angry: &quot;生气&quot;,
      fearful: &quot;害怕&quot;,
      disgusted: &quot;恶心&quot;,
      surprised: &quot;惊喜&quot;,
    },
    // 检测类型
    detectTypes: [
      &quot;AgeAndGender&quot;, //  年龄性别
      &quot;Expression&quot;, //  表情
      &quot;Face&quot;, //  人脸
    ],
    faces: [], // 录入的人脸描述

    showConfig: false, // 人脸检测器配置弹出层
    columns: [
      {
        values: [
          { text: &quot;SSD&quot;, value: &quot;SSD&quot; },
          { text: &quot;Tiny&quot;, value: &quot;Tiny&quot; },
        ],
        defaultIndex: 1,
      },
      {
        values: [
          { text: &quot;0.1&quot;, value: 0.1 },
          { text: &quot;0.2&quot;, value: 0.2 },
          { text: &quot;0.3&quot;, value: 0.3 },
          { text: &quot;0.4&quot;, value: 0.4 },
          { text: &quot;0.5&quot;, value: 0.5 },
          { text: &quot;0.6&quot;, value: 0.6 },
          { text: &quot;0.7&quot;, value: 0.7 },
          { text: &quot;0.8&quot;, value: 0.8 },
          { text: &quot;0.9&quot;, value: 0.9 },
        ],
        defaultIndex: 4,
      },
      {
        values: [
          { text: &quot;128&quot;, value: 128 },
          { text: &quot;160&quot;, value: 160 },
          { text: &quot;224&quot;, value: 224 },
          { text: &quot;320&quot;, value: 320 },
          { text: &quot;416&quot;, value: 416 },
          { text: &quot;512&quot;, value: 512 },
          { text: &quot;608&quot;, value: 608 },
        ],
        defaultIndex: 3,
      },
    ],
    selectedValue: [&quot;Tiny&quot;, 0.5, 320],

    showCameraList: false, // 摄像头列表弹出层
    cameraList: [],
    videoTrack: null,

    count: 0,
    forwardTimes: [],
    time: &quot;&quot;,
    fps: &quot;&quot;,
  });
  const refs = reactive({
    canvas: null,
    canvas2: null,
    shadow: null,
    img: null,
    video: null,
    pickImage: null,
  });
  const { canvas, canvas2, img, shadow, video, pickImage } = toRefs(refs);

  /**
   * remind
   *
   * const input = await faceapi.fetchImage(uri);
   * */

  /**
   * @description 录入人脸数据
   *
   * 大脸照、黑白照可能识别不出来，可以修改配置，降低人脸的置信度
   * */
  const entryFaces = async () =&gt; {
    const imgs = document.querySelectorAll(&quot;.faceCompare img&quot;);

    for (const img of imgs) {
      /** 注意：这里不能传options，不然会报错 */
      const singleResult = await faceapi
        .detectSingleFace(img)
        .withFaceLandmarks()
        .withFaceDescriptor();
      data.faces = [
        ...data.faces,
        new faceapi.LabeledFaceDescriptors(img.alt, [singleResult.descriptor]),
      ];
    }
  };

  /**
   * @desc 自定义文本描绘框
   *
   * @param {object}  box     - 盒子位置大小
   * @param {object}  options - 配置项
   * */
  const drawLabelBox = (box, options) =&gt; {
    // 绘制框 + 绘制文本
    const _box = { x: 50, y: 50, width: 100, height: 100 };
    const drawOptions = {
      label: &quot;Hello I am a box!&quot;, // 框的描述文字，只能整单行文字
      lineWidth: 2, // 边框宽度
      boxColor: &quot;red&quot;, // 边框颜色，默认蓝色
      drawLabelOptions: {
        anchorPosition: &quot;TOP_LEFT&quot;, // [TOP_LEFT | TOP_RIGHT | BOTTOM_LEFT | BOTTOM_RIGHT]
        backgroundColor: &quot;rgba(0, 0, 0, 0.5)&quot;, // label文字块的背景颜色
        fontColor: &quot;purple&quot;, // label文字颜色
        fontSize: 20, // label文字大小
        padding: 15, // label文字的padding
      },
    };
    const drawAreaBox = new faceapi.draw.DrawBox(
      box || _box,
      options || drawOptions
    );
    drawAreaBox.draw(canvas.value);
  };

  /**
   * @desc 自定义文本字段
   *
   * @param {array}  texts   - 多行文字
   * @param {object} pos     - 文本位置
   * @param {object} options - 配置项
   * */
  const drawTexts = (texts, pos, options) =&gt; {
    // 绘制多行文本块
    const text = [&quot;This is a textline!&quot;, &quot;This is another textline!&quot;];
    const anchor = { x: 200, y: 200 }; // 相对于canvas的位置
    const drawOptions = {
      // backgroundColor: &#39;rgba(0, 0, 0, 0.5)&#39;, // 文字块的背景颜色
      // fontColor: &#39;purple&#39;,                   // 文字颜色
      fontSize: 20, // 文字大小
      // padding: 15                            // 文字的padding
    };

    const drawTextBox = new faceapi.draw.DrawTextField(
      texts || text,
      pos || anchor,
      options || drawOptions
    );
    drawTextBox.draw(canvas.value);
  };

  const detectFactory = async () =&gt; {
    const {
      detectList,
      optionList,
      faces,
      base64,
      trackVideoFaces,
      trackCameraFaces,
      videoStatus,
    } = data;
    const input = trackVideoFaces || trackCameraFaces ? &quot;myVideo&quot; : &quot;myImg&quot;;
    const ts = Date.now();

    if (
      (input === &quot;myImg&quot; &amp;&amp; !base64) ||
      (input === &quot;myVideo&quot; &amp;&amp; !videoStatus)
    ) {
      return;
    }

    let displaySize;

    if (input === &quot;myImg&quot;) {
      displaySize = {
        width: img.value.width,
        height: img.value.height,
      };
    } else {
      displaySize = faceapi.matchDimensions(canvas.value, video.value, true);
    }
    // 准备画布，没有这一步方框位置会偏移
    faceapi.matchDimensions(canvas.value, displaySize);

    const options = getFaceDetectorOptions();

    // 绘制性别年龄
    if (detectList.includes(&quot;AgeAndGender&quot;)) {
      const detections = await faceapi
        .detectAllFaces(input, options)
        .withFaceLandmarks()
        .withAgeAndGender();

      // 调整检测到的盒子和地标的大小，以防显示的图像与原始图像大小不同
      const resizedResults = faceapi.resizeResults(detections, displaySize);

      // 输出年龄、性别、年龄可能性
      resizedResults.forEach((result) =&gt; {
        const { age, gender, genderProbability } = result;

        drawTexts(
          [
            `${data.genderTranslator[gender]} (${
              faceapi.utils.round(genderProbability) * 100
            }%)`,
            `${faceapi.utils.round(age, 0)} 岁 `,
          ],
          result.detection.box.bottomLeft
        );
      });
    }

    // 绘制脸部边界
    if (optionList.includes(&quot;showBorder&quot;)) {
      const detections = await faceapi.detectAllFaces(input, options);

      // 调整检测到的盒子和地标的大小，以防显示的图像与原始图像大小不同
      const resizedDetections = faceapi.resizeResults(detections, displaySize);

      // 绘制方框
      // faceapi.draw.drawDetections(canvas.value, resizedDetections);

      // 自定义输出边界盒子
      resizedDetections.forEach((result) =&gt; {
        const { box, _score } = result;
        // console.log(result,&#39;三观匹配值&#39;);

        if (_score &gt; 0.95) {
          const ctx = canvas2.value.getContext(&quot;2d&quot;);
          ctx.drawImage(
            video.value,
            0,
            0,
            canvas2.value.width,
            canvas2.value.height
          );
          // 将canvas转换为Base64图像
          let base64 = canvas2.value.toDataURL(&quot;image/png&quot;);
          let im = new Image();
          im.src = base64;
          canvas2.value.style.display = &quot;none&quot;;
          document.body.append(im);
          data.trackVideoFaces = false;
          data.trackCameraFaces = false;
          alert(&quot;采集成功！&quot;);
          return;
        }
        drawLabelBox(box, {
          label: `匹配度${Math.round(_score * 100)}%`,
        });
      });
    }

    // 绘制脸部标记点
    if (optionList.includes(&quot;showMark&quot;)) {
      const detections = await faceapi
        .detectAllFaces(input, options)
        .withFaceLandmarks();

      // 调整检测到的盒子和地标的大小，以防显示的图像与原始图像大小不同
      const resizedResults = faceapi.resizeResults(detections, displaySize);

      // 将标记点绘制到画布中
      faceapi.draw.drawFaceLandmarks(canvas.value, resizedResults);
    }

    if (videoStatus) {
      updateTimeStats(Date.now() - ts);

      setTimeout(() =&gt; {
        window.requestAnimationFrame(detectFactory);
      });
    }
  };

  // 计算平均花费时长和FPS
  const updateTimeStats = (timeInMs) =&gt; {
    data.forwardTimes = [timeInMs].concat(data.forwardTimes).slice(0, 30);
    const avgTimeInMs =
      data.forwardTimes.reduce((total, t) =&gt; total + t) /
      data.forwardTimes.length;

    data.time = `${Math.round(avgTimeInMs)} ms`;
    data.fps = `${faceapi.utils.round(1000 / avgTimeInMs)}`;
  };

  // 配置人脸检测器参数
  const getFaceDetectorOptions = () =&gt; {
    const { selectedValue } = data;

    return selectedValue[0] === &quot;SSD&quot;
      ? new faceapi.SsdMobilenetv1Options({
          minConfidence: selectedValue[1],
        })
      : /**
         * @param inputSize?: number
         处理图像的大小，越小越快
         在检测较小的人脸时， 必须被32整除
         常见的大小有128、160、224、320、416、512、608 ,
         用于通过网络摄像头进行人脸跟踪我建议使用较小尺寸的，例如128、160
         用于检测较小的人脸使用较大尺寸的，例如512、608
         默认值： 416
         *  @param scoreThreshold?: number
         最小置信阈值
         默认值:0.5
         *
         * @desc inputSize和scoreThreshold的不同配置，都会影响返回结果的数量
         * */
        new faceapi.TinyFaceDetectorOptions({
          scoreThreshold: selectedValue[1],
          inputSize: selectedValue[2],
        });
  };

  // 控制人脸检测器选项
  const handleColumnDisabled = (allSelected, rowIndex) =&gt; {
    if (rowIndex === 0) {
      data.columns[2].values =
        allSelected[0].value === &quot;SSD&quot;
          ? data.columns[2].values.map((item) =&gt; ({ ...item, disabled: true }))
          : data.columns[2].values.map((item) =&gt; ({
              ...item,
              disabled: false,
            }));
    }
  };

  // 人脸检测器配置项改变
  const selectHandle = (values) =&gt; {
    const { trackVideoFaces, trackCameraFaces } = data;

    data.selectedValue = values.map((item) =&gt; item.value);
    data.showConfig = false;

    // 图片检测，重新加载检测函数，视频不需要（播放时会一直重复调用）
    if (!trackVideoFaces &amp;&amp; !trackCameraFaces) {
      detectFactory();
    }
  };

  // 获取媒体设备列表
  const getMediaDevices = () =&gt; {
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
      Toast.fail({
        message: &quot;不支持 enumerateDevices()&quot;,
        forbidClick: true,
        mask: true,
      });

      return;
    }

    navigator.mediaDevices
      .enumerateDevices()
      .then((devices) =&gt; {
        const cameras = devices
          .filter((item) =&gt; item.kind === &quot;videoinput&quot;)
          .map((item, index) =&gt; ({
            text: item.label || `摄像头${index + 1}`,
            value: item.deviceId,
          }));

        if (cameras.length) {
          data.showCameraList = true;
          data.cameraList = cameras;
        } else {
          Toast.fail({
            message: &quot;未找到网络摄像头&quot;,
            forbidClick: true,
            mask: true,
          });
        }
      })
      .catch((err) =&gt; {
        console.log(err);
      });
  };

  // 请求媒体设备，获取视频流
  const getVideoStream = (deviceId) =&gt; {
    data.showCameraList = false;

    navigator.mediaDevices
      .getUserMedia({
        audio: false,
        video: {
          sourceId: deviceId[0],
        },
      })
      .then(function (stream) {
        video.value.srcObject = stream;
        console.log(video.value.offsetWidth, video.value.offsetHeight);
        shadow.value.width = video.value.offsetWidth;
        shadow.value.height = video.value.offsetHeight * 1.5;

        data.videoTrack = stream.getTracks()[0];
        window.requestAnimationFrame(detectFactory);
      })
      .catch(function () {
        Toast.fail({
          message: &quot;摄像头调用失败&quot;,
          forbidClick: true,
          mask: true,
        });
      });
  };

  // 加载模型
  const init = () =&gt; {
    const toast = Toast.loading({
      duration: 0,
      message: &quot;模型加载中...&quot;,
      forbidClick: true,
      mask: true,
    });

    // 加载训练好的模型np
    // ageGenderNet:          年龄、性别识别模型，大约420KB
    // faceExpressionNet:     人脸表情识别模型，识别表情,开心，沮丧，普通，大约310KB
    // faceLandmark68Net：    68个点人脸地标检测模型（默认模型），大约350KB
    // faceLandmark68TinyNet：68个点人脸地标检测模型（小模型），大约80KB
    // faceRecognitionNet:    人脸识别模型，可以比较任意两个人脸的相似性，大约6.2MB
    // ssdMobilenetv1：       SSD 移动网络 V1，大约5.4MB，准确的最高，推理时间最慢
    // tinyFaceDetector:      微型人脸检测器（实时人脸检测器），与 SSD Mobilenet V1 人脸检测器相比，它速度更快、体积更小且资源消耗更少，但在检测小人脸方面的表现略逊一筹。移动和网络友好
    // mtcnn                  大约2MB
    // tinyYolov2             识别身体轮廓的算法，不知道怎么用
    Promise.all([
      faceapi.nets.faceRecognitionNet.loadFromUri(&quot;./models&quot;),
      faceapi.nets.faceLandmark68Net.loadFromUri(&quot;./models&quot;),
      faceapi.nets.faceLandmark68TinyNet.loadFromUri(&quot;./models&quot;),
      faceapi.nets.ssdMobilenetv1.loadFromUri(&quot;./models&quot;),
      faceapi.nets.tinyFaceDetector.loadFromUri(&quot;./models&quot;),
      faceapi.nets.mtcnn.loadFromUri(&quot;./models&quot;),
      faceapi.nets.faceExpressionNet.loadFromUri(&quot;./models&quot;),
      faceapi.nets.ageGenderNet.loadFromUri(&quot;./models&quot;),
      // faceapi.nets.tinyYolov.loadFromUri(&#39;./models&#39;)
    ])
      .then(() =&gt; {
        entryFaces();
        toast.clear();
      })
      .catch(() =&gt; {
        toast.clear();
      });
  };

  onMounted(() =&gt; {
    init();
  });

  // 监听摄像头
  watch(
    () =&gt; data.trackCameraFaces,
    (newValue) =&gt; {
      if (newValue) {
        getMediaDevices();
      } else {
        // 关闭摄像头
        data.videoTrack?.stop();
      }
    }
  );
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
  /* 图片/视频 捕获区 */
  .detectBox {
    position: relative;
    // min-height: 200px;

    img,
    video {
      width: 100%;
    }

    canvas {
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
  }

  /* 美化样式 */
  .van-button {
    margin: 20px 15px 0 0;
  }

  .van-checkbox-group {
    background: #fff;
    padding: 15px;
    margin-top: 10px;

    .van-checkbox {
      margin-bottom: 10px;
    }
  }

  .bottomBox {
    p {
      display: flex;
      align-items: center;
      margin-top: 10px;
      font-size: 14px;
      background-color: #fff;
      padding: 5px;
      color: #666;
      font-style: italic;

      .van-switch {
        margin-right: 10px;
      }
    }
  }

  .faceCompare,
  .similarity {
    box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.5);
    background-color: #fff;
    padding: 5px;
    margin: 10px 0;
    box-sizing: border-box;

    h2 {
      font-size: 16px;
      margin-bottom: 5px;
    }

    .referenceImgs {
      display: flex;
      justify-content: flex-start;
      text-align: center;

      img {
        width: 100px;
        height: 140px;
        margin-right: 10px;
        display: block;
      }
      span {
        font-size: 12px;
      }
    }
  }

  .danger {
    color: red;
  }

  .timer {
    font-size: 14px;
    line-height: 20px;
    background-color: #fff;
    padding: 5px;
    margin: 10px 0;
    box-sizing: border-box;
  }
  .shadows {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1000;
  }
&lt;/style&gt;
</code></pre>

        </article>
      </main>

      <!-- Table of Contents Sidebar -->
      <aside class="toc-sidebar">
        <div class="toc-header">
          <h3>Table of Contents</h3>
        </div>
        <div class="toc-content" id="tocContent">
          <!-- TOC will be generated dynamically -->
        </div>
      </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M12 19V5M5 12l7-7 7 7" />
      </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(
          135deg,
          var(--accent),
          rgba(59, 130, 246, 0.8)
        );
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
      @media screen and (max-width: 768px) {
        .back-to-top {
          right: 15px;
          bottom: 15px;
          width: 36px;
          height: 36px;
        }
      }

      @media screen and (max-width: 480px) {
        .back-to-top {
          right: 12px;
          bottom: 12px;
          width: 32px;
          height: 32px;
        }
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // Sidebar Toggle
      const toggleBtn = document.getElementById("toggleSidebar");
      const sidebar = document.querySelector(".sidebar");
      const mainContent = document.querySelector(".main-content");

      function toggleSidebar() {
        sidebar.classList.toggle("hidden");
        // Store sidebar state in localStorage
        localStorage.setItem(
          "sidebarHidden",
          sidebar.classList.contains("hidden")
        );
      }

      toggleBtn.addEventListener("click", toggleSidebar);

      // Keyboard shortcut (Ctrl + B)
      window.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "b") {
          e.preventDefault(); // Prevent browser's default behavior
          toggleSidebar();
        }
      });

      // Restore sidebar state from localStorage
      document.addEventListener("DOMContentLoaded", () => {
        const sidebarHidden = localStorage.getItem("sidebarHidden") === "true";
        if (sidebarHidden) {
          sidebar.classList.add("hidden");
        }
      });

      // Generate Table of Contents
      function generateTOC() {
        const article = document.querySelector(".content-body");
        const headings = article.querySelectorAll("h1, h2, h3, h4");
        const tocContent = document.getElementById("tocContent");
        const toc = document.createElement("ul");

        headings.forEach((heading, index) => {
          const id = `heading-${index}`;
          heading.id = id;

          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = `#${id}`;
          a.textContent = heading.textContent;
          a.className = `toc-level-${heading.tagName.toLowerCase()}`;

          li.appendChild(a);
          toc.appendChild(li);
        });

        tocContent.appendChild(toc);
      }

      // Initialize TOC
      document.addEventListener("DOMContentLoaded", generateTOC);

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }

      // 监听 ctrl + b
      window.addEventListener("keydown", (e) => {
        const leftDom = document.querySelector(".sidebar");
        if (e.ctrlKey && e.key === "b") {
          leftDom.classList.toggle("hidden");
        }
      });

      // Modal
      // const modal = document.getElementById("myModal");
      // const modalContent = modal.querySelector(".modal-content");
      // const openModal = document.getElementById("openModal");
      // const close = modal.querySelector(".close");

      // openModal.addEventListener("click", () => {
      //     modal.style.display = "block";
      // });

      // close.addEventListener("click", () => {
      //     modal.style.display = "none";
      // });

      // window.addEventListener("click", (e) => {
      //     if (e.target === modal) {
      //         modal.style.display = "none";
      //     }
      // });

      // Back to top button
      const backToTop = document.getElementById("backToTop");
      window.addEventListener("scroll", () => {
        if (window.scrollY > 200) {
          backToTop.style.display = "block";
        } else {
          backToTop.style.display = "none";
        }
      });

      backToTop.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      // Theme toggle
      document.addEventListener("DOMContentLoaded", () => {
        const themeToggle = document.getElementById("themeToggle");
        const html = document.documentElement;
        const prismTheme = document.getElementById("prismTheme");

        // Function to update theme and stylesheet
        function updateTheme(theme) {
          html.className = theme;
          prismTheme.href = `../css/prism${theme === "dark" ? "2" : ""}.css`;
          localStorage.setItem("theme", theme);
        }

        // Check for saved theme preference
        const savedTheme = localStorage.getItem("theme") || "light";
        updateTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const currentTheme = html.className;
          const newTheme = currentTheme === "light" ? "dark" : "light";
          updateTheme(newTheme);
        });
      });
    </script>
  </body>
</html>
