<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>抢先体验！超强大的 Anchor Positioning 锚点定位</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>

  <body>
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 0">
          <div class="layout__main_left-switch"></div>
          <ul>
            <li class=""><a title="哪个 css 格式化工具是你的首选" href="/md/哪个 css 格式化工具是你的首选.html">60 哪个 css 格式化工具是你的首选</a></li><li class=""><a title="CSS 选择器详解 12 个必知用法与最佳实践" href="/md/CSS 选择器详解 12 个必知用法与最佳实践.html">59 CSS 选择器详解 12 个必知用法与最佳实践</a></li><li class=""><a title="动态视口单位之 dvh、svh、lvh" href="/md/动态视口单位之 dvh、svh、lvh.html">58 动态视口单位之 dvh、svh、lvh</a></li><li class=""><a title="不规则造型按钮解决方案" href="/md/不规则造型按钮解决方案.html">57 不规则造型按钮解决方案</a></li><li class=""><a title="不定宽文本溢出跑马灯效果完美解决方案" href="/md/不定宽文本溢出跑马灯效果完美解决方案.html">56 不定宽文本溢出跑马灯效果完美解决方案</a></li><li class=""><a title="巧用 CSS 变量，实现动画函数复用" href="/md/巧用 CSS 变量，实现动画函数复用.html">55 巧用 CSS 变量，实现动画函数复用</a></li><li class=""><a title="角向渐变的妙用" href="/md/角向渐变的妙用.html">54 角向渐变的妙用</a></li><li class=""><a title="有趣的六芒星能力图动画" href="/md/有趣的六芒星能力图动画.html">53 有趣的六芒星能力图动画</a></li><li class=""><a title="有意思的气泡 Loading 效果" href="/md/有意思的气泡 Loading 效果.html">52 有意思的气泡 Loading 效果</a></li><li class=""><a title="CSS 原生支持的三角函数" href="/md/CSS 原生支持的三角函数.html">51 CSS 原生支持的三角函数</a></li><li class=""><a title="有意思的网格下落加载效果" href="/md/有意思的网格下落加载效果.html">50 有意思的网格下落加载效果</a></li><li class=""><a title="有意思的 Emoji 3D 表情切换效果" href="/md/有意思的 Emoji 3D 表情切换效果.html">49 有意思的 Emoji 3D 表情切换效果</a></li><li class=""><a title="神奇的 3D 磨砂玻璃透视效果" href="/md/神奇的 3D 磨砂玻璃透视效果.html">48 神奇的 3D 磨砂玻璃透视效果</a></li><li class="active"><a title="抢先体验！超强大的 Anchor Positioning 锚点定位" href="/md/抢先体验！超强大的 Anchor Positioning 锚点定位.html">47 抢先体验！超强大的 Anchor Positioning 锚点定位</a></li><li class=""><a title="CSS 也能实现碰撞检测" href="/md/CSS 也能实现碰撞检测.html">46 CSS 也能实现碰撞检测</a></li><li class=""><a title="现代 CSS 解决方案 - 数学函数 Round" href="/md/现代 CSS 解决方案 - 数学函数 Round.html">45 现代 CSS 解决方案 - 数学函数 Round</a></li><li class=""><a title="现代 CSS 解决方案 - 原生嵌套" href="/md/现代 CSS 解决方案 - 原生嵌套.html">44 现代 CSS 解决方案 - 原生嵌套</a></li><li class=""><a title="神奇的背景，生化危机4日食 Loading 动画还原" href="/md/神奇的背景，生化危机4日食 Loading 动画还原.html">43 神奇的背景，生化危机4日食 Loading 动画还原</a></li><li class=""><a title="当路径动画遇到滚动驱动" href="/md/当路径动画遇到滚动驱动.html">42 当路径动画遇到滚动驱动</a></li><li class=""><a title="CSS 还原拉斯维加斯球数字动画" href="/md/CSS 还原拉斯维加斯球数字动画.html">41 CSS 还原拉斯维加斯球数字动画</a></li><li class=""><a title="单标签下多色块随机文字随机颜色动画" href="/md/单标签下多色块随机文字随机颜色动画.html">40 单标签下多色块随机文字随机颜色动画</a></li><li class=""><a title="CSS 也能实现 if 判断？实现动态高度下的不同样式展现" href="/md/CSS 也能实现 if 判断？实现动态高度下的不同样式展现.html">39 CSS 也能实现 if 判断？实现动态高度下的不同样式展现</a></li><li class=""><a title="Flex 布局下居中溢出滚动截断问题" href="/md/Flex 布局下居中溢出滚动截断问题.html">38 Flex 布局下居中溢出滚动截断问题</a></li><li class=""><a title="带圆角的虚线边框" href="/md/带圆角的虚线边框.html">37 带圆角的虚线边框</a></li><li class=""><a title="现代 CSS 解决方案：文字颜色自动适配背景色" href="/md/现代 CSS 解决方案：文字颜色自动适配背景色.html">36 现代 CSS 解决方案：文字颜色自动适配背景色</a></li><li class=""><a title="神奇的 3D 卡片反光闪烁动效" href="/md/神奇的 3D 卡片反光闪烁动效.html">35 神奇的 3D 卡片反光闪烁动效</a></li><li class=""><a title="现代 CSS 解决方案：accent-color 强调色" href="/md/现代 CSS 解决方案：accent-color 强调色.html">34 现代 CSS 解决方案：accent-color 强调色</a></li><li class=""><a title="巧用 has 和 drop-shadow 实现复杂布局效果" href="/md/巧用 has 和 drop-shadow 实现复杂布局效果.html">33 巧用 has 和 drop-shadow 实现复杂布局效果</a></li><li class=""><a title="巧用 CSS + SVG 实现复杂线条光效动画" href="/md/巧用 CSS + SVG 实现复杂线条光效动画.html">32 巧用 CSS + SVG 实现复杂线条光效动画</a></li><li class=""><a title="极具创意的鼠标交互动画" href="/md/极具创意的鼠标交互动画.html">31 极具创意的鼠标交互动画</a></li><li class=""><a title="标准滚动条控制规范 scrollbar-color 和 scrollbar-width" href="/md/标准滚动条控制规范 scrollbar-color 和 scrollbar-width.html">30 标准滚动条控制规范 scrollbar-color 和 scrollbar-width</a></li><li class=""><a title="类 ChatGpt 多行文本打字效果" href="/md/类 ChatGpt 多行文本打字效果.html">29 类 ChatGpt 多行文本打字效果</a></li><li class=""><a title="神奇的卡片 Hover 效果与 Blur 的特性探究" href="/md/神奇的卡片 Hover 效果与 Blur 的特性探究.html">28 神奇的卡片 Hover 效果与 Blur 的特性探究</a></li><li class=""><a title="渐变边框文字效果" href="/md/渐变边框文字效果.html">27 渐变边框文字效果</a></li><li class=""><a title="巧妙使用多种方式实现单侧阴影" href="/md/巧妙使用多种方式实现单侧阴影.html">26 巧妙使用多种方式实现单侧阴影</a></li><li class=""><a title="全尺寸的带圆角的渐变边框" href="/md/全尺寸的带圆角的渐变边框.html">25 全尺寸的带圆角的渐变边框</a></li><li class=""><a title="开发中保证你用得到的 css 小技巧" href="/md/开发中保证你用得到的 css 小技巧.html">24 开发中保证你用得到的 css 小技巧</a></li><li class=""><a title="您应该了解的 15 个有用的 CSS 属性" href="/md/您应该了解的 15 个有用的 CSS 属性.html">23 您应该了解的 15 个有用的 CSS 属性</a></li><li class=""><a title="CSS 行元素的截断样式 box-decoration-break 属性" href="/md/CSS 行元素的截断样式 box-decoration-break 属性.html">22 CSS 行元素的截断样式 box-decoration-break 属性</a></li><li class=""><a title="用 SASS 简化媒体查询" href="/md/用 SASS 简化媒体查询.html">21 用 SASS 简化媒体查询</a></li><li class=""><a title="为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式" href="/md/为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式.html">20 为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式</a></li><li class=""><a title="sass 优化响应式布局代码" href="/md/sass 优化响应式布局代码.html">19 sass 优化响应式布局代码</a></li><li class=""><a title="盘点 CSS 文本两端对齐的 N 种方式" href="/md/盘点 CSS 文本两端对齐的 N 种方式.html">18 盘点 CSS 文本两端对齐的 N 种方式</a></li><li class=""><a title="如何修改滚动条的样式" href="/md/如何修改滚动条的样式.html">17 如何修改滚动条的样式</a></li><li class=""><a title="CSS 模拟图片透明的棋盘背景" href="/md/CSS 模拟图片透明的棋盘背景.html">16 CSS 模拟图片透明的棋盘背景</a></li><li class=""><a title="文本描边完美实现" href="/md/文本描边完美实现.html">15 文本描边完美实现</a></li><li class=""><a title="你需要自定义 @property 而不是 CSS 变量的情况" href="/md/你需要自定义 @property 而不是 CSS 变量的情况.html">14 你需要自定义 @property 而不是 CSS 变量的情况</a></li><li class=""><a title="从高度 0 过渡到自动高度" href="/md/从高度 0 过渡到自动高度.html">13 从高度 0 过渡到自动高度</a></li><li class=""><a title="一些 css 语法解释" href="/md/一些 css 语法解释.html">12 一些 css 语法解释</a></li><li class=""><a title="scss 日常用法" href="/md/scss 日常用法.html">11 scss 日常用法</a></li><li class=""><a title="sass 指南" href="/md/sass 指南.html">10 sass 指南</a></li><li class=""><a title="CSS 颜色设置透明度的新姿势" href="/md/CSS 颜色设置透明度的新姿势.html">09 CSS 颜色设置透明度的新姿势</a></li><li class=""><a title="CSS 属性 appearance" href="/md/CSS 属性 appearance.html">08 CSS 属性 appearance</a></li><li class=""><a title="CSS 动画性能优化" href="/md/CSS 动画性能优化.html">07 CSS 动画性能优化</a></li><li class=""><a title="CSS 功能特性" href="/md/CSS 功能特性.html">06 CSS 功能特性</a></li><li class=""><a title="CSS 中的 var() 函数" href="/md/CSS 中的 var() 函数.html">05 CSS 中的 var() 函数</a></li><li class=""><a title="15 个你不知道的 CSS 属性" href="/md/15 个你不知道的 CSS 属性.html">04 15 个你不知道的 CSS 属性</a></li><li class=""><a title="will-change" href="/md/will-change.html">03 will-change</a></li><li class=""><a title="normalize.css 清除元素默认样式" href="/md/normalize.css 清除元素默认样式.html">02 normalize.css 清除元素默认样式</a></li><li class=""><a title="纯 CSS 获取屏幕宽高" href="/md/纯 CSS 获取屏幕宽高.html">01 纯 CSS 获取屏幕宽高</a></li>
          </ul>
        </div>
        <div
          style="order: 1"
          class="layout__main_right md "
        >
          <div class="page-header">
            
            <a href="/md/" class="back-button"
              ><svg t="1737007603776" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4546" width="200" height="200"><path d="M853.333333 245.333333H245.333333l93.866667-93.866666c12.8-12.8 12.8-34.133333 0-46.933334-12.8-12.8-34.133333-12.8-46.933333 0l-145.066667 145.066667c-12.8 12.8-12.8 34.133333 0 46.933333l145.066667 145.066667c6.4 6.4 14.933333 10.666667 23.466666 10.666667s17.066667-4.266667 23.466667-10.666667c12.8-12.8 12.8-34.133333 0-46.933333L256 311.466667h597.333333c6.4 0 10.666667 4.266667 10.666667 10.666666v426.666667c0 6.4-4.266667 10.666667-10.666667 10.666667H170.666667c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32h682.666666c40.533333 0 74.666667-34.133333 74.666667-74.666667V320c0-40.533333-34.133333-74.666667-74.666667-74.666667z" fill="#ffffff" p-id="4547"></path></svg></a>
            
            <h1>抢先体验！超强大的 Anchor Positioning 锚点定位</h1>
            <p class="time">HaoTian · 2024-12-17 10:44:23</p>
          </div>
          <p>本文，将向大家介绍 CSS 规范中，最新的 Anchor Positioning，翻译为<strong>锚点定位</strong>。</p>
<p>Anchor Position 的出现，极大的丰富了 CSS 的能力，虽然语法稍显复杂，但是有了它，能够实现非常多之前实现起来非常困难，或者压根无法使用纯 CSS 实现的功能。</p>
<p>Anchor Position 当前仍属于实验室功能，新版本 Chrome 开启该功能：</p>
<ol>
<li>浏览器 URL 输入框输入： <code>chrome://flags/</code></li>
<li>找到 <code>Experimental Web Platform features</code> 选项，开启该功能</li>
</ol>
<h2>何为 Anchor Positioning？</h2>
<p>那么，什么是 Anchor Positioning 呢？</p>
<p>Anchor Positioning 由规范 <a href="https://www.w3.org/TR/css-anchor-position-1/">CSS Anchor Positioning</a> 提出定义。</p>
<p>规范是这么描述的：<code>CSS absolute positioning allows authors to place elements anywhere on the page, without regard to the layout of other elements besides their containing block. This flexibility can be very useful, but also very limiting—often you want to position relative to some other element. Anchor positioning (via the anchor functions anchor() and anchor-size()) allows authors to achieve this, &quot;anchoring&quot; an absolutely-positioned element to one or more other elements on the page, while also allowing them to try several possible positions to find the &quot;best&quot; one that avoids overlap/overflow.</code></p>
<p>简单翻译一下，其核心就在于，Anchor Positioning（锚点定位） 用于<strong>增强元素的绝对定位的能力</strong>。Anchor Positioning（锚点定位）允许我们基于其它锚点元素的位置和尺寸去定位上下文，而不是传统意义上的基于父元素去进行绝对定位。</p>
<p>整个 Anchor Positioning 到底是干啥的？其重点总结如下：</p>
<ol>
<li>首先，锚点定位，需要我们通过新的锚点名称（<code>anchor-name</code>）来标记元素，允许我们使用这些经过了标记的元素作为我们绝对定位的基准目标；</li>
<li>其次，我们可以在绝对定位的元素上，通过新的语法 <code>anchor()</code> 或者 <code>anchor-size()</code> 来锚定上述被标记了的元素，并且可以使用被标记元素的相应属性（譬如被标记元素的 top、left、right、bottom 等）</li>
<li>并且，还有一些更高级的用法，譬如锚点定位的 Fallback 机制，也就是可以设置多套不同的锚点定位规则，以适应更为复杂的页面布局情况</li>
</ol>
<p>下面，我们通过一个最简单的例子，快速理解，到底什么是锚点定位。</p>
<p>假设，我们有如下代码结构：</p>
<pre><code class="language-html">&lt;div class=&quot;g-container&quot;&gt;
  &lt;div class=&quot;g-use-anchor&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;g-anchor-element&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.g-container {
  position: relative;
  width: 50vw;
  height: 50vh;
  border: 2px solid #666;
  display: flex;

  .g-anchor-element {
    width: 25vw;
    height: 25vh;
    border: 2px dashed #333;
    margin: auto;
  }

  .g-use-anchor {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #fc0;
    border-radius: 50%;
  }
}
</code></pre>
<p>整个，会是这么个效果：</p>
<img src="../imgs/123/01.png" />

<p>需要简单解读一下这个结构：</p>
<img src="../imgs/123/02.png" />

<p>这个很好理解，<strong>注意，此时此刻，<code>.g-use-anchor</code> 由于是绝对定位，是相对于它的父容器 <code>.g-container</code> 进行定位的</strong>。</p>
<p>而 Anchor Positioning 锚点定位，就允许我们，在上述情况下，改变 <code>.g-use-anchor</code> 的绝对定位的基准元素，允许它在绝对定位下，不再相对于父容器定位，而是相对于设定了 <code>anchor-name</code> 的锚点元素进行定位。</p>
<p>所以，下面，我们尝试将 <code>.g-anchor-element</code> 变成一个锚点元素。</p>
<p>代码如下：</p>
<pre><code class="language-css">.g-container {
  position: relative;
  width: 50vw;
  height: 50vh;
  border: 2px solid #666;
  display: flex;

  .g-anchor-element {
    width: 25vw;
    height: 25vh;
    border: 2px dashed #333;
    margin: auto;
    anchor-name: --target;
  }

  .g-use-anchor {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #fc0;
    border-radius: 50%;
    top: anchor(--target top);
    left: anchor(--target left);
  }
}
</code></pre>
<p>上面的代码，有哪些改动呢？</p>
<ol>
<li>我们给 <code>.g-anchor-element</code> 添加了一句 CSS 代码，<code>anchor-name: --target</code>，其含义为，将此元素设定为一个锚点元素，它的名字是 <code>--target</code>。</li>
<li>在 <code>.g-use-anchor</code> 中，新增了两句代码</li>
</ol>
<ul>
<li><code>top: anchor(--target top)</code>：这里的意思是，使用 name 为 <code>--target</code> 的锚点元素作为定位基准，并且将元素的顶部（top）对齐到锚点元素的顶部（top）</li>
<li><code>left: anchor(--target left)</code>：同理，使用 name 为 <code>--target</code> 的锚点元素作为定位基准，并且将元素的左边（left）对齐到锚点元素的左边（left）</li>
</ul>
<p>如此一来，我们就得到了这么一个效果：</p>
<img src="../imgs/123/03.png" />

<p>也就是这么一层关系：</p>
<img src="../imgs/123/04.png" />

<p>完整的代码，你可以戳这里：<a href="https://codepen.io/Chokcoco/pen/JjegrBN?editors=1100">CodePen Demo -- Anchor Positioning Demo</a></p>
<p>到这里，聪明的你应该能够深刻体会到，上面我们说的这一句话的含义了：</p>
<p>Anchor Positioning（锚点定位） 用于<strong>增强元素的绝对定位的能力</strong>。Anchor Positioning（锚点定位）允许我们基于其它锚点元素的位置和尺寸去定位上下文，而不是传统意义上的基于父元素去进行绝对定位。</p>
<h2>Anchor Positioning 锚点定位实战 -- 弹出框定位</h2>
<p>可以说，很多之前无法使用 CSS 实现的功能，因为 Anchor Positioning，迎来了新的转机。</p>
<p>首先，我们来看这么一个功能点，我们的页面有很多需要 Hover 的时候弹出的 Popover 或者 Tooltip，像是这样：</p>
<img src="../imgs/123/01.gif" />

<p>每次 Hover 的时候，弹出框的位置，其实都是需要实时通过 JavaScript 进行计算的。但是在有了 <code>Anchor Positioning</code> 后，我们可以把每一个被 Hover 需要弹出弹出框的元素，都设置成一个<strong>锚点元素</strong>，而我们的弹出框，只需要在 Hover 的时候，基于当前的锚点元素进行定位即可。</p>
<p>听起来很复杂，我们来实现一遍试试：</p>
<pre><code class="language-html">&lt;p class=&quot;g-container&quot;&gt;
  Lorem ipsum dolor sit amet consectetur adipisicing elit. Quod, porro,
  &lt;span&gt;facere&lt;/span&gt;, et incidunt error aliquam fugit pariatur eos labore ipsum
  voluptate magni culpa reiciendis optio at accusantium non! Quis, laboriosam.
  Lorem ipsum dolor sit, &lt;span&gt;amet consectetur&lt;/span&gt; adipisicing elit. Error
  commodi sequi perspiciatis ipsa veniam, aut, aliquam maiores quasi
  &lt;span&gt;adipisci tenetur &lt;/span&gt;reiciendis dolor nihil aperiam labore, sunt qui
  ullam aspernatur &lt;span&gt;voluptate&lt;/span&gt;.
&lt;/p&gt;
</code></pre>
<p>在 <code>&lt;p&gt;</code> 元素下，被包裹了 <code>&lt;span&gt;</code> 的文字就是需要 Hover 的时候弹出内容的元素。</p>
<pre><code class="language-css">p {
  position: relative;

  span {
    color: deeppink;
  }

  &amp;::before,
  &amp;::after {
    position: absolute;
    transition: 0;
    opacity: 0;
  }

  &amp;::before {
    content: &quot;&quot;;
    top: calc(anchor(var(--target) top) + 10px);
    left: calc(anchor(var(--target) left) + 5px);
    border: 8px solid transparent;
    border-bottom: 8px solid #000;
  }
  &amp;::after {
    content: &quot;Alert Tips!&quot;;
    width: 80px;
    padding: 2px 4px;
    font-size: 14px;
    background: #fff;
    border: 2px solid #000;
    top: calc(anchor(var(--target) top) + 24px);
    left: anchor(var(--target) left);
    right: anchor(var(--target) right);
  }
}

p span:nth-child(1) {
  anchor-name: --anchor-1;
}
p span:nth-child(2) {
  anchor-name: --anchor-2;
}
p span:nth-child(3) {
  anchor-name: --anchor-3;
}
p span:nth-child(4) {
  anchor-name: --anchor-4;
}

p:has(span:nth-child(1):hover) {
  --target: --anchor-1;
}
p:has(span:nth-child(2):hover) {
  --target: --anchor-2;
}
p:has(span:nth-child(3):hover) {
  --target: --anchor-3;
}
p:has(span:nth-child(4):hover) {
  --target: --anchor-4;
}

p:has(span:hover)::before,
p:has(span:hover)::after {
  opacity: 1;
}
</code></pre>
<p>这里的代码，有点长，简单解释一下：</p>
<ol>
<li>通过 <code>&lt;p&gt;</code> 元素的两个伪元素 <code>::before</code> 和 <code>::after</code>，实现了弹出框的框体和一个小三角形</li>
<li>给每个 <code>&lt;span&gt;</code> 都设置了成了锚点，也就是这么一段代码：<code>p span:nth-child(1) {anchor-name: --anchor-1;}</code></li>
<li>关键来了，利用了 <code>:has</code> 选择器，实现了当哪个 <code>&lt;span&gt;</code> 被 hover，则设置 <code>--target</code> 变量为当前元素的 <code>anchor-name</code>，也就是实现了锚点元素的动态变换</li>
<li>最终，只需要让弹出框（也就是两个伪元素），基于 <code>--target</code> 进行定位即可，而 <code>--target</code> 元素，就是我们每次 Hover 的文字元素，那么弹框也就实现了动态定位</li>
</ol>
<blockquote>
<p>知识补充，<code>:has</code> 选择器变相让 CSS 拥有了父选择器的能力，此选择器用于选择包含指定子元素的父元素，而本例中，利用了 <code>:has</code> 选择器甚至能选择包含指定伪类状态的能力，实现了 <code>--target</code> 的动态切换。</p>
</blockquote>
<p>这样，我们就成功了实现了上述的功能：</p>
<img src="../imgs/123/02.gif" />

<p>当然，这里还需要继续补充一个基于 <code>anchor()</code> 方法的基础知识，<code>anchor()</code> 方法的值也能与 <code>calc</code> 搭配使用，因此，需要理解如下的表达式：</p>
<ul>
<li><code>top: calc(anchor(var(--target) top) + 10px)</code>：将弹框元素的顶部（top）对齐到锚点元素的顶部（top），再加上 <code>10px</code> 的向上间距</li>
<li><code>left: calc(anchor(var(--target) left) + 5px)</code>：将弹框元素的左边（left）对齐到锚点元素的左边（left），再加上 <code>5px</code> 的左间距</li>
</ul>
<p>还有，如果页面内有 100 个 <code>&lt;span&gt;</code> 那下面这样的代码将会是噩梦性的重复工作：</p>
<pre><code class="language-css">p span:nth-child(1) {
  anchor-name: --anchor-1;
}
p span:nth-child(2) {
  anchor-name: --anchor-2;
}
p span:nth-child(3) {
  anchor-name: --anchor-3;
}
p span:nth-child(4) {
  anchor-name: --anchor-4;
}

p:has(span:nth-child(1):hover) {
  --target: --anchor-1;
}
p:has(span:nth-child(2):hover) {
  --target: --anchor-2;
}
p:has(span:nth-child(3):hover) {
  --target: --anchor-3;
}
p:has(span:nth-child(4):hover) {
  --target: --anchor-4;
}
</code></pre>
<p>因此，我们需要借助 SCSS/SASS/LESS 等预处理简化代码，譬如这样：</p>
<pre><code class="language-css">@for $i from 1 to 100 {
  p:has(span:nth-child(#{$i}):hover) {
    --target: --anchor-#{$i};
  }
  p span:nth-child(#{$i}) {
    anchor-name: --anchor-#{$i};
  }
}
</code></pre>
<p>合理利用预处理器的循环等功能，能有效提升我们的编码效率。</p>
<p>OK，完整的代码，你可以戳这里：</p>
<p><a href="https://codepen.io/Chokcoco/pen/wvQVoXO">CodePen Demo -- Anchor Positioning Demo</a></p>
<h2>Anchor Positioning 锚点定位实战 -- Tab 切换下划线跟随效果</h2>
<p>OK，我们继续，再来一个有意思的实战演练。</p>
<p>基于 Anchor Positioning，能否实现这样一个 TAB 切换时候的，下划线跟随效果呢？</p>
<img src="../imgs/123/03.gif" />

<p>此类效果，在之前，一定是需要 JavaScript 的介入才可能实现的。在很久之前，我尝试使用 CSS 实现过类似的效果：<a href="https://github.com/chokcoco/iCSS/issues/33">不可思议的 CSS 导航栏下划线跟随效果</a>，效果上有很多瑕疵：</p>
<img src="../imgs/123/04.gif" />

<p>而有了 Anchor Positioning 后，我们将可以完美的实现 Tab 切换过程中的下划线跟随效果。</p>
<p>假设，我们的 TAB 的结构如下：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;下&lt;/li&gt;
  &lt;li&gt;划&lt;/li&gt;
  &lt;li&gt;线&lt;/li&gt;
  &lt;li&gt;跟&lt;/li&gt;
  &lt;li&gt;随&lt;/li&gt;
  &lt;li&gt;动&lt;/li&gt;
  &lt;li&gt;画&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>其核心流程和上面的弹出框流程非常类似：</p>
<ol>
<li>下划线通过 <code>&lt;ul&gt;</code>元素的伪元素实现</li>
<li>给每个 <code>&lt;li&gt;</code> 都设置了成了锚点</li>
<li>利用了 <code>:has</code> 选择器，实现当任意一个 <code>&lt;li&gt;</code> 被 hover，则设置 <code>--target</code> 锚点变量为当前的 <code>&lt;li&gt;</code> 元素，也就是实现了锚点元素的动态变换</li>
<li>最终，只需要让下划线，基于动态的锚点进行定位即可，也就是我们每次 Hover 的 li 元素，那么弹框也就实现下划线动态定位</li>
<li>给下划线的 <code>left</code> 设置过渡效果 <code>transition</code>，实现跟随动画效果</li>
</ol>
<p>让我们一起来看看代码，看似复杂，代码量也很少：</p>
<pre><code class="language-css">ul {
  position: relative;
  width: 700px;
  display: flex;

  li {
    flex-grow: 1;
  }

  &amp;::before {
    position: absolute;
    content: &quot;&quot;;
    height: 5px;
    background: transparent;
    bottom: 0;
    left: anchor(var(--target) left);
    right: anchor(var(--target) right);
    transition: 0.3s all;
    transform: scaleX(5);
  }
}

ul:hover::before {
  background: #000;
  transform: scaleX(1);
}

@for $i from 1 to 8 {
  ul:has(li:nth-child(#{$i}):hover) {
    --target: --anchor-#{$i};
  }
  li:nth-child(#{$i}) {
    anchor-name: --anchor-#{$i};
  }
}
</code></pre>
<p>需要好好理解一下这段代码，其本质就在于，<strong>Hover 的时候，利用 <code>:has</code> 动态改变了 <code>--target</code> 锚点元素，让伪元素实现的下划线的宽度，设置为锚点的宽度</strong>。</p>
<p>并且，这里还加了一个 hover 过程中 <code>transform: scaleX(5)</code> 到 <code>transform: scaleX(1)</code> 的变化，属于锦上添花，删掉不影响最终效果。</p>
<p>当然，也利用了 SCSS 循环，减少了代码量。最终的效果就如我们上面 Gif 图演示般：</p>
<img src="../imgs/123/05.gif" />

<p>并且，可以做到适配 Flex 弹性布局各种情况。</p>
<p>这样，我们就实现了在之前，完全不敢想象能够由 CSS 独立实现的功能，完整的代码，你可以戳这里：<a href="https://codepen.io/Chokcoco/pen/JjegMRq">CodePen Demo -- Anchor Positioning Demo</a></p>
<h2>兼容性</h2>
<p>OK，大家肯定非常关系如此强大的功能的兼容性。</p>
<p>目前，Anchor Positioning 还处于较早期的版本，甚至乎我在 Can i Use 上还查不到它的兼容性：</p>
<img src="../imgs/123/05.png" />

<p>但是，目前我使用的 Chrome 115.0.5790.102 是能够跑通上面的所有代码。</p>
<p>Anchor Position 当前仍属于实验室功能，新版本 Chrome 开启该功能：</p>
<ol>
<li>浏览器 URL 输入框输入： chrome://flags/</li>
<li>找到 Experimental Web Platform features 选项，开启该功能</li>
</ol>
<p>并且，Anchor Positioning 还有非常多的语法以及有意思的实战技巧，在本文是没有放出来的。我会在 Anchor Positioning 兼容性更加明朗后，补充一篇更为详细的教学文章。只能说，未来可期。</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>
    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      const switchBtn = document.querySelector(".layout__main_left-switch");
      const left = document.querySelector(".layout__main_left");

      // li active 滚动到中间位置
      const liA = document.querySelector(".layout__main_left li.active");
      if (liA) {
        liA.scrollIntoView({
          behavior: "smooth", // 平滑滚动
          block: "center", // 垂直方向滚动到视口中间
        });
      }

      switchBtn.addEventListener("click", () => {
        left.classList.toggle("show");
      });

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }
    </script>
  </body>
</html>
