<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>盘点 CSS 文本两端对齐的 N 种方式</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism2.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>
  <body class="line-numbers">
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 2">
          <ul>
            <li class=""><a title="开发中保证你用得到的 css 小技巧" href="/md/开发中保证你用得到的 css 小技巧.html">24 开发中保证你用得到的 css 小技巧</a></li><li class=""><a title="您应该了解的 15 个有用的 CSS 属性" href="/md/您应该了解的 15 个有用的 CSS 属性.html">23 您应该了解的 15 个有用的 CSS 属性</a></li><li class=""><a title="CSS 行元素的截断样式 box-decoration-break 属性" href="/md/CSS 行元素的截断样式 box-decoration-break 属性.html">22 CSS 行元素的截断样式 box-decoration-break 属性</a></li><li class=""><a title="用 SASS 简化媒体查询" href="/md/用 SASS 简化媒体查询.html">21 用 SASS 简化媒体查询</a></li><li class=""><a title="为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式" href="/md/为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式.html">20 为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式</a></li><li class=""><a title="sass 优化响应式布局代码" href="/md/sass 优化响应式布局代码.html">19 sass 优化响应式布局代码</a></li><li class="active"><a title="盘点 CSS 文本两端对齐的 N 种方式" href="/md/盘点 CSS 文本两端对齐的 N 种方式.html">18 盘点 CSS 文本两端对齐的 N 种方式</a></li><li class=""><a title="如何修改滚动条的样式" href="/md/如何修改滚动条的样式.html">17 如何修改滚动条的样式</a></li><li class=""><a title="CSS 模拟图片透明的棋盘背景" href="/md/CSS 模拟图片透明的棋盘背景.html">16 CSS 模拟图片透明的棋盘背景</a></li><li class=""><a title="文本描边完美实现" href="/md/文本描边完美实现.html">15 文本描边完美实现</a></li><li class=""><a title="你需要自定义 @property 而不是 CSS 变量的情况" href="/md/你需要自定义 @property 而不是 CSS 变量的情况.html">14 你需要自定义 @property 而不是 CSS 变量的情况</a></li><li class=""><a title="从高度 0 过渡到自动高度" href="/md/从高度 0 过渡到自动高度.html">13 从高度 0 过渡到自动高度</a></li><li class=""><a title="一些 css 语法解释" href="/md/一些 css 语法解释.html">12 一些 css 语法解释</a></li><li class=""><a title="scss 日常用法" href="/md/scss 日常用法.html">11 scss 日常用法</a></li><li class=""><a title="sass 指南" href="/md/sass 指南.html">10 sass 指南</a></li><li class=""><a title="CSS 颜色设置透明度的新姿势" href="/md/CSS 颜色设置透明度的新姿势.html">9 CSS 颜色设置透明度的新姿势</a></li><li class=""><a title="CSS 属性 appearance" href="/md/CSS 属性 appearance.html">8 CSS 属性 appearance</a></li><li class=""><a title="CSS 动画性能优化" href="/md/CSS 动画性能优化.html">7 CSS 动画性能优化</a></li><li class=""><a title="CSS 功能特性" href="/md/CSS 功能特性.html">6 CSS 功能特性</a></li><li class=""><a title="CSS 中的 var() 函数" href="/md/CSS 中的 var() 函数.html">5 CSS 中的 var() 函数</a></li><li class=""><a title="15 个你不知道的 CSS 属性" href="/md/15 个你不知道的 CSS 属性.html">4 15 个你不知道的 CSS 属性</a></li><li class=""><a title="will-change" href="/md/will-change.html">3 will-change</a></li><li class=""><a title="normalize.css 清除元素默认样式" href="/md/normalize.css 清除元素默认样式.html">2 normalize.css 清除元素默认样式</a></li><li class=""><a title="纯 CSS 获取屏幕宽高" href="/md/纯 CSS 获取屏幕宽高.html">1 纯 CSS 获取屏幕宽高</a></li>
          </ul>
        </div>
        <div class="layout__main_map" style="order: 0">
          <div class="layout__main_map_content"></div>
          <div class="layout__main_map_swicth"></div>
        </div>
        <div
          style="order: 1"
          class="layout__main_right md "
        >
          <h1>盘点 CSS 文本两端对齐的 N 种方式</h1>
          <p class="time">HaoTian · 2024-09-10 21:46:53</p>
          <p>介绍一个你可能见过的文本两端布局（也可以叫文本均等分布），如下</p>
<img src="../imgs/66/01.webp" />

<h2>一、加空格</h2>
<p>很多人从直觉上会加空格，从视觉上达到文本两端对齐的效果，也是比较符合直觉的，例如像这样</p>
<pre><code class="language-html">&lt;ul class=&quot;demo&quot;&gt;
  &lt;li&gt;技 术 部&lt;/li&gt;
  &lt;li&gt;体验设计部&lt;/li&gt;
  &lt;li&gt;行 政 部&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>但是直接加空格没啥效果，因为默认情况下空格会合并</p>
<img src="../imgs/66/02.webp" />

<p>如果不想合并，可以用<code>white-space</code>来改变这种行为</p>
<pre><code class="language-css">li {
  white-space: pre;
}
</code></pre>
<p>这样，无论敲多少个空格，都会原封不动保留下来</p>
<img src="../imgs/66/03.webp" />

<p>这样就得到了一种“近似”的两端对齐效果</p>
<p>除了用<code>white-space</code>改变以外，还可以用<code>&amp;nbsp;</code>来输入“实体”空格</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;技&amp;nbsp;&amp;nbsp;术&amp;nbsp;&amp;nbsp;部&lt;/li&gt;
  &lt;li&gt;体验设计部&lt;/li&gt;
  &lt;li&gt;行&amp;nbsp;&amp;nbsp;政&amp;nbsp;&amp;nbsp;部&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>也能得到类似的效果</p>
<h2>二、加标签</h2>
<p>上面的实现其实只是“近似”的，并不能完美对齐，如下</p>
<img src="../imgs/66/04.webp" />

<p>很明显还是差了点。</p>
<p>不过可以换一种思路，因为空格并不能很好的描述一个中文字符的宽度，无论多少个空格，总是有点差距的，所以这里可以手动加一个空标签</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;技&lt;span&gt;&lt;/span&gt;术&lt;span&gt;&lt;/span&gt;部&lt;/li&gt;
  &lt;li&gt;体验设计部&lt;/li&gt;
  &lt;li&gt;行&lt;span&gt;&lt;/span&gt;政&lt;span&gt;&lt;/span&gt;部&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>然后，我们给这些标签设置一个字符的宽度就好了</p>
<pre><code class="language-css">li span {
  width: 1em;
}
</code></pre>
<p>这样就能完美对齐了</p>
<img src="../imgs/66/05.webp" />

<p>前面这两种方式其实都不大推荐，局限性太大，需要手动去补全剩余空间，如果字数不一样，又得手动重新计算了。</p>
<p>下面介绍几个实际更推荐的方式</p>
<h2>三、justify-content: space-between</h2>
<p>很多同学可能都会想到这种方式，毕竟现在<code>flex</code>布局实在太普遍了，不过这只适合具体的元素，不适合纯文本，所以需要改造一下，将所有文本拆分成单独的标签，类似这样</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;&lt;span&gt;技&lt;/span&gt;&lt;span&gt;术&lt;/span&gt;&lt;span&gt;部&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;span&gt;体&lt;/span&gt;&lt;span&gt;验&lt;/span&gt;&lt;span&gt;设&lt;/span&gt;&lt;span&gt;计&lt;/span&gt;&lt;span&gt;部&lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span&gt;行&lt;/span&gt;&lt;span&gt;政&lt;/span&gt;&lt;span&gt;部&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>这么多标签，手写太麻烦了，可以在  <code>JS</code>自动生成</p>
<pre><code class="language-js">txt
  .split(&quot;&quot;)
  .map((el) =&gt; `&lt;span&gt;${el}&lt;/span&gt;`)
  .join(&quot;&quot;);
</code></pre>
<img src="../imgs/66/06.webp" />

<p>然后直接利用<code>flex</code>布局的两端对齐就可以了</p>
<pre><code class="language-css">li {
  display: flex;
  justify-content: space-between;
}
</code></pre>
<p>效果如下</p>
<img src="../imgs/66/07.webp" />

<p>而且这种适应性更好，改变外层宽度，也能做到两端对齐</p>
<img src="../imgs/66/08.webp" />

<h2>四、flex:1</h2>
<p>利用<code>flex</code>布局，还可以用另一种方式来实现。</p>
<p>我们可以在每个字符中间都添加一个空标签，然后让这些空标签自动分配剩余空间，这样不就实现文本两端对齐了吗？</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;技&lt;span&gt;&lt;/span&gt;术&lt;span&gt;&lt;/span&gt;部&lt;/li&gt;
  &lt;li&gt;体&lt;span&gt;&lt;/span&gt;验&lt;span&gt;&lt;/span&gt;设&lt;span&gt;&lt;/span&gt;计&lt;span&gt;&lt;/span&gt;部&lt;/li&gt;
  &lt;li&gt;行&lt;span&gt;&lt;/span&gt;政&lt;span&gt;&lt;/span&gt;部&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>同样可以用<code>JS</code>来生成，相比上一种方式更容易</p>
<pre><code class="language-js">txt.split(&quot;&quot;).join(&quot;&lt;span&gt;&lt;/span&gt;&quot;);
</code></pre>
<img src="../imgs/66/09.webp" />

<p>然后设置<code>flex:1</code></p>
<pre><code class="language-css">li {
  display: flex;
}
li span {
  flex: 1;
}
</code></pre>
<p>效果如下</p>
<img src="../imgs/66/10.webp" />

<p>这两种方式适应性更好，基本可以在实际生产使用了，不过需要对<code>HTML</code>进行改造，稍微麻烦点，而且看着不够干净，毕竟都是空标签，没有实际价值。</p>
<p>下面再介绍两个不需要改变<code>HTML</code>的方式</p>
<h2>五、text-align: justify</h2>
<p>文本对齐方式中天然就有一个两端对齐的方式，叫做<code>justify</code>，但是这种方式不包括最后一行</p>
<img src="../imgs/66/11.webp" />

<p>由于不支持最后一行，所以对于单行文本，这种对齐方式自然也就失效了。</p>
<p>既然不支持单行文本，我们可以手动让“单行”变成“多行”，具体做法其实也很简单，用一个伪元素，强制换行就可以了，具体实现如下</p>
<pre><code class="language-css">li::after {
  content: &quot;&quot;;
  display: inline-block;
  width: 100%;
}
</code></pre>
<p>这样在设置<code>text-align: justify</code>时，原本的第一行就不再是最后一行了，自然也就生效了</p>
<p>效果如下</p>
<img src="../imgs/66/12.webp" />

<p>不过由于换行的关系，导致整体高度要比以前高出一部分，所以这种方式需要手动限制一个高度</p>
<pre><code class="language-css">li {
  text-align: justify;
  height: 24px;
  line-height: 24px;
}
</code></pre>
<p>这样就完美实现了。</p>
<p>另外，在 <code>MDN</code> 文档上还看到这样一个属性值<code>justify-all</code>，可以满足我们的需求</p>
<img src="../imgs/66/13.webp" />

<p>不过现在还没有任何浏览器支持</p>
<h2>六、text-align-last: justify</h2>
<p><code>CSS</code>中还有一个专门适用于最后一行文本的对齐方式，叫做<code>text-align-last</code>，刚好可以满足这个场景。所以我们可以在<code>HTML</code>不做任何修改的情况下，设置最后一行文本两端对齐就可以了</p>
<pre><code class="language-css">li {
  text-align-last: justify;
}
</code></pre>
<p>效果如下</p>
<img src="../imgs/66/14.webp" />

<p>这应该是最完美的方式了，不过兼容性稍微差点，又是<code>Safari</code>脱了后腿</p>
<img src="../imgs/66/15.webp" />

<h2>七、SVG 中的 lengthAdjust</h2>
<p>除了以上<code>CSS</code>的各种方式外，<code>SVG</code>中也可以实现类似这样的文本两端对齐，需要用到<code>lengthAdjust</code>属性。</p>
<p>这个属性有两个值，一个是<code>spacing</code>，表示剩余空间自动填充，另一个是<code>spacingAndGlyphs</code>，表示会让字符自动压缩或拉伸来适配整个文本长度（<code>textLength</code>）</p>
<pre><code class="language-html">&lt;svg width=&quot;300&quot; height=&quot;150&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
  &lt;g font-face=&quot;sans-serif&quot;&gt;
    &lt;text x=&quot;0&quot; y=&quot;20&quot; textLength=&quot;300&quot; lengthAdjust=&quot;spacing&quot;&gt;
      Stretched using spacing only.
    &lt;/text&gt;
    &lt;text x=&quot;0&quot; y=&quot;50&quot; textLength=&quot;300&quot; lengthAdjust=&quot;spacingAndGlyphs&quot;&gt;
      Stretched using spacing and glyphs.
    &lt;/text&gt;
    &lt;text x=&quot;0&quot; y=&quot;80&quot; textLength=&quot;100&quot; lengthAdjust=&quot;spacing&quot;&gt;
      Shrunk using spacing only.
    &lt;/text&gt;
    &lt;text x=&quot;0&quot; y=&quot;110&quot; textLength=&quot;100&quot; lengthAdjust=&quot;spacingAndGlyphs&quot;&gt;
      Shrunk using spacing and glyphs.
    &lt;/text&gt;
  &lt;/g&gt;
&lt;/svg&gt;
</code></pre>
<p>效果如下</p>
<img src="../imgs/66/16.webp" />

<p>我们也可以用这种对齐方式来实现我们想要的效果</p>
<img src="../imgs/66/17.webp" />

<h2>八、总结和说明</h2>
<p>以上共介绍了<code>7</code>种方式来实现文本两端对齐，完整 demo 可以查看以下链接</p>
<ul>
<li>CSS text justify (juejin.cn): <a href="https://code.juejin.cn/pen/7399192945481482290">https://code.juejin.cn/pen/7399192945481482290</a></li>
</ul>
<p>除此之外，你还知道哪些方式呢？欢迎留言讨论，下面总结一下</p>
<ul>
<li>加空格的方式比较符合直觉，但是只能达到近似的对齐效果</li>
<li>加标签可以实现精准对齐，但是是纯手动，而且和文字字数也有关系</li>
<li><code>flex</code>布局的两端对齐需要给每个文字套上一个标签</li>
<li>也可以在每个文字之间加上一个空标签，设置自动填充</li>
<li><code>text-align: justify</code>可以实现文本两端对齐，但是不包括最后一行</li>
<li>借助伪元素换行，可以手动将原本的最后一行变成非最后一行</li>
<li><code>text-align-last: justify</code>可以最完美的实现这个效果，不过兼容性欠佳</li>
<li><code>SVG</code>中的<code>lengthAdjust</code>也能实现类似的对齐效果</li>
</ul>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <script defer src="../js/prism.min.js"></script>
    <script>
      const liActive = document.querySelector(".layout__main_left li.active");
      liActive.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest",
      });
      const imgs = document.querySelectorAll("img");
      imgs.forEach((img) => {
        img.onclick = () => {
          img.style.opacity = 0;
          let imgHove = document.querySelector(".img-hover");
          if (imgHove) imgHove.remove();
          const src = img.src;
          const html = `
            <div class="img-hover">
              <img src="${src}" />
            </div>
          `;
          document.body.insertAdjacentHTML("beforeend", html);
          document.body.style.overflow = "hidden";
          imgHove = document.querySelector(".img-hover");
          imgHove.onclick = () => {
            imgHove.remove();
            document.body.style.overflow = "initial";
            img.style.opacity = 1;
          };
        };
      });
      const headings = document.querySelectorAll(".md h2, .md h3");
      const navContainer = document.querySelector(".layout__main_map_content");
      const layoutMainMap = document.querySelector(".layout__main_map");
      if (!headings?.length) {
        layoutMainMap.style.display = "none";
      }
      headings.forEach((heading, index) => {
        const id = `heading-${index}`;
        heading.id = id;
        const link = document.createElement("a");
        link.href = `#${id}`;
        link.textContent =
          heading.tagName === "H2"
            ? `${heading.textContent}`
            : `· ${heading.textContent}`;
        link.style.display = "block";
        link.style.margin = "5px 0";
        link.style.color = heading.tagName === "H2" ? "blue" : "darkblue";
        link.style.cursor = "pointer";
        link.className = heading.tagName === "H2" ? "H2" : "H3";
        link.addEventListener("click", (event) => {
          event.preventDefault();
          document.getElementById(id).scrollIntoView({ behavior: "smooth" });
        });
        navContainer.appendChild(link);
      });
      const swicthDom = document.querySelector(".layout__main_map_swicth");
      const mapDom = document.querySelector(".layout__main_map");
      swicthDom.onclick = () => {
        mapDom.classList.toggle("show");
      };
    </script>
  </body>
</html>
