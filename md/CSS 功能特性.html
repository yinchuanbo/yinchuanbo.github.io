<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>CSS 功能特性</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    
    <link rel="stylesheet" href="../css/prism.css" />
    
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700B3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
</head>

<body class="fade-in">
    <button class="toggle-sidebar" id="toggleSidebar" aria-label="Toggle Sidebar">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
    
    <div class="app-container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <button class="toggle-sidebar" id="toggleSidebar">
                    <span></span>
                </button>
            </div>
            <div class="sidebar-content">
                <div class="nav-section">
                    <li class=""><a title="哪个 css 格式化工具是你的首选" href="/md/哪个 css 格式化工具是你的首选.html">60 哪个 css 格式化工具是你的首选</a></li><li class=""><a title="CSS 选择器详解 12 个必知用法与最佳实践" href="/md/CSS 选择器详解 12 个必知用法与最佳实践.html">59 CSS 选择器详解 12 个必知用法与最佳实践</a></li><li class=""><a title="动态视口单位之 dvh、svh、lvh" href="/md/动态视口单位之 dvh、svh、lvh.html">58 动态视口单位之 dvh、svh、lvh</a></li><li class=""><a title="不规则造型按钮解决方案" href="/md/不规则造型按钮解决方案.html">57 不规则造型按钮解决方案</a></li><li class=""><a title="不定宽文本溢出跑马灯效果完美解决方案" href="/md/不定宽文本溢出跑马灯效果完美解决方案.html">56 不定宽文本溢出跑马灯效果完美解决方案</a></li><li class=""><a title="巧用 CSS 变量，实现动画函数复用" href="/md/巧用 CSS 变量，实现动画函数复用.html">55 巧用 CSS 变量，实现动画函数复用</a></li><li class=""><a title="角向渐变的妙用" href="/md/角向渐变的妙用.html">54 角向渐变的妙用</a></li><li class=""><a title="有趣的六芒星能力图动画" href="/md/有趣的六芒星能力图动画.html">53 有趣的六芒星能力图动画</a></li><li class=""><a title="有意思的气泡 Loading 效果" href="/md/有意思的气泡 Loading 效果.html">52 有意思的气泡 Loading 效果</a></li><li class=""><a title="CSS 原生支持的三角函数" href="/md/CSS 原生支持的三角函数.html">51 CSS 原生支持的三角函数</a></li><li class=""><a title="有意思的网格下落加载效果" href="/md/有意思的网格下落加载效果.html">50 有意思的网格下落加载效果</a></li><li class=""><a title="有意思的 Emoji 3D 表情切换效果" href="/md/有意思的 Emoji 3D 表情切换效果.html">49 有意思的 Emoji 3D 表情切换效果</a></li><li class=""><a title="神奇的 3D 磨砂玻璃透视效果" href="/md/神奇的 3D 磨砂玻璃透视效果.html">48 神奇的 3D 磨砂玻璃透视效果</a></li><li class=""><a title="抢先体验！超强大的 Anchor Positioning 锚点定位" href="/md/抢先体验！超强大的 Anchor Positioning 锚点定位.html">47 抢先体验！超强大的 Anchor Positioning 锚点定位</a></li><li class=""><a title="CSS 也能实现碰撞检测" href="/md/CSS 也能实现碰撞检测.html">46 CSS 也能实现碰撞检测</a></li><li class=""><a title="现代 CSS 解决方案 - 数学函数 Round" href="/md/现代 CSS 解决方案 - 数学函数 Round.html">45 现代 CSS 解决方案 - 数学函数 Round</a></li><li class=""><a title="现代 CSS 解决方案 - 原生嵌套" href="/md/现代 CSS 解决方案 - 原生嵌套.html">44 现代 CSS 解决方案 - 原生嵌套</a></li><li class=""><a title="神奇的背景，生化危机4日食 Loading 动画还原" href="/md/神奇的背景，生化危机4日食 Loading 动画还原.html">43 神奇的背景，生化危机4日食 Loading 动画还原</a></li><li class=""><a title="当路径动画遇到滚动驱动" href="/md/当路径动画遇到滚动驱动.html">42 当路径动画遇到滚动驱动</a></li><li class=""><a title="CSS 还原拉斯维加斯球数字动画" href="/md/CSS 还原拉斯维加斯球数字动画.html">41 CSS 还原拉斯维加斯球数字动画</a></li><li class=""><a title="单标签下多色块随机文字随机颜色动画" href="/md/单标签下多色块随机文字随机颜色动画.html">40 单标签下多色块随机文字随机颜色动画</a></li><li class=""><a title="CSS 也能实现 if 判断？实现动态高度下的不同样式展现" href="/md/CSS 也能实现 if 判断？实现动态高度下的不同样式展现.html">39 CSS 也能实现 if 判断？实现动态高度下的不同样式展现</a></li><li class=""><a title="Flex 布局下居中溢出滚动截断问题" href="/md/Flex 布局下居中溢出滚动截断问题.html">38 Flex 布局下居中溢出滚动截断问题</a></li><li class=""><a title="带圆角的虚线边框" href="/md/带圆角的虚线边框.html">37 带圆角的虚线边框</a></li><li class=""><a title="现代 CSS 解决方案：文字颜色自动适配背景色" href="/md/现代 CSS 解决方案：文字颜色自动适配背景色.html">36 现代 CSS 解决方案：文字颜色自动适配背景色</a></li><li class=""><a title="神奇的 3D 卡片反光闪烁动效" href="/md/神奇的 3D 卡片反光闪烁动效.html">35 神奇的 3D 卡片反光闪烁动效</a></li><li class=""><a title="现代 CSS 解决方案：accent-color 强调色" href="/md/现代 CSS 解决方案：accent-color 强调色.html">34 现代 CSS 解决方案：accent-color 强调色</a></li><li class=""><a title="巧用 has 和 drop-shadow 实现复杂布局效果" href="/md/巧用 has 和 drop-shadow 实现复杂布局效果.html">33 巧用 has 和 drop-shadow 实现复杂布局效果</a></li><li class=""><a title="巧用 CSS + SVG 实现复杂线条光效动画" href="/md/巧用 CSS + SVG 实现复杂线条光效动画.html">32 巧用 CSS + SVG 实现复杂线条光效动画</a></li><li class=""><a title="极具创意的鼠标交互动画" href="/md/极具创意的鼠标交互动画.html">31 极具创意的鼠标交互动画</a></li><li class=""><a title="标准滚动条控制规范 scrollbar-color 和 scrollbar-width" href="/md/标准滚动条控制规范 scrollbar-color 和 scrollbar-width.html">30 标准滚动条控制规范 scrollbar-color 和 scrollbar-width</a></li><li class=""><a title="类 ChatGpt 多行文本打字效果" href="/md/类 ChatGpt 多行文本打字效果.html">29 类 ChatGpt 多行文本打字效果</a></li><li class=""><a title="神奇的卡片 Hover 效果与 Blur 的特性探究" href="/md/神奇的卡片 Hover 效果与 Blur 的特性探究.html">28 神奇的卡片 Hover 效果与 Blur 的特性探究</a></li><li class=""><a title="渐变边框文字效果" href="/md/渐变边框文字效果.html">27 渐变边框文字效果</a></li><li class=""><a title="巧妙使用多种方式实现单侧阴影" href="/md/巧妙使用多种方式实现单侧阴影.html">26 巧妙使用多种方式实现单侧阴影</a></li><li class=""><a title="全尺寸的带圆角的渐变边框" href="/md/全尺寸的带圆角的渐变边框.html">25 全尺寸的带圆角的渐变边框</a></li><li class=""><a title="开发中保证你用得到的 css 小技巧" href="/md/开发中保证你用得到的 css 小技巧.html">24 开发中保证你用得到的 css 小技巧</a></li><li class=""><a title="您应该了解的 15 个有用的 CSS 属性" href="/md/您应该了解的 15 个有用的 CSS 属性.html">23 您应该了解的 15 个有用的 CSS 属性</a></li><li class=""><a title="CSS 行元素的截断样式 box-decoration-break 属性" href="/md/CSS 行元素的截断样式 box-decoration-break 属性.html">22 CSS 行元素的截断样式 box-decoration-break 属性</a></li><li class=""><a title="用 SASS 简化媒体查询" href="/md/用 SASS 简化媒体查询.html">21 用 SASS 简化媒体查询</a></li><li class=""><a title="为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式" href="/md/为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式.html">20 为什么你应该停止使用传统的 margin 和 padding 来设置 CSS 样式</a></li><li class=""><a title="sass 优化响应式布局代码" href="/md/sass 优化响应式布局代码.html">19 sass 优化响应式布局代码</a></li><li class=""><a title="盘点 CSS 文本两端对齐的 N 种方式" href="/md/盘点 CSS 文本两端对齐的 N 种方式.html">18 盘点 CSS 文本两端对齐的 N 种方式</a></li><li class=""><a title="如何修改滚动条的样式" href="/md/如何修改滚动条的样式.html">17 如何修改滚动条的样式</a></li><li class=""><a title="CSS 模拟图片透明的棋盘背景" href="/md/CSS 模拟图片透明的棋盘背景.html">16 CSS 模拟图片透明的棋盘背景</a></li><li class=""><a title="文本描边完美实现" href="/md/文本描边完美实现.html">15 文本描边完美实现</a></li><li class=""><a title="你需要自定义 @property 而不是 CSS 变量的情况" href="/md/你需要自定义 @property 而不是 CSS 变量的情况.html">14 你需要自定义 @property 而不是 CSS 变量的情况</a></li><li class=""><a title="从高度 0 过渡到自动高度" href="/md/从高度 0 过渡到自动高度.html">13 从高度 0 过渡到自动高度</a></li><li class=""><a title="一些 css 语法解释" href="/md/一些 css 语法解释.html">12 一些 css 语法解释</a></li><li class=""><a title="scss 日常用法" href="/md/scss 日常用法.html">11 scss 日常用法</a></li><li class=""><a title="sass 指南" href="/md/sass 指南.html">10 sass 指南</a></li><li class=""><a title="CSS 颜色设置透明度的新姿势" href="/md/CSS 颜色设置透明度的新姿势.html">09 CSS 颜色设置透明度的新姿势</a></li><li class=""><a title="CSS 属性 appearance" href="/md/CSS 属性 appearance.html">08 CSS 属性 appearance</a></li><li class=""><a title="CSS 动画性能优化" href="/md/CSS 动画性能优化.html">07 CSS 动画性能优化</a></li><li class="active"><a title="CSS 功能特性" href="/md/CSS 功能特性.html">06 CSS 功能特性</a></li><li class=""><a title="CSS 中的 var() 函数" href="/md/CSS 中的 var() 函数.html">05 CSS 中的 var() 函数</a></li><li class=""><a title="15 个你不知道的 CSS 属性" href="/md/15 个你不知道的 CSS 属性.html">04 15 个你不知道的 CSS 属性</a></li><li class=""><a title="will-change" href="/md/will-change.html">03 will-change</a></li><li class=""><a title="normalize.css 清除元素默认样式" href="/md/normalize.css 清除元素默认样式.html">02 normalize.css 清除元素默认样式</a></li><li class=""><a title="纯 CSS 获取屏幕宽高" href="/md/纯 CSS 获取屏幕宽高.html">01 纯 CSS 获取屏幕宽高</a></li>
                </div>
            </div>
        </nav>

        <!-- Main Content Area -->
        <main class="main-content">
            <header class="content-header">
                <div class="header-left">
                    <h1 class="page-title">CSS 功能特性</h1>
                    <p class="time">HaoTian · 2024-09-01 15:21:24</p>
                </div>
                <div class="header-right">
                    <div class="tag-container">
                        <span class="tag">Css</span>
                    </div>
                </div>
            </header>

            <!-- Article Content -->
            <article class="content-body md md ">
                <h3>01 clamp()</h3>
<blockquote>
<p>clamp() 函数的作用是把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。它接收三个参数：最小值、首选值、最大值。</p>
</blockquote>
<pre><code class="language-css">.box {
  width: clamp(220px, 55%, 300px);
}
h1 {
  letter-spacing: 2px;
  font-size: clamp(1.8rem, 2.5vw, 2.8rem);
}
</code></pre>
<h3>02 smooth</h3>
<blockquote>
<p>平滑滚动。</p>
</blockquote>
<pre><code class="language-html">&lt;div class=&quot;top&quot;&gt;
  &lt;a href=&quot;#bottom&quot;&gt;TOP&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&quot;bottom&quot; id=&quot;bottom&quot;&gt;BOTTOM&lt;/div&gt;
</code></pre>
<pre><code class="language-css">html {
  scroll-behavior: smooth;
}
.top,
.bottom {
  height: 100vh;
}
</code></pre>
<h3>03 scroll snap</h3>
<blockquote>
<p>允许开发者在用户完成滚动后将视窗锁定在特定的元素或位置；设置了在有滚动容器的情形下吸附至吸附点的严格程度。</p>
</blockquote>
<p><strong>语法：</strong></p>
<pre><code class="language-sh">#不吸附
scroll-snap-type: none;

#表示吸附轴的关键字
scroll-snap-type: x;
scroll-snap-type: y;
scroll-snap-type: block;
scroll-snap-type: inline;
scroll-snap-type: both;

#表示吸附程度的可选关键字
#mandatory 或 proximity
scroll-snap-type: x mandatory;
scroll-snap-type: y proximity;
scroll-snap-type: both mandatory;

#全局值
scroll-snap-type: inherit;
scroll-snap-type: initial;
scroll-snap-type: revert;
scroll-snap-type: revert-layer;
scroll-snap-type: unset;
</code></pre>
<pre><code class="language-html">&lt;div class=&quot;holster&quot;&gt;
  &lt;div class=&quot;container x mandatory-scroll-snapping&quot; dir=&quot;ltr&quot;&gt;
    &lt;div&gt;x 轴强制、从左往右&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;container x proximity-scroll-snapping&quot; dir=&quot;ltr&quot;&gt;
    &lt;div&gt;x 轴靠近、从左往右&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;container y mandatory-scroll-snapping&quot; dir=&quot;ltr&quot;&gt;
    &lt;div&gt;y 轴强制、从左往右&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;container y proximity-scroll-snapping&quot; dir=&quot;ltr&quot;&gt;
    &lt;div&gt;y 轴靠近、从左往右&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;container x mandatory-scroll-snapping&quot; dir=&quot;rtl&quot;&gt;
    &lt;div&gt;x 轴强制、从右往左&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;container x proximity-scroll-snapping&quot; dir=&quot;rtl&quot;&gt;
    &lt;div&gt;x 轴靠近、从右往左&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;container y mandatory-scroll-snapping&quot; dir=&quot;rtl&quot;&gt;
    &lt;div&gt;y 轴强制、从右往左&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;container y proximity-scroll-snapping&quot; dir=&quot;rtl&quot;&gt;
    &lt;div&gt;y 轴靠近、从右往左&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">/* 滚动吸附 */
.x.mandatory-scroll-snapping {
  scroll-snap-type: x mandatory;
}
.y.mandatory-scroll-snapping {
  scroll-snap-type: y mandatory;
}
.x.proximity-scroll-snapping {
  scroll-snap-type: x proximity;
}
.y.proximity-scroll-snapping {
  scroll-snap-type: y proximity;
}

.container &gt; div {
  text-align: center;
  scroll-snap-align: center;
  flex: none;
}
</code></pre>
<h3>04 inset</h3>
<blockquote>
<p>属性 inset 为简写属性，对应于 top、right、bottom 和 left 属性。其与 margin 简写属性具有相同的多值语法。</p>
</blockquote>
<p><strong>语法：</strong></p>
<pre><code class="language-sh">#长度值
inset: 10px; #应用于所有边
inset: 4px 8px; #上下 | 左右
inset: 5px 15px 10px; #上 | 左右 | 下
inset: 2.4em 3em 3em 3em; #上 | 右 | 下 | 左

#包含块的宽度（左或右）或高度（上或下）的百分比
inset: 10% 5% 5% 5%;

#关键词值
inset: auto;

#全局值
inset: inherit;
inset: initial;
inset: revert;
inset: revert-layer;
inset: unset;
</code></pre>
<h3>05 inline、block</h3>
<p><strong>padding-inline</strong></p>
<ul>
<li>兼容性良好</li>
</ul>
<blockquote>
<p>定义了元素的逻辑行首和行末内边距，并根据元素的书写模式、行内方向和文本朝向对应至实体内边距。</p>
</blockquote>
<pre><code class="language-css">.box {
  padding-inline: 5% 10%;
  writing-mode: horizontal-tb;
}
</code></pre>
<p><img src="../imgs/45/06.png" alt=""></p>
<pre><code class="language-css">.box {
  padding-inline: 15px 40px;
  writing-mode: vertical-rl;
}
</code></pre>
<p><img src="../imgs/45/07.png" alt=""></p>
<pre><code class="language-css">.box {
  padding-inline: 5% 20%;
  writing-mode: horizontal-tb;
  direction: rtl;
}
</code></pre>
<p><img src="../imgs/45/08.png" alt=""></p>
<ul>
<li>属性构成<ul>
<li>padding-inline-end</li>
<li>padding-inline-start</li>
</ul>
</li>
<li>语法</li>
</ul>
<pre><code class="language-sh">#&lt;length&gt; 值
padding-inline: 10px 20px; #绝对长度
padding-inline: 1em 2em; #相对于文本尺寸
padding-inline: 10px; #同时设置行首和行末值

#&lt;percentage&gt; 值
padding-inline: 5% 2%; #相对于最近包含区块的宽度

#全局值
padding-inline: inherit;
padding-inline: initial;
padding-inline: revert;
padding-inline: revert-layer;
padding-inline: unset;
</code></pre>
<p><code>padding-inline</code> 属性可用一个或两个值指定。若给一值，则此值同时用于 <code>padding-inline-start</code> 和 <code>padding-inline-end</code>。若给两值，则第一个用于 <code>padding-inline-start</code> 而第二个用于 <code>padding-inline-end</code>。</p>
<ul>
<li>为竖排文本设置行向内边距</li>
</ul>
<pre><code class="language-html">&lt;div&gt;
  &lt;p class=&quot;exampleText&quot;&gt;示例文本&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">div {
  background-color: yellow;
  width: 120px;
  height: 120px;
}
.exampleText {
  writing-mode: vertical-rl;
  padding-inline: 20px 40px;
  background-color: #c8c800;
}
</code></pre>
<p><img src="../imgs/45/09.png" alt=""></p>
<p><strong>padding-block</strong></p>
<ul>
<li>兼容性良好</li>
</ul>
<blockquote>
<p>定义了元素的逻辑块首和块末内边距，并根据元素的书写模式、行内方向和文本朝向对应至实体内边距。</p>
</blockquote>
<pre><code class="language-css">.box {
  padding-block: 10px 20px;
  writing-mode: horizontal-tb;
}
</code></pre>
<p><img src="../imgs/45/10.png" alt=""></p>
<pre><code class="language-css">.box {
  padding-block: 20px 40px;
  writing-mode: vertical-rl;
}
</code></pre>
<p><img src="../imgs/45/11.png" alt=""></p>
<pre><code class="language-css">.box {
  padding-block: 5% 10%;
  writing-mode: horizontal-tb;
}
</code></pre>
<p><img src="../imgs/45/12.png" alt=""></p>
<pre><code class="language-css">.box {
  padding-block: 2em 4em;
  writing-mode: vertical-lr;
}
</code></pre>
<p><img src="../imgs/45/13.png" alt=""></p>
<ul>
<li>属性构成<ul>
<li>padding-block-end</li>
<li>padding-block-start</li>
</ul>
</li>
<li>语法</li>
</ul>
<pre><code class="language-sh"># &lt;length&gt; 值
padding-block: 10px 20px; # 绝对长度
padding-block: 1em 2em; # 相对于文本尺寸
padding-block: 10px; # 同时设置块首和块末值

# &lt;percentage&gt; 值
padding-block: 5% 2%; # 相对于最近包含区块的宽度

# 全局值
padding-block: inherit;
padding-block: initial;
padding-block: revert;
padding-block: revert-layer;
padding-block: unset;
</code></pre>
<p><code>padding-block</code> 属性可用一个或两个值指定。若给一值，则此值同时用于 <code>padding-block-start</code> 和 <code>padding-block-end</code>。若给两值，则第一个用于 <code>padding-block-start</code> 而第二个用于 <code>padding-block-end</code>。</p>
<ul>
<li>为竖排文本设置块向内边距</li>
</ul>
<pre><code class="language-html">&lt;div&gt;
  &lt;p class=&quot;exampleText&quot;&gt;示例文本&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">div {
  background-color: yellow;
  width: 120px;
  height: 120px;
}

.exampleText {
  writing-mode: vertical-rl;
  padding-block: 20px 40px;
  background-color: #c8c800;
}
</code></pre>
<p><img src="../imgs/45/14.png" alt=""></p>
<p><strong>margin-inline</strong></p>
<ul>
<li>兼容性良好</li>
</ul>
<blockquote>
<p>定义了元素的逻辑行首和行末外边距，并根据元素的书写模式、行内方向和文本朝向对应至实体外边距。</p>
</blockquote>
<pre><code class="language-css">.box {
  margin-inline: 5% 10%;
  writing-mode: horizontal-tb;
}
</code></pre>
<p><img src="../imgs/45/15.png" alt=""></p>
<pre><code class="language-css">.box {
  margin-inline: 10px 40px;
  writing-mode: vertical-rl;
}
</code></pre>
<p><img src="../imgs/45/16.png" alt=""></p>
<pre><code class="language-css">.box {
  margin-inline: 5% 10%;
  writing-mode: horizontal-tb;
  direction: rtl;
}
</code></pre>
<p><img src="../imgs/45/17.png" alt=""></p>
<ul>
<li>属性构成<ul>
<li>margin-inline-start</li>
<li>margin-inline-end</li>
</ul>
</li>
<li>语法</li>
</ul>
<pre><code class="language-sh">#&lt;length&gt; 值
margin-inline: 10px 20px; #绝对长度
margin-inline: 1em 2em; #相对于文本尺寸
margin-inline: 5% 2%; #相对于最近区块容器的宽度
margin-inline: 10px; #同时设置行首和行末值

#关键词值
margin-inline: auto;

#全局值
margin-inline: inherit;
margin-inline: initial;
margin-inline: revert;
margin-inline: revert-layer;
margin-inline: unset;
</code></pre>
<p>根据 <code>writing-mode</code>、<code>direction</code> 和 <code>text-orientation</code> 所定义的值，此属性对应于 <code>margin-top</code> 和 <code>margin-bottom</code>，或者 <code>margin-right</code> 和 <code>margin-left</code> 属性。</p>
<p><code>margin-inline</code> 属性可用一个或两个值指定。</p>
<ul>
<li>用一个值指定时，行首和行末应用同样的外边距。</li>
<li>用两个值指定时，第一个外边距应用于行首，第二个应用于行末。</li>
<li>设置行首和行末外边距</li>
</ul>
<pre><code class="language-css">div {
  background-color: yellow;
  width: 120px;
  height: auto;
  border: 1px solid green;
}

p {
  margin: 0;
  margin-inline: 20px 40px;
  background-color: tan;
}

.verticalExample {
  writing-mode: vertical-rl;
}
</code></pre>
<pre><code class="language-html">&lt;div&gt;
  &lt;p&gt;示例文本&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;verticalExample&quot;&gt;
  &lt;p&gt;示例文本&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p><img src="../imgs/45/18.png" alt=""></p>
<p><strong>margin-block</strong></p>
<ul>
<li>兼容性良好</li>
</ul>
<blockquote>
<p>定义了元素的逻辑块首和块末外边距，并根据元素的书写模式、行内方向和文本朝向对应至实体外边距。</p>
</blockquote>
<pre><code class="language-css">.box {
  margin-block: 10px 20px;
  writing-mode: horizontal-tb;
}
</code></pre>
<p><img src="../imgs/45/19.png" alt=""></p>
<pre><code class="language-css">.box {
  margin-block: 20px 40px;
  writing-mode: vertical-rl;
}
</code></pre>
<p><img src="../imgs/45/20.png" alt=""></p>
<pre><code class="language-css">.box {
  margin-block: 5% 20%;
  writing-mode: horizontal-tb;
}
</code></pre>
<p><img src="../imgs/45/21.png" alt=""></p>
<pre><code class="language-css">.box {
  margin-block: 1rem auto;
  writing-mode: vertical-lr;
}
</code></pre>
<p><img src="../imgs/45/22.png" alt=""></p>
<ul>
<li>属性构成<ul>
<li>margin-block-start</li>
<li>margin-block-end</li>
</ul>
</li>
</ul>
<pre><code class="language-sh">#&lt;length&gt; 值
margin-block: 10px 20px; #绝对长度
margin-block: 1em 2em; #相对于文本尺寸
margin-block: 5% 2%; #相对于最近区块容器的宽度
margin-block: 10px; #同时设置块首和块末值

#关键词值
margin-block: auto;

#全局值
margin-block: inherit;
margin-block: initial;
margin-block: revert;
margin-block: revert-layer;
margin-block: unset;
</code></pre>
<p>根据 writing-mode、direction 和 text-orientation 所定义的值，此属性对应于 margin-top 和 margin-bottom，或者 margin-right 和 margin-left 属性。</p>
<p><code>margin-block</code> 属性可用一个或两个值指定。</p>
<ol>
<li>用<strong>一个</strong>值指定时，<strong>块首和块末</strong>应用同样的外边距。</li>
<li>用<strong>两个</strong>值指定时，第一个外边距应用于<strong>块首</strong>，第二个应用于<strong>块末</strong>。</li>
</ol>
<ul>
<li>设置块首和块末外边距</li>
</ul>
<pre><code class="language-html">&lt;div&gt;
  &lt;p&gt;示例文本&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;verticalExample&quot;&gt;
  &lt;p&gt;示例文本&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">div {
  background-color: yellow;
  width: 120px;
  height: auto;
  border: 1px solid green;
}

p {
  margin: 0;
  margin-block: 20px 40px;
  background-color: tan;
}

.verticalExample {
  writing-mode: vertical-rl;
}
</code></pre>
<p><img src="../imgs/45/23.png" alt=""></p>
<p><strong>border-inline</strong></p>
<ul>
<li>兼容性良好</li>
</ul>
<blockquote>
<p>用于在样式表中的某处同时设置逻辑行向边框的各属性值。</p>
</blockquote>
<pre><code class="language-css">.box {
  border-inline: solid;
  writing-mode: horizontal-tb;
}
</code></pre>
<p><img src="../imgs/45/24.png" alt=""></p>
<pre><code class="language-css">.box {
  border-inline: dashed red;
  writing-mode: vertical-rl;
}
</code></pre>
<p><img src="../imgs/45/25.png" alt=""></p>
<pre><code class="language-css">.box {
  border-inline: 1rem solid;
  writing-mode: horizontal-tb;
  direction: rtl;
}
</code></pre>
<p><img src="../imgs/45/26.png" alt=""></p>
<p><code>border-inline</code> 所对应的实体边框取决于元素的书写模式、行内方向和文本朝向。根据 <code>writing-mode</code>、<code>direction</code> 和 <code>text-orientation</code> 所定义的值，此属性对应于 <code>border-top</code> 和 <code>border-bottom</code>，或者 <code>border-right</code> 和 <code>border-left</code> 属性。</p>
<p>另一方向的边框可用 <code>border-block</code> 设置，此属性会设置 <code>border-block-start</code> 和 <code>border-block-end</code>。</p>
<ul>
<li>语法</li>
</ul>
<pre><code class="language-sh">border-inline: 1px;
border-inline: 2px dotted;
border-inline: medium dashed blue;

# 全局值
border-inline: inherit;
border-inline: initial;
border-inline: revert;
border-inline: revert-layer;
border-inline: unset;
</code></pre>
<ul>
<li>竖排文本的边框</li>
</ul>
<pre><code class="language-html">&lt;div&gt;
  &lt;p class=&quot;exampleText&quot;&gt;示例文本&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">div {
  background-color: yellow;
  width: 120px;
  height: 120px;
}
.exampleText {
  writing-mode: vertical-rl;
  border-inline: 5px dashed blue;
}
</code></pre>
<p><img src="../imgs/45/27.png" alt=""></p>
<h3>06 min()、max()</h3>
<ol>
<li>min()</li>
</ol>
<pre><code class="language-sh">width: min(1vw, 4em, 80px);
</code></pre>
<p>在上面的例子中，宽度最多是 80px。如果视口的宽度小于 800px，或者一个 em 的宽度小于 20px，则会更窄。换句话说，最大宽度是 80px，</p>
<p><strong>示例</strong></p>
<p><code>min()</code> 让我们在设置图像的最大宽度时更简单。在下面这个例子中，在小型设备上宽度拉伸为 window 的一半，但在大型设备上，不超过 300px，不使用媒体查询：</p>
<pre><code class="language-css">.logo {
  width: min(50vw, 300px);
}
</code></pre>
<pre><code class="language-html">&lt;img
  src=&quot;https://developer.mozilla.org/static../imgs/45b-docs-sprite.svg&quot;
  alt=&quot;MDN Web Docs&quot;
  class=&quot;logo&quot;
/&gt;
</code></pre>
<p>在这个例子中，除非视口比 600px 更窄，否则 logo 的宽会被设置为 300px，到时候，它会随着视口的缩小而缩小，而且总是视口宽度的 50%。</p>
<p><strong>给 label 和 input 设置最大值</strong></p>
<p>CSS 方法的另一个用途时设置响应式组件（form）的最大尺寸：让 label 和 input 的宽度随着组件的缩小而缩小。</p>
<pre><code class="language-html">&lt;form&gt;
  &lt;label&gt;Type something:&lt;/label&gt;
  &lt;input type=&quot;text&quot; /&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-css">input,
label {
  padding: 2px;
  box-sizing: border-box;
  display: inline-block;
  width: min(40%, 400px);
  background-color: pink;
}

form {
  margin: 4px;
  border: 1px solid black;
  padding: 4px;
}
</code></pre>
<p>这里，form 的 margin，border，padding 总是它父元素的宽度的 100%。我们声明 input 和 label 的宽度比 form 的 40% 还小或者 400px 宽，只要取决于哪一个最小。换句话说，input 和 label 的最大宽度就是 400px，最窄就是 form 的 40%。因此看起来会显得很小。</p>
<p><img src="../imgs/45/05.png" alt=""></p>
<p><strong>无障碍问题</strong></p>
<p>当 min() 用于控制文本大小时，要保证文本足够大以便于阅读。建议把 min() 方法嵌入到 max() 中， relative length unit 这样就可以便于阅读，比如：</p>
<pre><code class="language-css">small {
  font-size: max(min(0.5vw, 0.5em), 1rem);
}
</code></pre>
<p>这用于保证最小值是 1rem，这样在页面缩放时文本也会缩放。</p>
<ol start="2">
<li>max()</li>
</ol>
<pre><code class="language-sh">width: max(10vw, 4em, 80px);
</code></pre>
<p>在上面这个例子中，宽度最小会是 80px，除非视图宽度大于 800px 或者是一个 em 比 20px 宽。简单来说，最小宽度是 80px。你也可以认为 max() 的值提供了一个属性最小可能的值。</p>
<p><strong>为字体设定一个最小字号</strong></p>
<pre><code class="language-css">h1 {
  font-size: 2rem;
}
h1.responsive {
  font-size: max(4vw, 2em, 2rem);
}
</code></pre>
<p><strong>无障碍</strong></p>
<pre><code class="language-css">small {
  font-size: max(min(0.5vw, 0.5em), 1rem);
}
</code></pre>
<h3>07 line-clamp</h3>
<ul>
<li>兼容性良好</li>
</ul>
<blockquote>
<p>属性可以把块容器中的内容限制为指定的行数。</p>
</blockquote>
<p>它只有在 display 属性设置成 <code>-webkit-box</code> 或者 <code>-webkit-inline-box</code> 并且 <code>box-orient</code> 属性设置成 <code>vertical</code> 时才有效果。</p>
<p>在大部分情况下，也需要设置 overflow 属性为 hidden，否则，里面的内容不会被裁减，并且在内容显示为指定行数后还会显示省略号。</p>
<p>当应用于锚（anchor）元素时，截断可以发生在文本中间，而不必在末尾。</p>
<p><strong>语法</strong></p>
<pre><code class="language-sh">#关键词值
-webkit-line-clamp: none;

#整数值
-webkit-line-clamp: 3;
-webkit-line-clamp: 10;

#全局值
-webkit-line-clamp: inherit;
-webkit-line-clamp: initial;
-webkit-line-clamp: revert;
-webkit-line-clamp: revert-layer;
-webkit-line-clamp: unset;
</code></pre>
<p><strong>截断段落</strong></p>
<pre><code class="language-html">&lt;p&gt;
  在此示例中，&lt;code&gt;-webkit-line-clamp&lt;/code&gt; 属性设置为
  &lt;code&gt;2&lt;/code&gt;，即文本在超过两行后将被截断。文本截断处将显示省略号。
&lt;/p&gt;
</code></pre>
<pre><code class="language-css">p {
  width: 300px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
}
</code></pre>
<p><img src="../imgs/45/04.png" alt=""></p>
<h3>08 :has()</h3>
<ul>
<li>火狐浏览器不支持</li>
</ul>
<pre><code class="language-css">/* 当 h1 元素后面紧跟着一个兄弟元素 p 时，会应用以下样式 */
h1:has(+ p) {
  margin-bottom: 0;
}
</code></pre>
<p><strong>与兄弟组合器一起使用</strong></p>
<ul>
<li>以下示例中的 :has() 样式声明会调整 H1 标题后面的间距，如果它们后面紧跟着 H2 标题。</li>
</ul>
<pre><code class="language-html">&lt;section&gt;
  &lt;article&gt;
    &lt;h1&gt;Morning Times&lt;/h1&gt;
    &lt;p&gt;
      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
      tempor incididunt ut labore et dolore magna aliqua.
    &lt;/p&gt;
  &lt;/article&gt;
  &lt;article&gt;
    &lt;h1&gt;Morning Times&lt;/h1&gt;
    &lt;h2&gt;Delivering you news every morning&lt;/h2&gt;
    &lt;p&gt;
      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
      tempor incididunt ut labore et dolore magna aliqua.
    &lt;/p&gt;
  &lt;/article&gt;
&lt;/section&gt;
</code></pre>
<pre><code class="language-css">h1,
h2 {
  margin: 0 0 1rem 0;
}
h1:has(+ h2) {
  margin: 0 0 0.25rem 0;
}
</code></pre>
<p><img src="../imgs/45/02.png" alt=""></p>
<p><strong>与 :is() 伪类一起使用</strong></p>
<ul>
<li>这个示例建立在前一个示例之上，展示了如何用 :has() 选择多个元素。</li>
</ul>
<pre><code class="language-html">&lt;section&gt;
  &lt;article&gt;
    &lt;h1&gt;Morning Times&lt;/h1&gt;
    &lt;h2&gt;Delivering you news every morning&lt;/h2&gt;
    &lt;p&gt;
      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
      tempor incididunt ut labore et dolore magna aliqua.
    &lt;/p&gt;
  &lt;/article&gt;
  &lt;article&gt;
    &lt;h1&gt;Morning Times&lt;/h1&gt;
    &lt;h2&gt;Delivering you news every morning&lt;/h2&gt;
    &lt;h3&gt;8:00 am&lt;/h3&gt;
    &lt;p&gt;
      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
      tempor incididunt ut labore et dolore magna aliqua.
    &lt;/p&gt;
  &lt;/article&gt;
&lt;/section&gt;
</code></pre>
<pre><code class="language-css">h1,
h2,
h3 {
  margin: 0 0 1rem 0;
}
:is(h1, h2, h3):has(+ :is(h2, h3, h4)) {
  margin: 0 0 0.25rem 0;
}
</code></pre>
<p><img src="../imgs/45/03.png" alt=""></p>
<p>这个选择器也可以写作：</p>
<pre><code class="language-css">:is(h1, h2, h3):has(+ h2, + h3, + h4) {
  margin: 0 0 0.25rem 0;
}
</code></pre>
<h3>09 :is</h3>
<ul>
<li>兼容性良好</li>
</ul>
<blockquote>
<p>以选择器列表作为参数，并选择该列表中任意一个选择器可以选择的元素；这对于以更紧凑的形式编写大型选择器非常有用。</p>
</blockquote>
<p><strong>尝试一下：</strong></p>
<pre><code class="language-html">&lt;ol&gt;
  &lt;li&gt;Saturn&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;Mimas&lt;/li&gt;
      &lt;li&gt;Enceladus&lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;Voyager&lt;/li&gt;
          &lt;li&gt;Cassini&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;Tethys&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Uranus&lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;Titania&lt;/li&gt;
      &lt;li&gt;Oberon&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<pre><code class="language-css">ol {
  list-style-type: upper-alpha;
  color: darkblue;
}

/* stylelint-disable-next-line selector-pseudo-class-no-unknown */
:is(ol, ul, menu:unsupported) :is(ol, ul) {
  color: green;
}

:is(ol, ul) :is(ol, ul) ol {
  list-style-type: lower-greek;
  color: chocolate;
}
</code></pre>
<p><img src="../imgs/45/01.png" alt=""></p>
<p>在 CSS 中，当使用选择器列表时，如果任何一个选择器无效，则整个列表将被视为无效。使用 :is() 或 :where() 时，如果一个选择器无法解析，整个选择器列表不会被视为无效，而是会忽略不正确或不支持的选择器，并使用其他的选择器。</p>
<pre><code class="language-css">/* 即使在不支持 :unsupported 的浏览器中，仍将正确解析 :valid */
:is(:valid, :unsupported) {
  /* … */
}
</code></pre>
<pre><code class="language-css">/* 在不支持 :unsupported 浏览器中即使它们支持 :valid，仍将忽略。 */
:valid,
:unsupported {
  /* … */
}
</code></pre>
<p><strong>简化列表选择器</strong></p>
<p><code>:is()</code> 伪类可以大大简化你的 CSS 选择器。例如，考虑以下 CSS：</p>
<pre><code class="language-css">/* 三层或更深的无序列表使用方形符号。 */
ol ol ul,
ol ul ul,
ol menu ul,
ol dir ul,
ol ol menu,
ol ul menu,
ol menu menu,
ol dir menu,
ol ol dir,
ol ul dir,
ol menu dir,
ol dir dir,
ul ol ul,
ul ul ul,
ul menu ul,
ul dir ul,
ul ol menu,
ul ul menu,
ul menu menu,
ul dir menu,
ul ol dir,
ul ul dir,
ul menu dir,
ul dir dir,
menu ol ul,
menu ul ul,
menu menu ul,
menu dir ul,
menu ol menu,
menu ul menu,
menu menu menu,
menu dir menu,
menu ol dir,
menu ul dir,
menu menu dir,
menu dir dir,
dir ol ul,
dir ul ul,
dir menu ul,
dir dir ul,
dir ol menu,
dir ul menu,
dir menu menu,
dir dir menu,
dir ol dir,
dir ul dir,
dir menu dir,
dir dir dir {
  list-style-type: square;
}
</code></pre>
<p>你可以将其替换为：</p>
<pre><code class="language-css">/* 三层或更深的无序列表使用方形符号。 */
:is(ol, ul, menu, dir) :is(ol, ul, menu, dir) :is(ul, menu, dir) {
  list-style-type: square;
}
</code></pre>
<p><strong>简化段落选择器</strong></p>
<p><code>:is()</code> 伪类在处理段落和标题时特别有用。由于 <code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code> 和 <code>&lt;nav&gt;</code> 通常嵌套在一起，如果没有 <code>:is()</code>，将它们设置为相互匹配很棘手。</p>
<p>例如，没有 :is()，在不同的深度对所有 h1 元素进行样式化可能是非常复杂的：</p>
<pre><code class="language-css">/* 0 级 */
h1 {
  font-size: 30px;
}

/* 1 级 */
section h1,
article h1,
aside h1,
nav h1 {
  font-size: 25px;
}

/* 2 级 */
section section h1,
section article h1,
section aside h1,
section nav h1,
article section h1,
article article h1,
article aside h1,
article nav h1,
aside section h1,
aside article h1,
aside aside h1,
aside nav h1,
nav section h1,
nav article h1,
nav aside h1,
nav nav h1 {
  font-size: 20px;
}

/* 3 级 */
/* 想都别想！ */
</code></pre>
<p>然而，使用 <code>:is()</code> 将容易的多：</p>
<pre><code class="language-css">/* 0 级 */
h1 {
  font-size: 30px;
}
/* 1 级 */
:is(section, article, aside, nav) h1 {
  font-size: 25px;
}
/* 2 级 */
:is(section, article, aside, nav) :is(section, article, aside, nav) h1 {
  font-size: 20px;
}
/* 3 级 */
:is(section, article, aside, nav)
  :is(section, article, aside, nav)
  :is(section, article, aside, nav)
  h1 {
  font-size: 15px;
}
</code></pre>
<p><strong>:is() 不能选择伪元素</strong></p>
<pre><code class="language-css">/* 错误写法 */
some-element:is(::before, ::after) {
  display: block;
}
</code></pre>

            </article>
        </main>

        <!-- Table of Contents Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-header">
                <h3>Table of Contents</h3>
            </div>
            <div class="toc-content" id="tocContent">
                <!-- TOC will be generated dynamically -->
            </div>
        </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 19V5M5 12l7-7 7 7"/>
        </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(135deg, var(--accent), rgba(59, 130, 246, 0.8));
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
        // Sidebar Toggle
        const toggleBtn = document.getElementById('toggleSidebar');
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');
        
        function toggleSidebar() {
            sidebar.classList.toggle('hidden');
            // Store sidebar state in localStorage
            localStorage.setItem('sidebarHidden', sidebar.classList.contains('hidden'));
        }
        
        toggleBtn.addEventListener('click', toggleSidebar);

        // Keyboard shortcut (Ctrl + B)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'b') {
                e.preventDefault(); // Prevent browser's default behavior
                toggleSidebar();
            }
        });

        // Restore sidebar state from localStorage
        document.addEventListener('DOMContentLoaded', () => {
            const sidebarHidden = localStorage.getItem('sidebarHidden') === 'true';
            if (sidebarHidden) {
                sidebar.classList.add('hidden');
            }
        });

        // Generate Table of Contents
        function generateTOC() {
            const article = document.querySelector('.content-body');
            const headings = article.querySelectorAll('h1, h2, h3, h4');
            const tocContent = document.getElementById('tocContent');
            const toc = document.createElement('ul');

            headings.forEach((heading, index) => {
                const id = `heading-${index}`;
                heading.id = id;
                
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${id}`;
                a.textContent = heading.textContent;
                a.className = `toc-level-${heading.tagName.toLowerCase()}`;
                
                li.appendChild(a);
                toc.appendChild(li);
            });

            tocContent.appendChild(toc);
        }

        // Initialize TOC
        document.addEventListener('DOMContentLoaded', generateTOC);

        // Image zoom with FLIP animation
        const overlay = document.querySelector(".zoom-overlay");
        let activeImage = null;

        document.querySelectorAll("img").forEach((img) => {
            if (img.closest("a")) return; // Skip images that are inside links
            img.style.cursor = "zoom-in";
            img.addEventListener("click", handleImageClick);
        });

        function handleImageClick(event) {
            const img = event.target;

            if (activeImage) {
                // If an image is already zoomed, unzoom it
                unzoomImage();
                return;
            }

            // Get the initial position and size
            const rect = img.getBoundingClientRect();
            const first = {
                x: rect.left,
                y: rect.top,
                width: rect.width,
                height: rect.height,
            };

            // Create a clone of the image
            const clone = img.cloneNode();
            clone.classList.add("zoomed-image");
            document.body.appendChild(clone);

            // Position the clone exactly over the original
            clone.style.position = "fixed";
            clone.style.left = `${first.x}px`;
            clone.style.top = `${first.y}px`;
            clone.style.width = `${first.width}px`;
            clone.style.height = `${first.height}px`;
            clone.style.margin = "0";
            clone.style.transformOrigin = "top left";

            // Show the overlay
            overlay.style.display = "block";

            // Calculate the final position and scale
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
            const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
            const scaleX = targetWidth / first.width;
            const scaleY = targetHeight / first.height;
            const scale = Math.min(scaleX, scaleY);

            const last = {
                width: first.width * scale,
                height: first.height * scale,
            };
            last.x = (viewportWidth - last.width) / 2;
            last.y = (viewportHeight - last.height) / 2;

            // Calculate and apply the transform
            const dx = last.x - first.x;
            const dy = last.y - first.y;

            requestAnimationFrame(() => {
                clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
                clone.style.transition = "transform 0.3s ease-out";
            });

            activeImage = { original: img, clone: clone };

            // Add click handlers for closing
            clone.addEventListener("click", unzoomImage);
            overlay.addEventListener("click", unzoomImage);
        }

        function unzoomImage() {
            if (!activeImage) return;

            const { original, clone } = activeImage;
            const rect = original.getBoundingClientRect();

            // Animate back to the original position
            clone.style.transform = `translate(0, 0) scale(1)`;

            // Clean up after the animation
            clone.addEventListener(
                "transitionend",
                () => {
                    clone.remove();
                    overlay.style.display = "none";
                },
                { once: true }
            );

            activeImage = null;
        }

        // 监听 ctrl + b
        window.addEventListener("keydown", (e) => {
            const leftDom = document.querySelector(".sidebar");
            if (e.ctrlKey && e.key === "b") {
                leftDom.classList.toggle("hidden");
            }
        });

        // Modal
        // const modal = document.getElementById("myModal");
        // const modalContent = modal.querySelector(".modal-content");
        // const openModal = document.getElementById("openModal");
        // const close = modal.querySelector(".close");

        // openModal.addEventListener("click", () => {
        //     modal.style.display = "block";
        // });

        // close.addEventListener("click", () => {
        //     modal.style.display = "none";
        // });

        // window.addEventListener("click", (e) => {
        //     if (e.target === modal) {
        //         modal.style.display = "none";
        //     }
        // });

        // Back to top button
        const backToTop = document.getElementById('backToTop');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 200) {
                backToTop.style.display = 'block';
            } else {
                backToTop.style.display = 'none';
            }
        });

        backToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    </script>
</body>
</html>
