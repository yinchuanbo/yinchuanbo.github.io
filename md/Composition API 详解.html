<!DOCTYPE html>
<html lang="en" class="light">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>Composition API 详解</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    
    <link rel="stylesheet" href="../css/prism.css" />
    
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>

  <body>
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 0">
          <div class="layout__main_left-switch"></div>
          <ul>
            <li class="active"><a title="Composition API 详解" href="/md/Composition API 详解.html">12 Composition API 详解</a></li><li class=""><a title="实现过渡动画" href="/md/实现过渡动画.html">11 实现过渡动画</a></li><li class=""><a title="组件化进阶详解" href="/md/组件化进阶详解.html">10 组件化进阶详解</a></li><li class=""><a title="组件化基础详解" href="/md/组件化基础详解.html">09 组件化基础详解</a></li><li class=""><a title="组件化开发" href="/md/组件化开发.html">08 组件化开发</a></li><li class=""><a title="v-model和表单输入" href="/md/v-model和表单输入.html">07 v-model和表单输入</a></li><li class=""><a title="vue3 的 Options API" href="/md/vue3 的 Options API.html">06 vue3 的 Options API</a></li><li class=""><a title="模板语法和内置命令" href="/md/模板语法和内置命令.html">05 模板语法和内置命令</a></li><li class=""><a title="前端 vue 项目使用 ffmpeg 处理视频" href="/md/前端 vue 项目使用 ffmpeg 处理视频.html">04 前端 vue 项目使用 ffmpeg 处理视频</a></li><li class=""><a title="Vue Router 4 的 scrollBehavior 方法" href="/md/Vue Router 4 的 scrollBehavior 方法.html">03 Vue Router 4 的 scrollBehavior 方法</a></li><li class=""><a title="浅浅聊一下 vue 中的 nextTick 的实现原理" href="/md/浅浅聊一下 vue 中的 nextTick 的实现原理.html">02 浅浅聊一下 vue 中的 nextTick 的实现原理</a></li><li class=""><a title="Vue3.x 生态最能打的组合" href="/md/Vue3.x 生态最能打的组合.html">01 Vue3.x 生态最能打的组合</a></li>
          </ul>
        </div>
        <div
          style="order: 1"
          class="layout__main_right md "
        >
          <div class="page-header">
            
            <a href="/md/" class="back-button"
              ><svg
                t="1737007603776"
                class="icon"
                viewBox="0 0 1024 1024"
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
                p-id="4546"
                width="200"
                height="200"
              >
                <path
                  d="M853.333333 245.333333H245.333333l93.866667-93.866666c12.8-12.8 12.8-34.133333 0-46.933334-12.8-12.8-34.133333-12.8-46.933333 0l-145.066667 145.066667c-12.8 12.8-12.8 34.133333 0 46.933333l145.066667 145.066667c6.4 6.4 14.933333 10.666667 23.466666 10.666667s17.066667-4.266667 23.466667-10.666667c12.8-12.8 12.8-34.133333 0-46.933333L256 311.466667h597.333333c6.4 0 10.666667 4.266667 10.666667 10.666666v426.666667c0 6.4-4.266667 10.666667-10.666667 10.666667H170.666667c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32h682.666666c40.533333 0 74.666667-34.133333 74.666667-74.666667V320c0-40.533333-34.133333-74.666667-74.666667-74.666667z"
                  fill="#ffffff"
                  p-id="4547"
                ></path></svg
            ></a>
            
            <h1>Composition API 详解</h1>
            <p class="time">HaoTian · 2025-01-17 21:41:48</p>
          </div>
          <p>随着项目规模的扩大，组件数量也会逐渐增多，这时需要考虑复用组件逻辑。</p>
<p>在 Vue3 中，有两种主要的组件逻辑复用方式：Mixin 和 Composition API。</p>
<h2>Options API 代码的复用</h2>
<h3>Mixin 混入</h3>
<p>组件与组件之间有时会存在相同的代码逻辑，这时我们希望对相同的代码逻辑进行抽取。与 Vue2 一样，Vue3 也支持使用 Mixin 完成代码的复用。</p>
<p>Mixin 具有如下特点：</p>
<p>(1) Mixin 提供了一种非常灵活的方式来分发 Vue3 组件中可复用的功能</p>
<p>(2) 一个 Mixin 对象可以包含任何组件的选项（Options API）</p>
<p>(3) 当组件使用 Mixin 对象时，所有 Mixin 对象的选项都将被混入该组件本身的选项中</p>
<p><strong>1. Mixin 的基本使用</strong></p>
<pre><code class="language-js">// demoMixin.js
// 定义一个 Mixin 混合对象，将组件公用的代码逻辑抽取到 demoMixin 中
export const demoMixin = {
  data() {
    return {
      message: &quot;Hello DemoMixin&quot;,
    };
  },
  methods: {
    foo() {
      console.log(&quot;demo mixin foo&quot;);
    },
  },
  created() {
    console.log(&quot;执行了 demo mixin created&quot;);
  },
};
</code></pre>
<ul>
<li>App.vue 组件，代码如下：</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;{{ message }}&lt;/h2&gt;
    &lt;button @click=&quot;foo&quot;&gt;单击调用 demoMixin 定义的 foo 方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { demoMixin } from &quot;./mixins/demoMixin.js&quot;;
  export default {
    // 将 demoMixin 定义的 data、methods、created 选项混入该组件中，也支持混入其他组件
    mixins: [demoMixin],
  };
&lt;/script&gt;
</code></pre>
<p><strong>2. Mixin 的合并规则</strong></p>
<p>如果 Mixin 对象中的选项和组件对象中的选项发生了冲突，那么 Vue3 会分成三种情况来处理。</p>
<p>(1) 处理 data 函数返回值对象。</p>
<p>默认情况下，Mixin 对象中 data 选项的返回值和组件对象中 data 选项的返回值会进行合并。</p>
<p>如果它们的 data 选项返回值对象的属性发生了冲突，那么会保留组件对象自身的数据，</p>
<p>(2) 处理生命周期钩子函数。</p>
<p>Mixin 对象和组件对象中的生命周期钩子函数会被合并到数组中，都会调用。</p>
<p>(3) 处理值为对象的选项。</p>
<p>如 methods、components、directives 选项，将被合并为同一个对象。</p>
<p>例如，Mixin 对象和组件对象中都有 methods 选项，并且都定义了方法，那么它们都会生效。但是如果对象的 key 相同，那么会取组件对象的键值对。</p>
<p>下面演示一下 Mixin 的合并规则：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;{{ message }}&lt;/h2&gt;
    &lt;button @click=&quot;foo&quot;&gt;单击调用 demoMixin 定义的 foo 方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { demoMixin } from &quot;./mixins/demoMixin.js&quot;;
  export default {
    mixins: [demoMixin],
    data() {
      return {
        // 1. message 变量和 demoMixin 对象中定义的 message 冲突，那么会使用该组件的 message
        message: &quot;Hello App&quot;,
        title: &quot;Hello World&quot;,
      };
    },
    methods: {
      // 2. foo 方法和 demoMixin 对象中定义的 foo 方法冲突，那么会使用该组件的 foo 方法
      foo() {
        console.log(&quot;app foo&quot;);
      },
      bar() {
        console.log(&quot;bar function&quot;);
      },
    },
    computed: {},
    watch: {},
    // 3. 生命周期的钩子函数和 demoMixin 对象中的重复，那么它们会被合并到数组中，都会被调用
    created() {
      console.log(&quot;App created 执行&quot;);
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>3. 全局混入 Mixin</strong></p>
<p>如果所有组件都需要某些选项，那么可以使用全局 Mixin，全局 Mixin 可以使用 <code>app.mixin</code> 方法进行注册。</p>
<p>一旦注册，全局混入的选项将被混入每个组件中。</p>
<ul>
<li>修改 main.js</li>
</ul>
<pre><code class="language-js">import { createApp } from &quot;vue&quot;;
import App from &quot;./01_Mixin/App.vue&quot;;

let app = createApp(App);

// 注册全局混入
app.mixin({
  created() {
    console.log(&quot;global mixin created&quot;);
  },
});

app.mount(&quot;#app&quot;);
</code></pre>
<p>尽管 Mixin 可以对组件代码逻辑进行抽取和复用，但他存在如下缺陷：</p>
<p>(1) Mixin 容易发生冲突。</p>
<p>(2) Mixin 的可复用性是有限的。</p>
<h3>extends 继承</h3>
<p>除了 Mixin，Vue 3 还提供了另一种代码逻辑复用的方式，即使用 extends 属性，</p>
<p>使用 extends 属性可以扩展另一个组件，类似于 Mixin，但使用较少，了解即可。</p>
<pre><code class="language-html">&lt;!-- BasePage.vue --&gt;
&lt;!-- extends 属性只能复用 script 标签中的逻辑，不能复用 template 和 style --&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        title: &quot;Hello BasePage&quot;,
      };
    },
    methods: {
      bar() {
        console.log(&quot;base page bar&quot;);
      },
    },
  };
&lt;/script&gt;
</code></pre>
<p>上面代码用于复用 data 和 methods 选项中公共的代码逻辑。</p>
<pre><code class="language-html">&lt;!-- Home.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;home&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;h4&gt;{{ title }}&lt;/h4&gt;
    &lt;button @click=&quot;bar&quot;&gt;单击调用 BasePage 组件定义的 bar 方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import BasePage from &quot;./BasePage.vue&quot;;
  export default {
    exends: BasePage,
  };
&lt;/script&gt;
</code></pre>
<h2>认识 Composition API</h2>
<p>在 Vue2 中，我们使用 Options API 的方式编写组件，Options API 最大的特点就是在对应的属性中编写对应的功能模块，比如在 data 中定义数据，在 methods 中定义方法，在 computed 中定义计算属性，在 watch 中监听属性改变，以及在组件中定义生命周期函数等。但是，使用 Options API 这种方式编写代码会带来一些弊端。</p>
<p>(1) 代码逻辑会被拆分，在实现某个功能时，对应的代码逻辑会被拆分到各个属性中。</p>
<p>(2) 当组件变得更大、更复杂时，逻辑关注点的列表就会变长，同一个功能的逻辑会被拆分得非常分撒。</p>
<p>(3) 对维护这些复杂组件的开发者来说，过于分散的逻辑代码难以阅读和理解。</p>
<blockquote>
<p>在代码的可读性和可维护性上，Composition API 优于 Options API</p>
</blockquote>
<p><strong>如果想要使用 Composition API 这种方式来编写代码，需要在 setup 函数中编写或使用 <code>&lt;script setup&gt;</code> 语法糖</strong></p>
<h2>setup 函数的基本使用</h2>
<h3>setup 函数的参数</h3>
<p>setup 函数的参数有两个，分别是 props 和 context。</p>
<p><strong>props 作为第一个参数，父组件传递过来的属性会被放到 props 对象中。因此，我们可以直接通过该参数获取父组件传递过来的属性。</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;setup-props&quot;&gt;
    &lt;h4&gt;{{ message }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: {
      message: {
        type: String,
        required: true,
      },
    },
    setup(props) {
      console.log(props);
      console.log(props.message);
    },
  };
&lt;/script&gt;
</code></pre>
<p>[231]</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>
    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      const switchBtn = document.querySelector(".layout__main_left-switch");
      const left = document.querySelector(".layout__main_left");

      // li active 滚动到中间位置
      const liA = document.querySelector(".layout__main_left li.active");
      if (liA) {
        liA.scrollIntoView({
          behavior: "smooth", // 平滑滚动
          block: "center", // 垂直方向滚动到视口中间
        });
      }

      switchBtn.addEventListener("click", () => {
        left.classList.toggle("show");
      });

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }

      // 监听 ctrl + b
      window.addEventListener("keydown", (e) => {
        const leftDom = document.querySelector(".layout__main_left");
        if (e.ctrlKey && e.key === "b") {
          leftDom.classList.toggle("hidden");
        }
      });
    </script>
  </body>
</html>
