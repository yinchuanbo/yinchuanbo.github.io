<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>Composition API 详解</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link id="prismTheme" rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700b3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
  </head>

  <body class="fade-in">
    <button
      class="toggle-sidebar"
      id="toggleSidebar"
      aria-label="Toggle Sidebar"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <div class="app-container">
      <!-- Sidebar Navigation -->
      <nav class="sidebar">
        <div class="sidebar-content">
          <div class="nav-section"><li class=""><a title="TypeScript 的进阶详解" href="/md/TypeScript 的进阶详解.html">22 TypeScript 的进阶详解</a></li><li class=""><a title="Vuex 状态管理" href="/md/Vuex 状态管理.html">21 Vuex 状态管理</a></li><li class=""><a title="Vue Router" href="/md/Vue Router.html">20 Vue Router</a></li><li class=""><a title="Vue 3 异常处理终极秘籍" href="/md/Vue 3 异常处理终极秘籍.html">19 Vue 3 异常处理终极秘籍</a></li><li class=""><a title="组件化高级详解" href="/md/组件化高级详解.html">18 组件化高级详解</a></li><li class=""><a title="你还不会调试线上 vue 组件" href="/md/你还不会调试线上 vue 组件.html">17 你还不会调试线上 vue 组件</a></li><li class=""><a title="如何构建高效的 Vue 3 前端项目结构" href="/md/如何构建高效的 Vue 3 前端项目结构.html">16 如何构建高效的 Vue 3 前端项目结构</a></li><li class=""><a title="vue3 vite 使用 代理转发" href="/md/vue3 vite 使用 代理转发.html">15 vue3 vite 使用 代理转发</a></li><li class=""><a title="分享一些 Vue 实用且常用的开发工具库" href="/md/分享一些 Vue 实用且常用的开发工具库.html">14 分享一些 Vue 实用且常用的开发工具库</a></li><li class=""><a title="Motion Vue 尤雨溪力荐的 Vue 动画库" href="/md/Motion Vue 尤雨溪力荐的 Vue 动画库.html">13 Motion Vue 尤雨溪力荐的 Vue 动画库</a></li><li class="active"><a title="Composition API 详解" href="/md/Composition API 详解.html">12 Composition API 详解</a></li><li class=""><a title="实现过渡动画" href="/md/实现过渡动画.html">11 实现过渡动画</a></li><li class=""><a title="组件化进阶详解" href="/md/组件化进阶详解.html">10 组件化进阶详解</a></li><li class=""><a title="组件化基础详解" href="/md/组件化基础详解.html">09 组件化基础详解</a></li><li class=""><a title="组件化开发" href="/md/组件化开发.html">08 组件化开发</a></li><li class=""><a title="v-model和表单输入" href="/md/v-model和表单输入.html">07 v-model和表单输入</a></li><li class=""><a title="vue3 的 Options API" href="/md/vue3 的 Options API.html">06 vue3 的 Options API</a></li><li class=""><a title="模板语法和内置命令" href="/md/模板语法和内置命令.html">05 模板语法和内置命令</a></li><li class=""><a title="前端 vue 项目使用 ffmpeg 处理视频" href="/md/前端 vue 项目使用 ffmpeg 处理视频.html">04 前端 vue 项目使用 ffmpeg 处理视频</a></li><li class=""><a title="Vue Router 4 的 scrollBehavior 方法" href="/md/Vue Router 4 的 scrollBehavior 方法.html">03 Vue Router 4 的 scrollBehavior 方法</a></li><li class=""><a title="浅浅聊一下 vue 中的 nextTick 的实现原理" href="/md/浅浅聊一下 vue 中的 nextTick 的实现原理.html">02 浅浅聊一下 vue 中的 nextTick 的实现原理</a></li><li class=""><a title="Vue3.x 生态最能打的组合" href="/md/Vue3.x 生态最能打的组合.html">01 Vue3.x 生态最能打的组合</a></li></div>
        </div>
      </nav>

      <!-- Main Content Area -->
      <main class="main-content">
        <header class="content-header">
          <div class="header-left">
            <h1 class="page-title">Composition API 详解</h1>
            <p class="time">HaoTian · 2025-01-17 21:41:48</p>
          </div>
          <div class="header-right">
            <div class="tag-container">
              <span class="tag">Vue</span>
            </div>
            <button
              id="themeToggle"
              class="theme-toggle"
              aria-label="Toggle theme"
            >
              <svg
                class="sun-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
              <svg
                class="moon-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
            </button>
            <button
              class="theme-toggle"
              aria-label="Toggle theme"
              style="width: 36px; height: 36px"
              onclick="window.location.href='/md';"
            >
              <svg
                t="1737442501710"
                class="icon"
                viewBox="0 0 1024 1024"
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
                p-id="5258"
                width="20"
                height="20"
              >
                <path
                  d="M883.773793 626.047476c-17.308201 0-31.408337 14.029528-31.408337 31.304983l0 207.437469c0 17.204847-14.098089 31.302937-31.406291 31.302937L203.040834 896.092865c-17.340947 0-31.408337-14.098089-31.408337-31.302937L171.632497 657.352459c0-17.275455-14.099113-31.304983-31.408337-31.304983-17.380856 0-31.444153 14.029528-31.444153 31.304983l0 207.437469c0 51.773154 42.261523 93.91188 94.260827 93.91188l617.918331 0c52.031027 0 94.259804-42.139749 94.259804-93.91188L915.21897 657.352459C915.21897 640.077004 901.152603 626.047476 883.773793 626.047476L883.773793 626.047476zM230.262826 614.286618c55.523571 0 104.556311-27.674293 134.394896-69.762877 32.487925 46.451962 86.303598 77.0744 147.343813 77.0744 61.036122 0 114.846678-30.623461 147.306974-77.0744 29.943986 42.018999 78.902024 69.762877 134.426619 69.762877 90.948385 0 164.968216-73.77526 164.968216-164.371628 0-11.062963-2.342348-22.859637-5.130857-35.178197-0.209778-1.134847 0.031722-2.26867-0.277316-3.38612l-0.629333-2.267647c-0.24764-0.924045-0.140193-1.535983-0.352017-2.547009-0.138146-0.505513-0.521886-0.87288-0.695848-1.39579l-85.364203-316.671313c-3.699252-13.645788-16.051581-23.172769-30.293957-23.172769L187.965487 65.296145c-14.238282 0-26.665313 9.526981-30.360472 23.24133L72.309374 405.1566c-0.103354 0.50756-0.48607 0.820692-0.62524 1.309832-0.210801 0.942465-0.107447 1.639337-0.349971 2.511193l-0.62524 2.373047c-0.318248 1.11745 0 2.25025-0.210801 3.38612-2.863211 12.31856-5.201465 24.115234-5.201465 35.178197C65.295634 540.511357 139.315464 614.286618 230.262826 614.286618L230.262826 614.286618z"
                  fill="currentColor"
                  p-id="5259"
                ></path>
              </svg>
            </button>
          </div>
        </header>

        <!-- Article Content -->
        <article
          class="content-body md md "
        >
          <p>随着项目规模的扩大，组件数量也会逐渐增多，这时需要考虑复用组件逻辑。</p>
<p>在 Vue3 中，有两种主要的组件逻辑复用方式：Mixin 和 Composition API。</p>
<h2>Options API 代码的复用</h2>
<h3>Mixin 混入</h3>
<p>组件与组件之间有时会存在相同的代码逻辑，这时我们希望对相同的代码逻辑进行抽取。与 Vue2 一样，Vue3 也支持使用 Mixin 完成代码的复用。</p>
<p>Mixin 具有如下特点：</p>
<p>(1) Mixin 提供了一种非常灵活的方式来分发 Vue3 组件中可复用的功能</p>
<p>(2) 一个 Mixin 对象可以包含任何组件的选项（Options API）</p>
<p>(3) 当组件使用 Mixin 对象时，所有 Mixin 对象的选项都将被混入该组件本身的选项中</p>
<p><strong>1. Mixin 的基本使用</strong></p>
<pre><code class="language-js">// demoMixin.js
// 定义一个 Mixin 混合对象，将组件公用的代码逻辑抽取到 demoMixin 中
export const demoMixin = {
  data() {
    return {
      message: &quot;Hello DemoMixin&quot;,
    };
  },
  methods: {
    foo() {
      console.log(&quot;demo mixin foo&quot;);
    },
  },
  created() {
    console.log(&quot;执行了 demo mixin created&quot;);
  },
};
</code></pre>
<ul>
<li>App.vue 组件，代码如下：</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;{{ message }}&lt;/h2&gt;
    &lt;button @click=&quot;foo&quot;&gt;单击调用 demoMixin 定义的 foo 方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { demoMixin } from &quot;./mixins/demoMixin.js&quot;;
  export default {
    // 将 demoMixin 定义的 data、methods、created 选项混入该组件中，也支持混入其他组件
    mixins: [demoMixin],
  };
&lt;/script&gt;
</code></pre>
<p><strong>2. Mixin 的合并规则</strong></p>
<p>如果 Mixin 对象中的选项和组件对象中的选项发生了冲突，那么 Vue3 会分成三种情况来处理。</p>
<p>(1) 处理 data 函数返回值对象。</p>
<p>默认情况下，Mixin 对象中 data 选项的返回值和组件对象中 data 选项的返回值会进行合并。</p>
<p>如果它们的 data 选项返回值对象的属性发生了冲突，那么会保留组件对象自身的数据，</p>
<p>(2) 处理生命周期钩子函数。</p>
<p>Mixin 对象和组件对象中的生命周期钩子函数会被合并到数组中，都会调用。</p>
<p>(3) 处理值为对象的选项。</p>
<p>如 methods、components、directives 选项，将被合并为同一个对象。</p>
<p>例如，Mixin 对象和组件对象中都有 methods 选项，并且都定义了方法，那么它们都会生效。但是如果对象的 key 相同，那么会取组件对象的键值对。</p>
<p>下面演示一下 Mixin 的合并规则：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;{{ message }}&lt;/h2&gt;
    &lt;button @click=&quot;foo&quot;&gt;单击调用 demoMixin 定义的 foo 方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { demoMixin } from &quot;./mixins/demoMixin.js&quot;;
  export default {
    mixins: [demoMixin],
    data() {
      return {
        // 1. message 变量和 demoMixin 对象中定义的 message 冲突，那么会使用该组件的 message
        message: &quot;Hello App&quot;,
        title: &quot;Hello World&quot;,
      };
    },
    methods: {
      // 2. foo 方法和 demoMixin 对象中定义的 foo 方法冲突，那么会使用该组件的 foo 方法
      foo() {
        console.log(&quot;app foo&quot;);
      },
      bar() {
        console.log(&quot;bar function&quot;);
      },
    },
    computed: {},
    watch: {},
    // 3. 生命周期的钩子函数和 demoMixin 对象中的重复，那么它们会被合并到数组中，都会被调用
    created() {
      console.log(&quot;App created 执行&quot;);
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>3. 全局混入 Mixin</strong></p>
<p>如果所有组件都需要某些选项，那么可以使用全局 Mixin，全局 Mixin 可以使用 <code>app.mixin</code> 方法进行注册。</p>
<p>一旦注册，全局混入的选项将被混入每个组件中。</p>
<ul>
<li>修改 main.js</li>
</ul>
<pre><code class="language-js">import { createApp } from &quot;vue&quot;;
import App from &quot;./01_Mixin/App.vue&quot;;

let app = createApp(App);

// 注册全局混入
app.mixin({
  created() {
    console.log(&quot;global mixin created&quot;);
  },
});

app.mount(&quot;#app&quot;);
</code></pre>
<p>尽管 Mixin 可以对组件代码逻辑进行抽取和复用，但他存在如下缺陷：</p>
<p>(1) Mixin 容易发生冲突。</p>
<p>(2) Mixin 的可复用性是有限的。</p>
<h3>extends 继承</h3>
<p>除了 Mixin，Vue 3 还提供了另一种代码逻辑复用的方式，即使用 extends 属性，</p>
<p>使用 extends 属性可以扩展另一个组件，类似于 Mixin，但使用较少，了解即可。</p>
<pre><code class="language-html">&lt;!-- BasePage.vue --&gt;
&lt;!-- extends 属性只能复用 script 标签中的逻辑，不能复用 template 和 style --&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        title: &quot;Hello BasePage&quot;,
      };
    },
    methods: {
      bar() {
        console.log(&quot;base page bar&quot;);
      },
    },
  };
&lt;/script&gt;
</code></pre>
<p>上面代码用于复用 data 和 methods 选项中公共的代码逻辑。</p>
<pre><code class="language-html">&lt;!-- Home.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;home&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;h4&gt;{{ title }}&lt;/h4&gt;
    &lt;button @click=&quot;bar&quot;&gt;单击调用 BasePage 组件定义的 bar 方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import BasePage from &quot;./BasePage.vue&quot;;
  export default {
    exends: BasePage,
  };
&lt;/script&gt;
</code></pre>
<h2>认识 Composition API</h2>
<p>在 Vue2 中，我们使用 Options API 的方式编写组件，Options API 最大的特点就是在对应的属性中编写对应的功能模块，比如在 data 中定义数据，在 methods 中定义方法，在 computed 中定义计算属性，在 watch 中监听属性改变，以及在组件中定义生命周期函数等。但是，使用 Options API 这种方式编写代码会带来一些弊端。</p>
<p>(1) 代码逻辑会被拆分，在实现某个功能时，对应的代码逻辑会被拆分到各个属性中。</p>
<p>(2) 当组件变得更大、更复杂时，逻辑关注点的列表就会变长，同一个功能的逻辑会被拆分得非常分撒。</p>
<p>(3) 对维护这些复杂组件的开发者来说，过于分散的逻辑代码难以阅读和理解。</p>
<blockquote>
<p>在代码的可读性和可维护性上，Composition API 优于 Options API</p>
</blockquote>
<p><strong>如果想要使用 Composition API 这种方式来编写代码，需要在 setup 函数中编写或使用 <code>&lt;script setup&gt;</code> 语法糖</strong></p>
<h2>setup 函数的基本使用</h2>
<h3>setup 函数的参数</h3>
<p>setup 函数的参数有两个，分别是 props 和 context。</p>
<p><strong>props 作为第一个参数，父组件传递过来的属性会被放到 props 对象中。因此，我们可以直接通过该参数获取父组件传递过来的属性。</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;setup-props&quot;&gt;
    &lt;h4&gt;{{ message }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: {
      message: {
        type: String,
        required: true,
      },
    },
    setup(props) {
      console.log(props);
      console.log(props.message);
    },
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>需要注意的是，setup 函数可以直接通过参数来接收 props 对象，不可以通过 this 获取，因为 setup 函数没有绑定 this</p>
</blockquote>
<p><strong>setup 函数第二个参数是 context，该参数对象包含以下三个属性：</strong></p>
<ul>
<li><p>attrs: 所有非 prop 的属性</p>
</li>
<li><p>slots: 父组件传递过来的插槽</p>
</li>
<li><p>emit: 组件内部发送事件时用到的 emit 函数 (setup 中不能访问 this，因此不可使用 this.$emit)</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- SetupContext.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;setup-context&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;h4&gt;{{ message }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: {
      message: {
        type: String,
        required: true,
      },
    },
    setup(props, context) {
      console.log(props); // 1. 所有的 props 属性
      console.log(props.message); // 2. 父组件传递过来的 message
      console.log(context.attrs.id, context.attrs.class); // 3. 所有非 prop 的属性
      console.log(context.slots); // 4. 父组件传递过来的插槽
      console.log(context.emit); // 5. 用于触发事件，如 context.emit(&quot;name&quot;, value)
    },
  };
&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;app&quot; style=&quot;border: 1px solid #ddd; margin: 4px&quot;&gt;
    &lt;SetupContext
      message=&quot;Hello SetupContext&quot;
      id=&quot;setup-context&quot;
      class=&quot;setup-context&quot;
    &gt;
      &lt;p&gt;Hello World&lt;/p&gt;
    &lt;/SetupContext&gt;
  &lt;/div&gt;&lt;/template
&gt;
&lt;script&gt;
  import SetupContext from &quot;./components/SetupContext.vue&quot;;
  export default {
    name: &quot;App&quot;,
    components: {
      SetupContext,
    },
  };
&lt;/script&gt;
</code></pre>
<h3>setup 函数的返回值</h3>
<p>在 Vue3 中，setup 函数不仅可以接收 props 和 context 参数，还可以像普通函数一样有返回值。</p>
<p>具体而言，setup 函数可以返回一个对象类型的值，该值可以直接在模板（template）中使用。这意味着，<strong>我们可以使用 setup 函数的返回值代替 data 选项的返回值</strong>。</p>
<pre><code class="language-html">&lt;!-- SetupReturn.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;setup-return&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;h4&gt;当前计数：{{ counter }}&lt;/h4&gt;
    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    setup(props, context) {
      let counter = 100;
      const increment = () =&gt; {
        counter++;
      };
      return {
        // 提供给 template 使用
        counter: counter,
        increment: increment,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>可以看到，counter 的值显示出来了，当单击 “+1” 按钮时，会调用 increment 函数来修改 counter 的值，但是页面的数组并没有响应式更新，因为 counter 是一个普通的变量。</p>
</blockquote>
<h3>setup 函数的 this</h3>
<p>在 setup 函数中，this 并<strong>没有</strong>指向当前组件实例。此外，在调用 setup 函数之前，<strong>data、computed、methods</strong> 等都<strong>没有</strong>被解析，Vue3 框架也没有为 setup 函数绑定 this，因此<strong>无法</strong>在 setup 中获取 this。</p>
<h2>数据响应式 API</h2>
<p>若要使用 Options API 编写代码，可以在 data 选项中定义响应式数据，如果在 setup 函数中也需要定义响应式数据，那么可以使用 Vue3 提供的响应式 API: <code>reactive</code>、<code>ref</code>。</p>
<h3>reactive</h3>
<p>该函数可以将数据转换为响应式数据，并且响应式<code>深层</code>的 - 它影响所有的嵌套属性。</p>
<p>其底层原理基于 ES2015 的 Proxy 实现，所以 reactive 函数的返回值是一个对象的响应式代理。</p>
<pre><code class="language-html">&lt;!-- reactiveAPI.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;setup-return&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;h4&gt;当前计数：{{ state.counter }}&lt;/h4&gt;
    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    setup(props, context) {
      let state = reactive({
        counter: 100,
      });
      const increment = () =&gt; {
        state.counter++;
      };
      return {
        state,
        increment,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>事实上，data 选项返回的对象在 Vue3 内部也交给了 reactive 函数，将其变成响应式对象。</p>
<h3>ref</h3>
<p>reactive 函数对传入的数据的类型是有限制的，必须是一个对象或数据组类型，如果传入一个基本类型（String、Number、Boolean），那么会报错。那么，为了适配这种情况，Vue3 提供了 ref 函数，可以将基本类型的数据转换为响应式数据。</p>
<p>(1) ref 函数接收一个值，返回一个响应式、可更改的 ref 对象，此对象只有一个指向其内部值的属性 <code>.value</code>。</p>
<p>(2) ref 对象的内部值是通过该对象的 <code>.value</code> 属性维护的，比如可以通过 <code>.value</code> 为该 ref 对象赋新值。</p>
<pre><code class="language-html">&lt;!-- RefAPI.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;ref-api&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;h4&gt;当前计数：{{ counter }}&lt;/h4&gt;
    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { ref } from &quot;vue&quot;;
  export default {
    setup(props, context) {
      let counter = ref(100);
      const increment = () =&gt; {
        counter.value++;
      };
      return {
        counter,
        increment,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>注意：在模板中使用 ref 对象时，Vue3 会自动进行解包操作，不需要通过 <code>.value</code> 的方式访问内部值。但是，在 setup 函数内部不会自动解包，因此仍需要使用 <code>.value</code> 的方式访问内部值。</p>
</blockquote>
<p><strong>另外，需要注意的是:</strong></p>
<p>〇 如果普通对象包含 ref 对象，那么在模板中引用普通对象中的 ref 对象时，会自动解包。</p>
<p>〇 如果 reactive 响应式对象包含 ref 对象，那么在模板中引用 reactive 响应式对象中 ref 对象时，也会自动解包。</p>
<pre><code class="language-html">&lt;!-- RefAPIOther.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;ref-api-other&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;h4&gt;当前计数：{{ counter }}&lt;/h4&gt;
    &lt;h2&gt;当前计算：{{ info.counter }}&lt;/h2&gt;
    &lt;h2&gt;当前计算：{{ reactiveInfo.agcountere }}&lt;/h2&gt;
    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;&lt;/template
&gt;
&lt;script&gt;
  import { ref, reactive } from &quot;vue&quot;;
  export default {
    setup(props, context) {
      let counter = ref(100);
      let info = {
        counter,
      };
      let reactiveInfo = reactive({
        counter,
      });
      const increment = () =&gt; {
        counter.value++;
      };
      return {
        counter,
        info,
        reactiveInfo,
        increment,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h2>响应式工具 reactive</h2>
<h3>readonly</h3>
<p>通过 reactive 或 ref 函数可以获取一个响应式对象。这些响应式对象都是可以被更改的，但是在某些情况下，我们希望响应式对象只读且不能更改。比如，当我们在向其他组件传递数据时，希望其他子组件在使用该内容时不允许修改。</p>
<p>这时可以使用 Vue3 提供的 readonly 函数。该函数会返回原生对象的只读代理对象，该对象的 setter 方法被劫持了，不允许对其进行修改。readonly 函数通常可接收以下三种类型的参数。</p>
<p>(1) 普通对象</p>
<p>(2) reactive 函数返回的响应式对象</p>
<p>(3) ref 函数返回的响应式对象</p>
<p><strong>readonly 函数在使用时，有如下规则:</strong></p>
<ul>
<li><p>readonly 返回的对象都是不允许被修改的。但是，经过 readonly 处理的原来的对象是允许被修改的。比如，在 <code>const info = readonly(obj)</code> 中，info 对象是不允许被修改的，obj 是可以被修改的。当 obj 被修改时，readonly 返回的 info 对象也会被修改。但是，我们不能修改 readonly 返回的 info 对象，否则会报错。</p>
</li>
<li><p>readonly 函数的本质是该函数返回代理对象的 setter 方法被劫持了，不允许对其进行修改。</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- ReadonlyAPI.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;updateState&quot;&gt;修改状态&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { ref, reactive, readonly } from &quot;vue&quot;;
  export default {
    setup(props, context) {
      const info1 = { name: &quot;why&quot; };
      const readonlyInfo1 = readonly(info1);

      const info2 = reactive({
        name: &quot;why&quot;,
      });
      const readonlyInfo2 = readonly(info2);

      const info3 = ref(&quot;why&quot;);
      const readonlyInfo3 = readonly(info3);

      const updateState = () =&gt; {
        readonlyInfo1.name = &quot;coderwhy&quot;; // 只读，控制台报错
        // info1.name = &quot;coderwhy&quot;; // 允许修改

        readonlyInfo2.name = &quot;coderwhy&quot;; // 只读，控制台报错
        // info2.name = &quot;coderwhy&quot;; // 允许修改

        readonlyInfo3.value = &quot;coderwhy&quot;; // 只读，控制台报错
        // info3.value = &quot;coderwhy&quot;; // 允许修改
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>isProxy</h3>
<p>isProxy 函数可以检査对象是否为由 Vue3 中的 reactive 或 readonly 创建的 Proxy 对象。</p>
<p>需要注意的是，ref 创建的是 RefImpl 对象，因此 isProxy 函数不能用于检查对象是否为 ref 对象。</p>
<h3>isReactive</h3>
<p>isReactive 函数可以检查对象是否为由 reactive 创建的响应式代理对象</p>
<pre><code class="language-js">import { reactive, isReactive, isProxy } from &quot;vue&quot;;
export default {
  setup(props, context) {
    const info = reactive({
      name: &quot;why&quot;,
    });
    console.log(isReactive(info)); // true
    console.log(isProxy(info)); // true
  },
};
</code></pre>
<p>如果代理对象是由 readonly 函数创建的，并且参数为 reactive 创建的响应式对象，那么也会返回 true，</p>
<pre><code class="language-js">import { reactive, isReactive, readonly } from &quot;vue&quot;;
export default {
  setup(props, context) {
    const state = reactive({
      name: &quot;why&quot;,
    });
    const plain = readonly({
      name: &quot;Mary&quot;,
    });

    console.log(isReactive(plain)); // false

    const stateCopy = readonly(state);
    console.log(isReactive(stateCopy)); // true
  },
};
</code></pre>
<h3>isReadonly</h3>
<p>isReadonly 函数可以用于检查一个对象是否为由 readonly 创建的只读代理对象。</p>
<h3>toRaw</h3>
<p>toRaw 函数可以返回 reactive 或 readonly 代理对象的原始对象。</p>
<pre><code class="language-js">const info = { name: &quot;why&quot; };
const reactiveInfo = reactive(info);
console.log(toRaw(reactiveInfo) === info); // true

const readonlyInfo = readonly(info);
console.log(toRaw(readonlyInfo) === info); // true
</code></pre>
<h3>shallowReactive</h3>
<p>shallowReactive 函数可以创建一个浅层响应式代理对象，该对象只有根级别的属性是响应式的，</p>
<p>由于没有进行深层级的转换，该对象深层嵌套的属性仍然是普通对象。</p>
<pre><code class="language-js">const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2,
  },
});
state.foo++;
isReactive(state.nested); // false
state.nested.bar++; // 非响应式
</code></pre>
<h3>shallowReadonly</h3>
<p>shallowReadonly 函数可以创建一个浅层只读代理对象，该对象只有根级别的属性变为只读。因为没有进行深层级的转换，该对象深层嵌套的属性依然是可读可写的，</p>
<pre><code class="language-js">const state = shallowReadonly({
  foo: 1,
  nested: {
    bar: 2,
  },
});
state.foo++;
isReadonly(state.nested); // false
state.nested.bar++; // 深层嵌套的属性依然是可读可写
</code></pre>
<h3>响应式工具 ref</h3>
<h3>toRefs</h3>
<p>toRefs 函数用于将一个 reactive 定义的响应式对象转换为一个普通对象。转换后的普通对象的每个属性都是指向源对象相应属性的 ref 对象。</p>
<p>每个单独的 ref 对象都是使用 toRefs 函创建的</p>
<pre><code class="language-html">&lt;!-- ToRefsAPI.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;{{name}} - {{ age }}&lt;/h4&gt;
    &lt;button @click=&quot;changeAge&quot;&gt;修改 age++&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { reactive } from &quot;vue&quot;;
  export default {
    setup() {
      const info = reactive({
        name: &quot;why&quot;,
        age: 18,
      });
      // 1. ES6 语法直接解构 info 对象，会失去响应式
      let { name. age } = info;
      const changeAge = () =&gt; {
        info.age++;
      };
      return {
        name,
        age,
        changeAge
      }
    },
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>需要注意的是，无论是修改解构后的 name 和 age 变量，还是修改 reactive 返回的 info 对象，数据都不再是响应式的。</p>
</blockquote>
<p>如果想让解构出来的属性依然是响应式的，可以使用 Vue3 提供的 toRefs 函数。该函数会将 reactive 函数返回对象中的属性都转换成 ref 对象。这时解构出来的 name 和 age 就是 ref 响应式对象了。</p>
<pre><code class="language-html">&lt;script&gt;
  import { reactive, toRefs } from &quot;vue&quot;;
  export default {
    setup() {
      const info = reactive({
        name: &quot;why&quot;,
        age: 18,
      });
      // let { name. age } = info;
      // 1. 保持响应式特性
      let { name, age } = toRefs(info);
      const changeAge = () =&gt; {
        info.age++;
      };
      return {
        name,
        age,
        changeAge,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>toRef</h3>
<p>在上面的案例中，如果只想将 reactive 函数返回对象中的某个属性转换为 ref 对象，我们可以使用 toRef 的数。</p>
<pre><code class="language-html">&lt;!-- ToRefsAPI.vue --&gt;
&lt;script&gt;
  import { reactive, toRef } from &quot;vue&quot;;
  export default {
    setup() {
      const info = reactive({
        name: &quot;why&quot;,
        age: 18,
      });

      // 单个属性，局部转化
      let name = toRef(info, &quot;name&quot;);
      let age = toRef(info, &quot;age&quot;);

      const changeAge = () =&gt; {
        info.age++;
      };

      return {
        name,
        age,
        changeAge,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>isRef</h3>
<p>isRef 函数可以判断某个值是否为一个 ref 对象。</p>
<h3>unref</h3>
<p>unref 函数的参数如果是 ref，则返回内部值 value，否则返回参数本身。该函数是 <code>val = isRef(val) ? val.value : val</code> 计算的一个语法糖。</p>
<pre><code class="language-js">import { ref, unref } from &quot;vue&quot;;
const name = ref(&quot;why&quot;);
const unwrappedName = unref(name);
console.log(unwrappedName); // &quot;why&quot;，不是响应式对象
</code></pre>
<h3>customRef</h3>
<p>customRef 函数可以创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行控制。该函数接收一个工厂函数作为参数，该工厂函数接收 track 和 trigger 两个函数作为参数，并返回一个带有 get 和 set 方法的对象。</p>
<pre><code class="language-js">// useDebouncedRef.js
import { customRef } from &quot;vue&quot;;
export default function (value, delay = 300) {
  let timer = null;
  // 自定义 ref
  return customRef((track, trigger) =&gt; {
    // 工厂函数接收 track 和 trigger 两个函数作为参数
    return {
      get() {
        track(); // 获取时收集依赖
        return value;
      },
      set(newValue) {
        clearTimeout(timer);
        timer = setTimeout(() =&gt; {
          value = newValue; // 更新值
          trigger(); // 赋值时，触发更新
        }, delay);
      },
    };
  });
}
</code></pre>
<pre><code class="language-html">&lt;!-- CustomRefAPI.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;input v-model=&quot;message&quot; /&gt;
    &lt;h4&gt;{{ message }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import useDebouncedRef from &quot;./utils/useDebouncedRef&quot;;
  export default {
    setup() {
      let message = useDebouncedRef(&quot;hello world&quot;); // 带有防抖功能的响应式对象
      return {
        message,
      };
    },
  };
</code></pre>
<blockquote>
<p>效果：当在 input 输入框中依次输入值时，并不会触发页面的刷新，只有当输入间隔超过 300ms 时，页面才会刷新。</p>
</blockquote>
<h3>shallowRef</h3>
<p>shallowRef 函数可以创建一个浅层的 ref 对象。</p>
<pre><code class="language-js">const info = shallowRef({ name: &quot;why&quot; });
// 当修改 info.value 时，不会触发页面的更新
info.value.name = &quot;coderwhy&quot;;
</code></pre>
<h3>triggerRef</h3>
<p>triggerRef 函数可以手动强制触发依赖于一个浅层 ref 的副作用，它通常在对浅引用内部值进行深度变更后使用。</p>
<pre><code class="language-js">const info = shallowRef({ name: &quot;why&quot; });
const changeInfo = () =&gt; {
  info.value.name = &quot;coderwhy&quot;;
  // 手动触发依赖
  triggerRef(info);
};
</code></pre>
<h2>computed 计算属性</h2>
<p>当某些属性依赖于其他状态时，可以使用计算属性来处理，举例如下：</p>
<ul>
<li><p>在 Options API 中，可以使用 computed 选项编写计算属性。</p>
</li>
<li><p>在 Composition API 中，可以在 setup 函数中使用 computed 函数编写计算属性。</p>
</li>
</ul>
<p><strong>下面我们来看看 computed 函数的两种使用方式：</strong></p>
<ol>
<li><p>computed 函数的基本使用: computed 数接收一个 getter 函数，并根据 getter 函数的返回值返回一个不可变的响应式 ref 对象。</p>
</li>
<li><p>computed 函数的 get 和 set 方法: computed 函数接收一个具有 get 和 set 方法的对象并返回一个可变(可读写)的 ref 对象。</p>
</li>
</ol>
<h3>computed 函数的基本使用</h3>
<pre><code class="language-html">&lt;!-- ComputedAPI.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;{{ fullName }}&lt;/h4&gt;
    &lt;button @click=&quot;changeName&quot;&gt;修改 firstName&lt;/button&gt;`
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { ref, computed } from &quot;vue&quot;;
  export default {
    setup(props, context) {
      const firstName = ref(&quot;Kobe&quot;);
      const lastName = ref(&quot;Bryant&quot;);
      const fullName = computed(() =&gt; {
        return firstName.value + &quot; &quot; + lastName.value;
      });
      const changeName = () =&gt; {
        firstName.value = &quot;James&quot;;
      };
      return {
        fullName,
        changeName,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>computed 函数的 get 和 set 方法</h3>
<pre><code class="language-html">&lt;script&gt;
  import { ref, computed } from &quot;vue&quot;;
  export default {
    setup(props, context) {
      const firstName = ref(&quot;Kobe&quot;);
      const lastName = ref(&quot;Bryant&quot;);
      // 方式 1
      // const fullName = computed(() =&gt; {
      //   return firstName.value + &quot; &quot; + lastName.value;
      // });

      // 方式 2
      const fullName = computed({
        get() {
          return firstName.value + &quot; &quot; + lastName.value;
        },
        set(value) {
          const names = value.split(&quot; &quot;);
          firstName.value = names[0];
          lastName.value = names[1];
        },
      });
      const changeName = () =&gt; {
        // firstName.value = &quot;James&quot;;
        // 修改计算属性
        fullName.value = &quot;James Lee&quot;;
      };
      return {
        fullName,
        changeName,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h2>watchEffect 监听</h2>
<p>在 Vue3 中，我们可以使用 OptionsAPI 监听 data、props 或 computed 数据的变化，比如当数据变化时执行某些操作。而在 CompositionAPI 中，我们可以使用 watchEffect 和 watch 函数完成响应式数据的监听。其中，watchEffect 函数用于自动收集响应式数据的依赖，而 watch 函数需要手动指定监听的数据源。</p>
<h3>watchEffect 的基本使用</h3>
<p>如果我们需要在某些响应式数据变化时执行某些操作，就可以使用 watchEffect 函数。</p>
<p>该函数具有以下特点：</p>
<ul>
<li><p>watchEffect 函数的参数需要接收一个函数。该函数会被立即执行一次，并且在执行的过程中会收集依赖。</p>
</li>
<li><p>当收集的依赖发生变化时，watchEffect 函数的参数传入的函数（即副作用函数）才会再次执行</p>
</li>
<li><p>watchEffect 函数的参数传入的函数不会接收到新值和旧值。</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- WatchEffectAPI.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;{{ age }}&lt;/h4&gt;
    &lt;button @click=&quot;changeAge&quot;&gt;修改 age&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { ref, watchEffect } from &quot;vue&quot;;
  export default {
    setup(props, context) {
      const age = ref(18);
      // watchEffect 会自动收集响应式依赖，默认先执行一次
      watchEffect(() =&gt; {
        // 监听 age 的变化，age 变化后再次执行该回调函数
        console.log(&quot;age 的值是：&quot;, age.value);
      });
      const changeAge = () =&gt; {
        age.value++;
      };
      return {
        age,
        changeAge,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>停止 watchEffect 监听</h3>
<p>在某些情况下，我们希望停止监听某个变量的变化。这时可以使用 watchEtect 函数，并接收其返回值的函数，调用该函数即可停止监听。比如在上面的案例中，当 age 达到 20 时，我们希望停止监听其变化。</p>
<pre><code class="language-html">&lt;script&gt;
  import { ref, watchEffect } from &quot;vue&quot;;
  export default {
    setup(props, context) {
      const age = ref(18);
      // 1. stop 是 watchEffect 函数返回的函数，专门用于停止监听
      const stop = watchEffect(() =&gt; {
        console.log(&quot;age 的值是：&quot;, age.value);
      });
      const changeAge = () =&gt; {
        age.value++;
        if (age.value &gt;= 20) {
          stop(); // 停止监听 age 的变化
        }
      };
      return {
        age,
        changeAge,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>watchEffect 清除副作用</h3>
<p>在 Vue3 watchEffect 函数的参数传入的回调函数可以接收一个 onInvalidate 函数类型的参数。onInvalidate 函数的参数也需要接收一个回调函数。当副作用函数再次执行或监听器被停止时，会执行 onInvalidate 函数传入的回调函数。因此，我们可以在 onlnvalidate 函数传入
的回调函数中执行一些清除副作用的工作。</p>
<p>举个例子，在实际开发中，我们需要在监听函数中执行网络请求。但是在网络请求还没有完成时，我们就停止了监听器或监听器对应的监听函数被再次执行了。这时，上一次的网络请求应该被取消，即清除该副作用。因此，我们可以借助 onInvalidate 函数清除该副作用。</p>
<pre><code class="language-html">&lt;!-- WatchEffectAPIClear.vue --&gt;
&lt;script&gt;
  import { ref, watchEffect } from &quot;vue&quot;;
  export default {
    setup() {
      const age = ref(18);
      watchEffect((onInvalidate) =&gt; {
        const timer = setTimeout(() =&gt; {
          console.log(&quot;模拟网络请求，网路请求成功&quot;);
        }, 2000);
        onInvalidate(() =&gt; {
          // 监听到 age 变化或监听停止时，会执行这里的代码
          // 这里清除副作用
          clearTimeout(timer);
          console.log(&quot;清除副作用&quot;);
        });
      });
      const changeAge = () =&gt; {
        age.value++;
      };
      return {
        age,
        changeAge,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>watchEffect 的执行时机</h3>
<p>先讲一下如何使用 CompositionAPI 获取元素或组件的对象。这个过程非常简单，只需要定义一个前文提到的 ref 对象，然后将该对象绑定到元素或组件的 ref 属性上。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4 ref=&quot;titleRef&quot;&gt;哈哈哈&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { ref, watchEffect } from &quot;vue&quot;;
  export default {
    setup() {
      // 1. 定义一个 titleRef 对象，用于存储 h4 元素的 DOM 对象
      const titleRef = ref(null);
      // 2. 监听titleRef的变化，即赋值操作
      watchEffect(() =&gt; {
        // 3. 打印 h4 元素的 DOM 对象
        console.log(titleRef.value);
      });
      return {
        titleRef,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>在浏览器中刷新页面，控制台会打印两次。这是因为 setup 函数在执行时就会立即执行 watchEffect 传入的副作用函数，即 watchEffect 的回调函数。此时 DOM 并没有挂载，因此打印 null。而当 DOM 挂载时，会为 titleRef 变量赋新的内部值，副作用函数会再次被执行，打印出<code>&lt;h4&gt;</code> 元素；使用 ref 获取元素的对象，</p>
<p>这时，如果希望在第一次执行时就打印出对应的元素，那么可以向 watchEffect 函数传递第二个参数，改变副作用函数的执行时机。</p>
<p>例如，向 watchEffect 函数的第二个参数传递一个对象 <code>{ flush: &quot;pre&quot; }</code>，flush 属性的默认值是 pre，意思是 watchEffect 函数会在元素挂载或更新之前执行，这就解释了前面的例子中，为什么会先打印出一个空元素 null，当依赖的 titleRef 发生改变时，会再次执行一次 watchEffect 函数，打印出对应的元素。</p>
<pre><code class="language-html">&lt;script&gt;
  import { ref, watchEffect } from &quot;vue&quot;;
  export default {
    setup() {
      const titleRef = ref(null);
      watchEffect(
        () =&gt; {
          console.log(titleRef.value);
        },
        {
          flush: &quot;post&quot;, // 修改副作用函数的执行时机，支持pre、post、sync 值
        }
      );
      return {
        titleRef,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>可以看到，watchEffect 函数第二个参数需要接收一个对象，该对象的 flush 属性用于修改副作用函数的执行时机。设置 <code>flush: &quot;post&quot;</code> 的意思是，副作用函数会延迟到组件渲染之后再执行。</p>
<blockquote>
<p>注意：当设置 flush: &quot;sync&quot; 时，意思是依赖变化时同步执行副作用函数，这种执行是低效的，谨慎使用。</p>
</blockquote>
<blockquote>
<p>提示:在 Vue3.2 以后的版本中，watchPostEffect 是 watchEfect 带有 <code>flush:&quot;post&quot;</code> 选项的别名，watchSyncEffect 是 watchEffect 带有 <code>flush&quot;sync&quot;</code> 选项的别名</p>
</blockquote>
<h3>watch 监听</h3>
<p>watchEffect 函数会自动收集响应式数据的依赖，而 watch 函数则需要手动指定监听数据源，并且完全等同于第 3 章中的 watch 选项。</p>
<p><strong>watch 函数的特点如下：</strong></p>
<ul>
<li><p>在默认情况下，watch 函数是惰性的，只有当被监听的源发生变化时，才会执行回调函数(副作用函数)。</p>
</li>
<li><p>watch 函数需要手动指定监听的数据源，而 watchEfect 函数会自动收集响应式数据的依赖。</p>
</li>
<li><p>watch 函数在副作用函数中可以接收到新值和旧值，而 watchEffect 函数接收不到</p>
</li>
</ul>
<h3>监听单个数据源</h3>
<p>watch 函数可以监听两种类型的数据源：</p>
<ol>
<li><p>getter 函数: 该函数必须引用响应式对象，如 reactive 或 ref 函数返回的响应式对象</p>
</li>
<li><p>响应式对象: 直接接收一个响应式对象，如 reactive 或 ref 函数返回的响应式对象。</p>
</li>
</ol>
<p><strong>案例一: watch 函数监听的数据源为一个 getter 函数。</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;{{ info.name }}&lt;/h4&gt;
    &lt;button @click=&quot;changeData&quot;&gt;修改数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { reactive, watch } from &quot;vue&quot;;
  export default {
    setup() {
      const info = reactive({
        name: &quot;why&quot;,
        age: 18,
      });
      watch(
        // 1. 第一个参数：getter 函数，该函数必须引用响应式对象
        () =&gt; info.name,
        // 2. 第二个参数：回调函数，该函数会接收到新值和旧值
        (newValue, oldValue) =&gt; {
          console.log(&quot;info.name 变化了&quot;);
        }
      );
      const changeData = () =&gt; {
        info.name = &quot;kobe&quot;;
      };
      return {
        info,
        changeData,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>案例二: watch 函数监听的数据源为 reactive 函数返回的响应式对象</strong></p>
<pre><code class="language-html">&lt;script&gt;
  import { reactive, watch } from &quot;vue&quot;;
  export default {
    setup() {
      const info = reactive({
        name: &quot;why&quot;,
        age: 18,
      });
      /*
        watch(
          () =&gt; info.name,
          (newValue, oldValue) =&gt; {
            console.log(&quot;info.name 变化了&quot;);
          }
        );
      */
      // newValue 和 oldValue 都是响应式对象
      watch(info, (newValue, oldValue) =&gt; {
        console.log(&quot;info 变化了&quot;);
      });
      const changeData = () =&gt; {
        info.name = &quot;kobe&quot;;
      };
      return {
        info,
        changeData,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>这时，如果我们希望 newValue 和 oldValue 是一个普通对象，那么可以这样监听</p>
<pre><code class="language-html">&lt;script&gt;
  import { reactive, watch } from &quot;vue&quot;;
  export default {
    setup() {
      const info = reactive({
        name: &quot;why&quot;,
        age: 18,
      });
      watch(
        () =&gt; {
          return { ...info };
        },
        // 此时 newValue 和 oldValue 都是普通对象
        (newValue, oldValue) =&gt; {
          console.log(&quot;info 变化了&quot;);
        }
      );
      const changeData = () =&gt; {
        info.name = &quot;kobe&quot;;
      };
      return {
        info,
        changeData,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>案例三: watch 函数监听的数据源为 ref 函数返回的响应式对象</strong></p>
<pre><code class="language-html">&lt;script&gt;
  import { reactive, watch } from &quot;vue&quot;;
  export default {
    setup() {
      const name = ref(&quot;codeywhy&quot;);
      // newValue 和 oldValue 都是 value 值本身
      watch(name, (newValue, oldValue) =&gt; {
        console.log(&quot;name 变化了&quot;);
      });
      const changeData = () =&gt; {
        name.value = &quot;kobe&quot;;
      };
      return {
        name,
        changeData,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>监听多个数据源</h3>
<p>watch 不仅可以监听单个数据源，还可以通过接收数组实现同时监听多个数据源。</p>
<pre><code class="language-html">&lt;script&gt;
  import { ref, reactive, watch } from &quot;vue&quot;;
  export default {
    setup() {
      const info = reactive({
        name: &quot;coder&quot;,
        age: 18,
      });
      const name = ref(&quot;why&quot;);
      const age = ref(20);
      watch(
        // 1. 第一个参数：数组，数组中可以存放多个数据源
        [() =&gt; ({ ...info }), name, age],
        // 2. 第二个参数：回调函数
        ([newInfo, newName, newAge], [oldInfo, oldName, oldAge]) =&gt; {
          console.log(newInfo, newName, newAge);
          console.log(oldInfo, oldName, oldAge);
        }
      );
      const changeData = () =&gt; {
        info.name = &quot;kobe&quot;;
        name.value = &quot;jack&quot;;
      };
      return {
        info,
        name,
        changeData,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>监听响应式对象</h3>
<p>如果我们希望监听一个数组或对象，可以使用一个 getter 函数，并对可响应式对象进行解构。</p>
<pre><code class="language-js">const names = reactive([&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;]);

// 监听响应式数组
watch(
  () =&gt; [...names],
  (newValue, oldValue) =&gt; {
    console.log(newValue, oldValue);
  }
);
const changeName = () =&gt; {
  names.push(&quot;why&quot;);
};
</code></pre>
<p>如果需要对一个对象进行深度监听，可以将 deep 属性设置为 true，也可以传入 immediate 参数立即执行监听函数。</p>
<pre><code class="language-js">import { reactive, watch, ref } from &quot;vue&quot;;
export default {
  setup() {
    const info = reactive({
      name: &quot;why&quot;,
      age: 18,
      friend: {
        name: &quot;kobe&quot;,
        age: 40,
      },
    });
    // 监听响应式对象
    watch(
      () =&gt; ({ ...info }),
      (newInfo, oldInfo) =&gt; {
        console.log(newInfo, oldInfo);
      },
      {
        deep: true, // 深度监听
        immediate: true, // 立即执行监听函数
      }
    );
    const changeData = () =&gt; (info.friend.name = &quot;james&quot;);
    return {
      info,
      changeData,
    };
  },
};
</code></pre>
<h2>组件的生命周期</h2>
<p>setup 函数不但可以替代 data、methods、computed、watch 等选项，还可以替代生命周期函数(钩子)。如果想在 setup 函数中使用组件生命周期函数，那么可以通过直接导入 onXxx 函数来注册生命周期函数。</p>
<pre><code class="language-js">import { onMounted, onUnmounted, onUpdated } from &quot;vue&quot;;
export default {
  setup() {
    const counter = ref(0);
    const increment = () =&gt; {
      counter.value++;
    };
    onMounted(() =&gt; {
      console.log(&quot;组件挂载完成&quot;);
    });
    // 生命周期函数(同一个生命周期函数可以存在多次)
    onMounted(() =&gt; {
      console.log(&quot;组件挂载完成&quot;);
    });
    onUpdated(() =&gt; {
      console.log(&quot;组件更新完成&quot;);
    });
    onUnmounted(() =&gt; {
      console.log(&quot;组件卸载完成&quot;);
    });
    return {
      counter,
      increment,
    };
  },
};
</code></pre>
<p>Composition API 和 Options API(选项式 API) 的生命周期函数的对应关系:</p>
<img src="../imgs/138/01.awebp" />

<blockquote>
<p>可以看到，Composition API 没有提供 beforeCreate 和 created 生命周期函数，而是直接使用 setup 函数代替。需要注意的是，setup 函数会在 beforeCreate 之前被调用，</p>
</blockquote>
<h2>Provide / Inject 依赖注入</h2>
<p>在 Vue3 的 Composition API 中，我们可以使用 provide 和 inject 函数实现非父子组件之间的通信。</p>
<p>相比于 Options API 中的 provide 和 inject 选项，provide 和 inject 函数更加灵活和方便。</p>
<h3>提供数据</h3>
<p>provide 函数可以向子组件或孙子组件提供数据。它接收以下两个参数：</p>
<ul>
<li><p>key: 要提供的键，可以是字符串或符号 (symbol)</p>
</li>
<li><p>value: 要提供的值</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;script&gt;
  import { provide, ref } from &quot;vue&quot;;
  export default {
    setup() {
      const name = &quot;coderwhy&quot;;
      const age = 18;
      let counter = ref(100);

      // 向所有后代组件提供数据
      /**
       * 其中，提供的普通数据是只读的，不可修改；提供的响应式数据默认是可读可修改的。
       */
      provide(&quot;name&quot;, name);
      provide(&quot;age&quot;, age);
      provide(&quot;counter&quot;, counter);

      return {
        name,
        age,
        counter,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>注入数据</h3>
<p>inject 函数接收以下两个参数：</p>
<ol>
<li><p>key: 需要注入的数据的名称。</p>
</li>
<li><p>defaultValue(可选): 在没有匹配到 key 时使用的默认值。</p>
</li>
</ol>
<pre><code class="language-html">&lt;script&gt;
  import { inject } from &quot;vue&quot;;
  export default {
    setup() {
      // 获取父组件提供 provide 提供的数据
      const name = inject(&quot;name&quot;); // 普通数据，只读
      const age = inject(&quot;age&quot;); // 普通数据，只读
      const counter = inject(&quot;counter&quot;); // 响应式数据，可读可写
      const homeIncrement = () =&gt; counter.value++;
      return {
        name,
        age,
        counter,
        homeIncrement,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>提供和注入响应式数据</h3>
<p>provide 函数不仅可以向子组件或孙子组件提供只读的普通数据，还支持提供响应式数据,例如，支持提供 ref 和 reactive 函数定义的响应式数据。</p>
<ul>
<li>父组件</li>
</ul>
<pre><code class="language-js">let counter = ref(100);
let info = reactive({
  name: &quot;why&quot;,
  age: 18,
});

provide(&quot;counter&quot;, counter);
provide(&quot;info&quot;, info);
</code></pre>
<ul>
<li>子组件</li>
</ul>
<pre><code class="language-js">const info = inject(&quot;info&quot;);
const counter = inject(&quot;counter&quot;);
</code></pre>
<blockquote>
<p>注意: provide 函数提供的响应式数据既可以在父组件中被修改，又可以在子组件中被修改这会导致难以追踪数据的修改。为了保证单向数据流，以及避免子组件修改父组件提供的数据我们可以借助 readonly 函数</p>
</blockquote>
<ul>
<li>父组件</li>
</ul>
<pre><code class="language-js">provide(&quot;info&quot;, readonly(info));
provide(&quot;counter&quot;, readonly(counter));
</code></pre>
<h2><code>&lt;script setup&gt;</code> 语法</h2>
<h3>基本使用</h3>
<ul>
<li><p>在启用该语法时，需要将 setup 属性添加到 <code>&lt;script&gt;</code> 标签上。<code>&lt;script&gt;</code> 标签中的代码会被编译成组件 setup 函数的内容。</p>
</li>
<li><p><code>&lt;script&gt;</code> 中的代码只在组件被首次引入时执行一次，而 <code>&lt;script setup&gt;</code> 中的代码会在每次组件实例被创建时执行。</p>
</li>
<li><p>任何在<code>&lt;script setup&gt;</code> 中声明的顶层的绑定 (包括变量、函数声明，以及 import 引入的内容) 都能在模板中直接使用。</p>
</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;{{ counter }}&lt;/h4&gt;
    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
  import { ref } from &quot;vue&quot;;
  const counter = ref(0);
  const increment = () =&gt; {
    counter.value++;
  };
&lt;/script&gt;
</code></pre>
<p>需要注意的是，任何在 <code>&lt;script setup&gt;</code> 中声明的顶层的绑定内容都能在模板中直接使用。例如，声明的普通变量、响应式变量、函数、impont 引入的内容，包含对象、组件、动态组件、指令等，</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;MyComponent /&gt;
  &lt;component :is=&quot;Foo&quot; /&gt;
  &lt;h4 v-my-directive&gt;This is a Heading&lt;/h4&gt;
  &lt;div&gt;{{ capitalize(&quot;hello&quot;) }}&lt;/div&gt;
  &lt;button @click=&quot;count++&quot;&gt;{{ count }}&lt;/button&gt;
  &lt;div @click=&quot;log&quot;&gt;{{ msg}}&lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
  import MyComponent from &quot;./components/MyComponent.vue&quot;;
  import Foo from &quot;./components/Foo.vue&quot;;
  import { myDirective as vMyDirective } from &quot;./MyDirectives.js&quot;;
  import { capitalize } from &quot;./helpers&quot;;
  import { ref } from &quot;vue&quot;;
  const count = ref(0);
  const msg = &quot;Hello World&quot;;

  function log() {
    console.log(msg);
  }
&lt;/script&gt;
</code></pre>
<h3>defineProps 和 defineEmits</h3>
<p>而在 <code>&lt;script setup&gt;</code> 语法中，必须用 <code>defineProps</code> 和 <code>defineEmits</code> 函数来声明 props 和 emit。</p>
<ul>
<li><p><code>defneprps</code> 和 <code>defneEmits</code> 函数都是只在 <code>&lt;script setup&gt;</code> 中才能使用的编译器宏，它不需要导入且会随着 <code>&lt;script setup&gt;</code> 处理过程一同被编译。</p>
</li>
<li><p>defineProps 接收与 props 选项相同的值，defneEmits 接收与 emits 选项相同的值。</p>
</li>
<li><p>在选项传入后，defineProps 和 defineEmits 会提供恰当的类型推断。</p>
</li>
<li><p>传入 defineProps 和 defineEmits 的选项会从 setup 中提升到模块的范围内。因此，传入的选项不能引用在 setup 范围中声明的局部变量，这样做会引起编译错误。但是它可以引用导入的绑定，因为导入的绑定也在模块范围内。</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- DefinePropsEmitAPI.vue --&gt;
&lt;template&gt;
  &lt;div style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
    &lt;button @click=&quot;emitEvent&quot;&gt;发射 emit 事件&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  // 接收 props
  const props = defineProps({
    message: String,
    default: &quot;默认的 message&quot;,
  });

  // 注册需要的触发的 emit 事件
  const emit = defineEmits([&quot;increment&quot;]);

  const emitEvent = () =&gt; {
    emit(&quot;increment&quot;, 1); // 触发 increment 事件，并传递参数 1
  };
&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;app&quot; style=&quot;border: 1px solid #ddd; margin: 10px&quot;&gt;
    &lt;DefinePropsEmitAPI
      message=&quot;App 传递过来的 message&quot;
      @increment=&quot;getCounter&quot;
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
  import DefinePropsEmitAPI from &quot;./components/DefinePropsEmitAPI.vue&quot;;
  const getCounter = (counter) =&gt; {
    console.log(&quot;子组件传递过来的 counter 值：&quot;, counter);
  };
</code></pre>
<h3>defineExpose</h3>
<p>组件在使用 <code>&lt;script setup&gt;</code> 语法时默认是关闭的，即通过模板 ref 或 $parent 获取到组件的实例不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的属性。这时，如果要将组件的某些属性暴露出去，可以通过 defneExpose 编译器宏来实现</p>
<pre><code class="language-html">&lt;script setup&gt;
  import { ref } from &quot;vue&quot;;
  const age = 18;
  const name = ref(&quot;coderwhy&quot;);
  const showMessage = () =&gt; {
    console.log(&quot;hello world&quot;);
  }
  defineExpose({
    age,
    name,
    showMessage
  })
</code></pre>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;DefineExposeAPI ref=&quot;defineExposeAPI&quot; /&gt;
&lt;/template&gt;
&lt;script setup&gt;
  import { ref, wacthEffect } from &quot;vue&quot;;
  import DefineExposeAPI from &quot;./components/DefineExposeAPI.vue&quot;;
  // 1. 获取 DefineExposeAPI.vue 组件的实例和该组件暴露的属性
  const defineExposeAPI = ref(null);
  watchEffect(
    () =&gt; {
      console.log(defineExposeAPI.value);
      console.log(defineExposeAPI.value.age);
      console.log(defineExposeAPI.value.name);
      defineExposeAPI.value.showMessage();
    },
    {
      flush: &quot;post&quot;,
    }
  );
&lt;/script&gt;
</code></pre>
<h3>useSlots 和 useAttrs</h3>
<p>setup 函数主要有两个参数: props 和 context。其中，context 包含 slots、attrs 和 emit 三个属性。而在 <code>&lt;script setup&gt;</code> 中，可以分别使用 useSlots 和 useAttrs 两个辅助函数，代码如下所示:</p>
<pre><code class="language-html">&lt;script setup&gt;
  import { useSlots, useAttrs } from &quot;vue&quot;;
  const slots = useSlots(); // 1. 获取该组件的插槽，相当于 setup 函数中的 context.slots
  const attrs = useAttrs(); // 2. 获取该组件的属性，相当于 setup 函数中的 context.attrs
  console.log(slots);
  console.log(attrs);
&lt;/script&gt;
</code></pre>
<p>注意: useSlots 和 useAttrs 是真实的运行时函数，需要导入后使用。它会返回与 setupContext.slots 和 setupContext.attrs 等价的值，也能在普通的 Composition API 中使用。</p>
<p>提示: 在 <code>&lt;script setup&gt;</code> 中使用 slots 和 attrs 是很罕见的，因为在模板中可以直接使用 $slos 和$ attrs。</p>

        </article>
      </main>

      <!-- Table of Contents Sidebar -->
      <aside class="toc-sidebar">
        <div class="toc-header">
          <h3>Table of Contents</h3>
        </div>
        <div class="toc-content" id="tocContent">
          <!-- TOC will be generated dynamically -->
        </div>
      </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M12 19V5M5 12l7-7 7 7" />
      </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(
          135deg,
          var(--accent),
          rgba(59, 130, 246, 0.8)
        );
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
      @media screen and (max-width: 768px) {
        .back-to-top {
          right: 15px;
          bottom: 15px;
          width: 36px;
          height: 36px;
        }
      }

      @media screen and (max-width: 480px) {
        .back-to-top {
          right: 12px;
          bottom: 12px;
          width: 32px;
          height: 32px;
        }
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // Sidebar Toggle
      const toggleBtn = document.getElementById("toggleSidebar");
      const sidebar = document.querySelector(".sidebar");
      const mainContent = document.querySelector(".main-content");

      function toggleSidebar() {
        sidebar.classList.toggle("hidden");
        // Store sidebar state in localStorage
        localStorage.setItem(
          "sidebarHidden",
          sidebar.classList.contains("hidden")
        );
      }

      toggleBtn.addEventListener("click", toggleSidebar);

      // Keyboard shortcut (Ctrl + B)
      window.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "b") {
          e.preventDefault(); // Prevent browser's default behavior
          toggleSidebar();
        }
      });

      // Restore sidebar state from localStorage
      document.addEventListener("DOMContentLoaded", () => {
        const sidebarHidden = localStorage.getItem("sidebarHidden") === "true";
        if (sidebarHidden) {
          sidebar.classList.add("hidden");
        }
      });

      // Generate Table of Contents
      function generateTOC() {
        const article = document.querySelector(".content-body");
        const headings = article.querySelectorAll("h1, h2, h3, h4");
        const tocContent = document.getElementById("tocContent");
        const toc = document.createElement("ul");

        headings.forEach((heading, index) => {
          const id = `heading-${index}`;
          heading.id = id;

          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = `#${id}`;
          a.textContent = heading.textContent;
          a.className = `toc-level-${heading.tagName.toLowerCase()}`;

          li.appendChild(a);
          toc.appendChild(li);
        });

        tocContent.appendChild(toc);
      }

      // Initialize TOC
      document.addEventListener("DOMContentLoaded", generateTOC);

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }

      // 监听 ctrl + b
      window.addEventListener("keydown", (e) => {
        const leftDom = document.querySelector(".sidebar");
        if (e.ctrlKey && e.key === "b") {
          leftDom.classList.toggle("hidden");
        }
      });

      // Modal
      // const modal = document.getElementById("myModal");
      // const modalContent = modal.querySelector(".modal-content");
      // const openModal = document.getElementById("openModal");
      // const close = modal.querySelector(".close");

      // openModal.addEventListener("click", () => {
      //     modal.style.display = "block";
      // });

      // close.addEventListener("click", () => {
      //     modal.style.display = "none";
      // });

      // window.addEventListener("click", (e) => {
      //     if (e.target === modal) {
      //         modal.style.display = "none";
      //     }
      // });

      // Back to top button
      const backToTop = document.getElementById("backToTop");
      window.addEventListener("scroll", () => {
        if (window.scrollY > 200) {
          backToTop.style.display = "block";
        } else {
          backToTop.style.display = "none";
        }
      });

      backToTop.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      // Theme toggle
      document.addEventListener("DOMContentLoaded", () => {
        const themeToggle = document.getElementById("themeToggle");
        const html = document.documentElement;
        const prismTheme = document.getElementById("prismTheme");

        // Function to update theme and stylesheet
        function updateTheme(theme) {
          html.className = theme;
          prismTheme.href = `../css/prism${theme === "dark" ? "2" : ""}.css`;
          localStorage.setItem("theme", theme);
        }

        // Check for saved theme preference
        const savedTheme = localStorage.getItem("theme") || "light";
        updateTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const currentTheme = html.className;
          const newTheme = currentTheme === "light" ? "dark" : "light";
          updateTheme(newTheme);
        });
      });
    </script>
  </body>
</html>
