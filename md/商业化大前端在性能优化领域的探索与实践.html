<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>商业化大前端在性能优化领域的探索与实践</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link id="prismTheme" rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700b3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
  </head>

  <body class="fade-in">
    <button
      class="toggle-sidebar"
      id="toggleSidebar"
      aria-label="Toggle Sidebar"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <div class="app-container">
      <!-- Sidebar Navigation -->
      <nav class="sidebar">
        <div class="sidebar-header">
          <button class="toggle-sidebar" id="toggleSidebar">
            <span></span>
          </button>
        </div>
        <div class="sidebar-content">
          <div class="nav-section"><li class="active"><a title="商业化大前端在性能优化领域的探索与实践" href="/md/商业化大前端在性能优化领域的探索与实践.html">35 商业化大前端在性能优化领域的探索与实践</a></li><li class=""><a title="性能分析小知识 Performance.mark 创建时间戳" href="/md/性能分析小知识 Performance.mark 创建时间戳.html">34 性能分析小知识 Performance.mark 创建时间戳</a></li><li class=""><a title="百分之90前端工程师都踩过的内存泄漏陷阱" href="/md/百分之90前端工程师都踩过的内存泄漏陷阱.html">33 百分之90前端工程师都踩过的内存泄漏陷阱</a></li><li class=""><a title="什么是双键缓存？我们必须了解的浏览器缓存新规则" href="/md/什么是双键缓存？我们必须了解的浏览器缓存新规则.html">32 什么是双键缓存？我们必须了解的浏览器缓存新规则</a></li><li class=""><a title="分析组件的渲染时间" href="/md/分析组件的渲染时间.html">31 分析组件的渲染时间</a></li><li class=""><a title="Rust vs JavaScript 使用 WebAssembly 提升百分 66 的性能" href="/md/Rust vs JavaScript 使用 WebAssembly 提升百分 66 的性能.html">30 Rust vs JavaScript 使用 WebAssembly 提升百分 66 的性能</a></li><li class=""><a title="避免巨大网络负载的 10 个方法" href="/md/避免巨大网络负载的 10 个方法.html">29 避免巨大网络负载的 10 个方法</a></li><li class=""><a title="利用fetchpriority优化资源加载，提升网页性能" href="/md/利用fetchpriority优化资源加载，提升网页性能.html">28 利用fetchpriority优化资源加载，提升网页性能</a></li><li class=""><a title="一文读懂 JS 内存管理，掌握面试中 7 大内存泄漏场景" href="/md/一文读懂 JS 内存管理，掌握面试中 7 大内存泄漏场景.html">27 一文读懂 JS 内存管理，掌握面试中 7 大内存泄漏场景</a></li><li class=""><a title="首页加载速度优化" href="/md/首页加载速度优化.html">26 首页加载速度优化</a></li><li class=""><a title="前端如何实现 gzip 打包压缩" href="/md/前端如何实现 gzip 打包压缩.html">25 前端如何实现 gzip 打包压缩</a></li><li class=""><a title="性能优化思路之网络层优化" href="/md/性能优化思路之网络层优化.html">24 性能优化思路之网络层优化</a></li><li class=""><a title="你实现的前端图片预加载真的够优雅吗" href="/md/你实现的前端图片预加载真的够优雅吗.html">23 你实现的前端图片预加载真的够优雅吗</a></li><li class=""><a title="前端如何避免重排 reflow 和重绘 repaint" href="/md/前端如何避免重排 reflow 和重绘 repaint.html">22 前端如何避免重排 reflow 和重绘 repaint</a></li><li class=""><a title="页面加载流程分析技巧" href="/md/页面加载流程分析技巧.html">21 页面加载流程分析技巧</a></li><li class=""><a title="资源优先级" href="/md/资源优先级.html">20 资源优先级</a></li><li class=""><a title="聊聊图片预加载" href="/md/聊聊图片预加载.html">19 聊聊图片预加载</a></li><li class=""><a title="网站优化之静态资源优化" href="/md/网站优化之静态资源优化.html">18 网站优化之静态资源优化</a></li><li class=""><a title="看《浏览器基本原理与实践》后，36点总结" href="/md/看《浏览器基本原理与实践》后，36点总结.html">17 看《浏览器基本原理与实践》后，36点总结</a></li><li class=""><a title="渲染优化" href="/md/渲染优化.html">16 渲染优化</a></li><li class=""><a title="浏览器渲染性能分析技巧" href="/md/浏览器渲染性能分析技巧.html">15 浏览器渲染性能分析技巧</a></li><li class=""><a title="构建优化" href="/md/构建优化.html">14 构建优化</a></li><li class=""><a title="性能优化全家桶：6 个方面 9 点建议" href="/md/性能优化全家桶：6 个方面 9 点建议.html">13 性能优化全家桶：6 个方面 9 点建议</a></li><li class=""><a title="性能优化-时间分片渲染简单做法" href="/md/性能优化-时间分片渲染简单做法.html">12 性能优化-时间分片渲染简单做法</a></li><li class=""><a title="加载注意事项" href="/md/加载注意事项.html">11 加载注意事项</a></li><li class=""><a title="利用 Performance API 分析网站性能" href="/md/利用 Performance API 分析网站性能.html">10 利用 Performance API 分析网站性能</a></li><li class=""><a title="内存泄漏排查" href="/md/内存泄漏排查.html">09 内存泄漏排查</a></li><li class=""><a title="了解透彻浏览器缓存" href="/md/了解透彻浏览器缓存.html">08 了解透彻浏览器缓存</a></li><li class=""><a title="书写高性能的代码" href="/md/书写高性能的代码.html">07 书写高性能的代码</a></li><li class=""><a title="Performance 面板分析性能瓶颈全流程" href="/md/Performance 面板分析性能瓶颈全流程.html">06 Performance 面板分析性能瓶颈全流程</a></li><li class=""><a title="API 技巧" href="/md/API 技巧.html">05 API 技巧</a></li><li class=""><a title="速通 JS 性能优化" href="/md/速通 JS 性能优化.html">04 速通 JS 性能优化</a></li><li class=""><a title="网页太慢了怎么排查" href="/md/网页太慢了怎么排查.html">03 网页太慢了怎么排查</a></li><li class=""><a title="浅谈前端性能优化之评估工具" href="/md/浅谈前端性能优化之评估工具.html">02 浅谈前端性能优化之评估工具</a></li><li class=""><a title="前端如何优化资源加载" href="/md/前端如何优化资源加载.html">01 前端如何优化资源加载</a></li></div>
        </div>
      </nav>

      <!-- Main Content Area -->
      <main class="main-content">
        <header class="content-header">
          <div class="header-left">
            <h1 class="page-title">商业化大前端在性能优化领域的探索与实践</h1>
            <p class="time">HaoTian · 2025-02-05 14:22:53</p>
          </div>
          <div class="header-right">
            <div class="tag-container">
              <span class="tag">性能优化</span>
            </div>
            <button
              id="themeToggle"
              class="theme-toggle"
              aria-label="Toggle theme"
            >
              <svg
                class="sun-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
              <svg
                class="moon-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
            </button>
            <button
              class="theme-toggle"
              aria-label="Toggle theme"
              style="width: 36px; height: 36px"
              onclick="window.location.href='/md';"
            >
              <svg
                t="1737442501710"
                class="icon"
                viewBox="0 0 1024 1024"
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
                p-id="5258"
                width="20"
                height="20"
              >
                <path
                  d="M883.773793 626.047476c-17.308201 0-31.408337 14.029528-31.408337 31.304983l0 207.437469c0 17.204847-14.098089 31.302937-31.406291 31.302937L203.040834 896.092865c-17.340947 0-31.408337-14.098089-31.408337-31.302937L171.632497 657.352459c0-17.275455-14.099113-31.304983-31.408337-31.304983-17.380856 0-31.444153 14.029528-31.444153 31.304983l0 207.437469c0 51.773154 42.261523 93.91188 94.260827 93.91188l617.918331 0c52.031027 0 94.259804-42.139749 94.259804-93.91188L915.21897 657.352459C915.21897 640.077004 901.152603 626.047476 883.773793 626.047476L883.773793 626.047476zM230.262826 614.286618c55.523571 0 104.556311-27.674293 134.394896-69.762877 32.487925 46.451962 86.303598 77.0744 147.343813 77.0744 61.036122 0 114.846678-30.623461 147.306974-77.0744 29.943986 42.018999 78.902024 69.762877 134.426619 69.762877 90.948385 0 164.968216-73.77526 164.968216-164.371628 0-11.062963-2.342348-22.859637-5.130857-35.178197-0.209778-1.134847 0.031722-2.26867-0.277316-3.38612l-0.629333-2.267647c-0.24764-0.924045-0.140193-1.535983-0.352017-2.547009-0.138146-0.505513-0.521886-0.87288-0.695848-1.39579l-85.364203-316.671313c-3.699252-13.645788-16.051581-23.172769-30.293957-23.172769L187.965487 65.296145c-14.238282 0-26.665313 9.526981-30.360472 23.24133L72.309374 405.1566c-0.103354 0.50756-0.48607 0.820692-0.62524 1.309832-0.210801 0.942465-0.107447 1.639337-0.349971 2.511193l-0.62524 2.373047c-0.318248 1.11745 0 2.25025-0.210801 3.38612-2.863211 12.31856-5.201465 24.115234-5.201465 35.178197C65.295634 540.511357 139.315464 614.286618 230.262826 614.286618L230.262826 614.286618z"
                  fill="currentColor"
                  p-id="5259"
                ></path>
              </svg>
            </button>
          </div>
        </header>

        <!-- Article Content -->
        <article
          class="content-body md md "
        >
          <blockquote>
<p>在业务飞速发展的过程中，用户体验是必不可少的一个环节，而页面性能是直接影响用户体验的重要因素。当页面加载时间过长、交互操作不流畅时，意味着业务可能会出现转化率降低、用户流失等业务问题。在过去一年，为了确保用户在使用快手商业化产品时能获得流畅、快捷和满意的体验，快手商业化大前端团队立项「商业化端架构性能治理专项」，针对 12 个核心项目累计 30+ 核心页面进行性能优化治理。</p>
</blockquote>
<h2>一. 背景介绍</h2>
<h3>1.1 页面性能优化的价值与意义</h3>
<p>在业务迅猛发展的时代，用户体验已成为企业成功的关键因素之一，而页面性能则是塑造用户体验的核心要素。早在十多年前，亚马逊就已经意识到页面加载速度对商业成果的深远影响：亚马逊支付页面每增加 100 毫秒的延迟，可能减少 1% 有效转化。页面加载时间的延长和交互操作的不流畅性，不仅会损害用户体验，还可能导致转化率下降和用户流失等后果。</p>
<p>在快手商业化团队，我们深知页面性能对提升用户体验的重要性。因此，我们基于快手内部动态化技术的特点，并参考了 Google 的性能标准，制定了快手商业化页面性能达标的北极星指标（如下）</p>
<img src="../imgs/141/12.webp" />

<h3>1.2 核心页面性能现状</h3>
<p>在实际的商业化业务场景中，尽管端侧页面繁多，但流量却高度集中于少数核心系统与页面之上。因此，从 ROI 的角度出发，<strong>我们采取了页面分级治理策略，将优化资源聚焦于核心页面</strong> 。我们界定核心页面依据两大关键要素：一是它们直接面向外部用户，位于广告投放的核心路径之中；二是依据页面访问量（PV 数）的统计结果。</p>
<p>遵循这些原则，我们挑选出了 12 个流量较大且处于广告投放核心路径的快手商业化核心系统，涵盖了广告投放、广告落地页等核心业务流程，并进一步从中筛选出超过 30+ 核心页面作为优化的重点对象。那么，这些承载着巨大流量的核心页面，其性能表现究竟如何呢？</p>
<img src="../imgs/141/13.webp" />

<p>我们借助雷达平台（快手内部的性能监控平台），对各核心页面的性能数据进行了全面且细致的整理与分析，包括静态资源、接口等维度，并得出以下结论：</p>
<ul>
<li>仅有 18.42%的页面即 7 个页面达到了“性能优秀”的基线标准，且其中有 4 个页面只是略优于基线标准。有 15 个页面其性能被判定为“较差”。</li>
<li>在 C 端系统中，主要性能瓶颈在于静态资源加载耗时过长，约 47.36%页面静态资源耗时超过 1500ms，约 65.78%页面的静态资源耗时超过 1000ms。这意味着用户在访问这些页面时，需要等待较长时间来加载页面内容，这无疑会严重影响用户体验。</li>
<li>而在 B 端系统中，主要性能瓶颈在于接口耗时过长，约 31.57%页面的接口请求耗时超过 2500ms，约 21.05%页面的请求接口耗时占比超过 60%。这对于 B 端系统的操作效率构成了严峻挑战，也直接影响了广告投放等核心业务流程的顺畅进行。</li>
</ul>
<h3>1.3 核心性能问题分析</h3>
<p>基于上述性能现状的深入分析，我们明确了当前面临的核心性能问题主要归为两大类：一是静态资源加载和渲染耗时过长，二是接口请求耗时较长。针对这两大类核心性能问题，我们需要进一步细化问题原因，制定针对性的优化策略，并付诸实施。</p>
<p><strong>1.3.1 静态资源加载和渲染耗时过长</strong></p>
<img src="../imgs/141/14.webp" />

<p>为了进一步下钻分析「静态资源」相关的性能问题，我们通过破晓平台（快手内部的性能诊断平台）对上述各核心页面进行性能评测，发现这些核心项目普遍存在较多显而易见的问题。我们对这些问题进行了归类，主要有以下 4 个方面：</p>
<ul>
<li><strong>HTTP/2 覆盖率较低：</strong> 所有项目均存在使用 HTTP/1.1 的情况，作为对比，HTTP/2 能显著提高页面加载性能、减少延迟、提高带宽利用效率等；</li>
<li><strong>图片资源优化空间大：</strong> 绝大部分项目直接引用原始图片的 CDN 链接，没有对图片做任何处理；</li>
<li><strong>页面渲染结构较复杂：</strong> 以广告投放平台为首的核心业务的页面首屏渲染结构非常复杂；</li>
<li><strong>脚本资源较大：</strong> 脚本资源请求体积较大，JS 覆盖率较低，脚本解析时长占高，影响资源加载时长和渲染时长</li>
</ul>
<p><strong>1.3.2 接口请求耗时较长</strong></p>
<p>众所周知，B 端系统往往逻辑非常复杂，尤其是像商业化的广告投放平台这样逻辑复杂且规模庞大的系统，涉及的接口数量众多，管理起来极具挑战性。为此我们对核心页面加载链路上的相关接口进行了细致的梳理和分析。在梳理过程中，我们重点关注了 4 个 B 端系统中的 14 个核心页面，这些页面是用户访问频率高、业务逻辑复杂的关键区域。通过监测和分析，我们发现这些页面中累计存在 30 个接口性能表现不佳。</p>
<h2>二. 面临的挑战</h2>
<p>在深入了解快手商业化内部性能现状及问题的基础上，我们意识到在推进性能治理的过程中，仍需克服以下三方面的挑战：</p>
<p><strong>挑战一：统一推进各核心系统治理的难度较高</strong></p>
<p>性能优化治理是一项复杂且长期的工作，尤其是在页面较多、项目发展阶段不一、技术栈差异化的情况下。商业化端侧性能治理专项涉及 12 个项目 30+页面，涉及页面流量大，且项目间发展阶段不同，导致性能问题的根源也各不相同，统一推进治理的难度较高，若任由业务方自行优化则重复劳动较多，同时难以形成可复制、可推广的最佳实践。<strong>为了解决这一问题，我们需要建立一套性能治理机制，既要针对性地解决端侧性能问题，也要在项目推进中引入性能优化卡口，防止性能问题后期劣化。</strong></p>
<p><strong>挑战二：B 端业务核心链路体验度量模型缺失</strong></p>
<p>快手商业化的 B 端业务主要集中在广告投放、企业服务、内容变现、电商合作等领域，主要服务于广告主、代理商、品牌等，帮助他们在平台上实现品牌曝光、用户转化和销售增长。B 端业务交互逻辑重，用户停留时间长，操作次数多，除了关注页面加载阶段的性能以外，还需要关注业务核心链路的操作体验。目前，快手商业化缺乏 B 端体验度量模型，难以评估广告投放系统的用户体验。因此，<strong>我们亟需建立 B 端业务核心链路体验度量模型，以评估用户使用商业化 B 端核心系统的流畅度，并基于数据洞察问题，不断改进 B 端核心系统的用户体验。</strong></p>
<p><strong>挑战三：C 端业务 Web 和 Native 结合不够深入</strong></p>
<p>在现代的互联网应用中，Web 端和 Native 端的界限日益模糊。用户的使用场景不再局限于某一特定平台，而 Web 与 Native 端的紧密结合可以有效提升产品开发效率、用户体验和资源共享度。由于早期业务开发周期紧急、动态化技术栈熟悉度不足等原因，商业化端内项目采用 Web 技术栈的比例较高，与 Native 侧结合不够深入。这导致了一些页面未能充分利用端上优化手段，如离线包、预建连、预请求等。为了应对多变的业务环境和技术挑战，<strong>我们需要借助「大前端」的组织优势，打破技术壁垒，搭建统一、高效且灵活的大前端技术体系。</strong></p>
<h2>三. 治理思路与落地实践</h2>
<p>基于上述的背景现状分析，我们进一步制定了治理思路，核心能力包括以下三个方面：</p>
<ul>
<li><p><strong>性能评估模型和防劣化机制：</strong></p>
<p>建立系统化的性能评估模型，评估性能健康度，发掘并解决端侧在性能维度的潜在问题，提升用户体验；同时，建立性能防劣化机制，使性能问题能够有效的收敛在产品上线发布前</p>
</li>
<li><p><strong>B 端核心链路体验度量模型：</strong></p>
<p>建立以「操作卡顿率」和「任务达成率」为核心指标的 B 端链路体验度量模型，从而评估用户使用商业化 B 端系统的流畅度，并基于数据洞察问题，不断改进商业化 B 端系统的平台体验</p>
</li>
<li><p><strong>C 端 Web 和 Native 紧密结合：</strong>
搭建端内页面的技术选型标准，推动端内项目接入已有的端上能力&amp;进行动态化改造，同时，持续探索 Web&amp;Native 紧密结合的可能性，进一步输出体系化的方案，从而提升端内动态化页面的流量占比</p>
</li>
</ul>
<p>下面我们进一步拆解上述三大核心建设方向下的关键技术实现方案：</p>
<h3>3.1 性能评估模型和防劣化机制</h3>
<p>为了系统化地提升和维护页面性能，我们构建了一套「事前-事中-事后」的性能评估模型和防劣化机制。</p>
<img src="../imgs/141/15.webp" />

<p><strong>（1）事前-数据置信</strong></p>
<ul>
<li><p><strong>问题：</strong> 在快手内部，性能上报依赖主动打点，难以保证数据准确性，易发生数据打点时机和用户体感差距较大的可能性；</p>
</li>
<li><p><strong>解法：</strong> 落地数据置信方案计算 FMP 误差率（Web 页面对比浏览器内核计算的 LCP，动态化页面对比动态化内核计算的 FMP），对于差值 &gt; 20%的页面进行上报点位校准</p>
</li>
</ul>
<p><strong>（2）事中-推进治理</strong></p>
<ul>
<li><p><strong>问题：</strong> 性能优化治理涉及页面较多，且项目间发展阶段不同，影响性能背后的问题差异较大，统一推进治理难度较高，但如果放任业务方各自优化则重复工作较多，探索最佳实践的难度较大；</p>
</li>
<li><p><strong>解法：</strong> 利用破晓平台（快手内部的性能评测平台）对页面进行性能评测，得出当前核心页面存在的核心问题；以评测结果为指引，针对性地梳理出 8 项核心优化策略和治理最佳实践，并推进各核心页面治理；</p>
</li>
</ul>
<p><strong>（3）事后-防劣化</strong></p>
<ul>
<li><p><strong>问题：</strong> 随着项目持续迭代，存在性能持续劣化的可能性，难以毕其功于一役；</p>
</li>
<li><p><strong>解法：</strong> 基于「事中-推进治理」的各项策略，定义明确可度量的准出规则，推进在治理完成后加入性能卡口，防止性能劣化；</p>
</li>
</ul>
<p><strong>3.1.1 事前-数据置信</strong></p>
<p>快手内部目前性能上报依赖主动打点，这种方式虽有较好的灵活性，但一线开发同学较难感知上报时机是否准确，且随着业务的迭代，难以保证上报逻辑是否会被更改。因此，需要针对 FMP/T3 上报点位进行数据置信。</p>
<img src="../imgs/141/16.webp" />

<p>如上图所示，FMP/T3 数据置信过程主要包括三个核心步骤：</p>
<ul>
<li>首先，根据页面类型选择基准值，Web 页面采用 Google 提出的 LCP 作为基准，而动态化页面则使用动态化内核自动计算的 FMP 作为基准；</li>
<li>其次，通过录屏方式记录页面加载过程中的关键性能指标，并截取关键帧以便一线开发团队了解上报 FMP 时的页面状态；</li>
<li>最后，结合关键帧图片识别对比基准值与上报点的误差比例来计算 FMP 误差率，对于误差率超过 20%的页面，会提出检查上报时机的建议。这一 20%的阈值是基于快手内部 2023 年对核心前端项目的校验结果得出。</li>
</ul>
<img src="../imgs/141/17.webp" />

<p>如上图所示是当前 FMP 置信能力的效果图，FMP 置信能力的实现仅是起点，更重要的是产品化能力的落地。如下方的时序图所示，我们在破晓平台（快手内部的性能评测平台）实现 FMP 置信的产品化能力：</p>
<ul>
<li>依托 openAPI 与雷达平台（快手内部的性能监控平台）无缝对接，预获取项目信息、高流量页面 URL 等，同时开放业务方手动录入；</li>
<li>为确保登录便捷，实现自动登录服务，兼容快手内网 SSO、快手 Web 及 App 等多种登录方式；</li>
<li>通过定时巡检机制，每日收集页面性能数据，定期向部门、项目组或单项业务进行推送数据，提升各角色对重点项目置信现状的洞察力。</li>
</ul>
<img src="../imgs/141/18.webp" />

<p><strong>3.1.2 事中-推进治理</strong></p>
<p>如下图所示，我们以破晓平台的评测结果为指引，针对性地梳理出 8 项核心优化策略和治理最佳实践。在此，我们选取在静态资源、网络请求等维度下具有代表性的治理策略展开讲述。</p>
<img src="../imgs/141/19.webp" />

<p><strong>（1）静态资源优化：图片资源、脚本打包优化等</strong></p>
<p><strong>图片资源优化：</strong></p>
<p>图片资源的优化成为提升网站性能的关键一环，我们采用兼容性较好的 WebP 格式。与传统的 JPG 和 PNG 格式相比，WebP 通常能提供更小的文件体积，从而加快网页加载速度并节省带宽。同时，快手的 CDN 服务支持自动将 PNG、JPG 等格式的图片资源转换为 WebP 格式。以下面的图片为例，将 PNG 图片转换为 WebP 可以减少 80+%的体积：</p>
<img src="../imgs/141/20.webp" />

<p>同时，我们还针对性地提供了一个功能全面的图片处理库，支持以下特性：</p>
<ul>
<li>支持 JPG、PNG、WebP、GIF 等多种图片格式的转换，具备图片裁剪、缩放、模糊、背景色设置等功能</li>
<li>能处理域名收敛问题，支持特定 CDN 域名和全局 CDN 域名的传入</li>
<li>能根据端内网络环境智能加载不同质量的图片，并根据设备像素比自动调整图片裁剪尺寸，确保图片资源的高效利用和优质显示
‍‍‍</li>
</ul>
<p>尽管 WebP 已经表现出色，但随着技术的不断进步，更高效的图片格式如 HEIF 和 AVIF 相继出现。HEIF 使用 HEVC 的帧内编码技术，具有 HEVC 帧内编码工具集，达到了更高的压缩率、更好的画质。AVIF 则是基于 AV1 视频编解码器的图片格式，在高压缩比和较高的视觉质量方面比 WebP 和 HEIF 更优。然而，这些新格式在兼容性方面仍存在挑战，尤其是与老旧设备和浏览器的兼容性问题，限制了它们的广泛应用。目前，快手 APP 已经支持 HEIF 格式，端内的图片库也增加了相关参数以支持这一格式。此外，快手还自主研发了 KVIF 格式，比 AVIF 和 HEIF 更优。</p>
<img src="../imgs/141/21.webp" />

<img src="../imgs/141/22.webp" />

<p><strong>脚本资源打包优化：</strong></p>
<p>快手商业化前端针对前期各自独立的研发工具和方案带来的维护成本高、低效协作等问题，在 23 年进行了前端工程方案的整合升级，统一将数百个前端工程迁移至 Kmi（快手商业化的前端工程化解决方案）。从工程角度来看，统一迁移 Kmi 不仅提升开发效率和降低维护成本，同时还保证了灵活性和可扩展性，为性能优化提供了便利的先发优势。Kmi 提供了三种 Code Splitting 策略，以适应不同的项目需求：</p>
<ul>
<li><p>bigVendors：将 async chunk 里的 node_modules 的文件打包到一起，避免重复，但容易导致单文件尺寸过大，无缓存效率可言；</p>
</li>
<li><p>depPerChunk：和 bigVendors 类似，将依赖按 package name + version 进行拆分，解决 bigVendors 的尺寸和缓存效率问题，但请求较多；</p>
</li>
<li><p>granularChunks：在 bigVendors 和 depPerChunk 之间取了中间值，同时又能在缓存效率上有更好的利用。</p>
</li>
</ul>
<img src="../imgs/141/23.webp" />

<p>在默认使用 granularChunks 策略的基础上，Kmi 针对各核心项目定制化打包优化，以最大化提升商业化前端应用的性能和用户体验。此外，Kmi 在每次构建后自动生成详细报告，帮助团队深入了解每次构建过程中的关键差异，为代码质量和构建速度的持续优化提供数据支持，也为排查问题提供了快速还原现场的能力。</p>
<img src="../imgs/141/24.webp" />

<p><strong>（2）网络请求优化：HTTP/2+域名收敛、数据预请求等</strong></p>
<p><strong>升级 HTTP/2+域名收敛</strong></p>
<p>为了提升性能，我们针对仍在使用 HTTP/1.1 的商业核心项目域名（包括业务域名、CDN 域名、埋点域名等）进行了 HTTP/2 升级。HTTP/2 的多路复用特性允许在同一 TCP 连接上并行交换多重请求-响应消息，从而克服了 HTTP/1.1 中同一域名下请求数量受限的问题。</p>
<img src="../imgs/141/25.webp" />

<p>在升级 HTTP/2 的同时，我们还建议业务收敛域名，将资源集中到更少的域名下，以减少 TCP 连接数和优化 DNS 查询。此外，我们针对端内场景配置了预建连，提前建立与目标域名的 TCP 连接和 TLS 握手，进一步减少延迟，提升首次请求的响应速度。</p>
<p><strong>数据预请求</strong></p>
<p>如下图所示，常规页面流程可简化为「HTML/Bundle 加载解析 -&gt; 页面资源加载解析 -&gt;数据 API 请求 -&gt; 页面渲染」4 个过程，数据预请求的核心思路是最大限度提前页面数据加载时机，提前获取当前或未来需要的数据，以便用户在访问时能够更快地体验到完整的内容。</p>
<img src="../imgs/141/26.webp" />

<p>我们的数据预请求方案结合 KMI 实现了发起预请求、消费预请求、日志上报和缓存机制等主要功能。通过工程配置，用户可以在解析时立即发起预请求并缓存结果，随后通过插件暴露的适配器对预请求结果进行消费。同时，我们在关键节点上报自定义事件，收集预请求 API 信息以完善日志能力。缓存机制避免重复请求同一数据，进一步加速了页面加载速度。</p>
<img src="../imgs/141/27.webp" />

<p>在推进接入过程中，为了适配各接入方的使用场景，我们在请求时机、底层请求库兼容、日志能力完善、业务定制化需求的问题中不断优化进行了 40+次的迭代，功能不断提升。目前该方案在 B 端各核心项目中发挥了较大的作用，单项目 FMP 平均减少 600ms+。上述方案主要针对 web 项目，端内项目则主要是使用客户端在端内提供的预请求方案，可见下方的【结合客户端能力】这一章节。</p>
<p><strong>3.1.3 事后-防劣化</strong></p>
<img src="../imgs/141/28.webp" />

<p>如上面的时序图所示，主要结合天穹平台（快手内部的前端代码审查平台）实现性能维度的天穹平台插件，在前端研发流程上建立性能防劣化机制，具备性能维度下的任务打标、流程阻断、豁免审批、结果触达等性能卡口能力。目前已为快手商业化端侧核心项目加入卡口，一期选取 5 项 web 指标、7 项动态化指标作为卡口规则，规则详见下表：</p>
<img src="../imgs/141/29.webp" />

<h3>3.2 B 端核心链路体验度量模型</h3>
<img src="../imgs/141/30.webp" />

<p>为了更好地监控 B 端系统的用户操作体验和流程完成情况，我们建设以【操作卡顿率】和【任务达成率】为核心指标的 B 端核心链路体验度量模型。其中操作卡顿率关注核心路径的操作响应体验，任务达成率则关注核心任务流程的完成情况。</p>
<p><strong>3.2.1 操作卡顿率：核心路径的操作响应体验</strong></p>
<p>操作卡顿率是衡量用户操作体验的核心指标，它反映了用户在执行操作时等待时间超出预设阈值的占比情况。该指标通过对比卡顿操作数与有效操作数来计算得出，直观展现了用户在不同使用场景下可能遭遇的延迟问题。其中，有效操作数记录了用户每次成功执行的操作，而卡顿操作数则统计因等待时间超出阈值而引发的卡顿事件。</p>
<p>在操作卡顿率的核心思路中，我们为核心链路上的主要操作设定了明确的响应阈值，一旦超出此阈值，即视为一次卡顿。针对 B 端用户多样化的操作场景，我们进一步细化了操作场景，并制定了相应的细分指标和阈值，以确保评估的准确性和针对性。</p>
<img src="../imgs/141/31.webp" />

<p>基于这些通用规则，我们为不同 B 端核心业务平台在不同场景下的操作卡顿设定了合理的阈值，并设计通用的卡顿率数据上报 SDK，以便业务轻松接入各自平台，降低接入成本。在快手商业化前端团队的 B 端体验度量模型中，操作卡顿率占据举足轻重的地位：</p>
<ul>
<li><p>卡顿率能够客观、准确地反映用户体验的流畅度，不会跟产品形态强耦合，也不会因业务需求的迭代而产生大幅波动；</p>
</li>
<li><p>作为一个全局性的性能指标，卡顿率与前端和后端的优化工作紧密相连，后端接口的优化和前端页面的提升都能直接反映在卡顿率的改善上，这充分体现了技术优化的价值，并帮助团队清晰评估技术优化的成果，最终助力提升用户的交互体验。</p>
</li>
</ul>
<p><strong>3.2.2 任务达成率：核心任务流程的完成情况</strong></p>
<p>任务达成率是衡量用户成功完成任务或达成目标的比例，其计算基于提交成功数（经过访问 ID 去重处理）与页面开始加载数的比值。这一指标深受前端静态资源可用性、后端接口服务稳定性以及用户个体差异等多重因素的影响。</p>
<img src="../imgs/141/32.webp" />

<p>以商业化广告投放平台的创编流程（即创建广告的过程）为例，用户在进行广告创建时，会经历一系列有序的步骤。具体包括：</p>
<ul>
<li>页面到达成功率：衡量从用户开始访问页面到主 JS 执行完毕，再到页面加载完成的整个过程的成功率</li>
<li>提交转化率：关注用户在填写完广告属性后点击提交按钮的转化率</li>
<li>提交成功率：记录提交操作成功的情况，并通过访问 ID 进行细致区分，以确保统计的准确性</li>
</ul>
<p>为了分析任务达成率的异常现象，我们还会收集一系列技术指标进行监控。当任务达成率的细分指标出现异常波动时，这些技术指标将作为关键的诊断工具，帮助我们定位问题的根源。具体的技术归因指标包括但不限于：</p>
<img src="../imgs/141/33.webp" />

<h3>3.3 C 端 Web 和 Native 紧密结合</h3>
<p>在移动端互联网时代无论是 H5 还是动态化页面，与客户端的紧密结合是性能优化的关键路径。这主要包括两个核心方面：一是充分利用和结合已有的客户端能力，以提升页面加载速度；二是实施端侧页面的动态化改造，利用动态化的优势进一步提升性能表现。</p>
<h3><strong>3.3.1 结合已有的客户端能力</strong></h3>
<p>针对 H5 页面，常见的优化手段包括预加载、预建连、离线包、code cache 等，而对于 KRN 页面，则采用包预置、业务包预加载、code cache、预请求等策略。</p>
<img src="../imgs/141/34.webp" />

<img src="../imgs/141/35.webp" />

<p>这些优化手段可能有着不同的名称，但其核心理念相通的。在快手内部，Yoda 和 KDS 两个端侧基础团队提供了性能优化 SOP。基于这些 SOP，我们梳理出一系列适合商业化的优化手段，并推动了核心端内页面的接入工作。实践证明，这些端侧的优化方案取得了显著的效果。在接入后，端内单项目的 FMP 时间平均减少 500ms+。</p>
<p><strong>3.3.2 端侧页面动态化改造</strong></p>
<p>对于 web 技术栈而言，由于浏览器底层架构设计、JS 的解析和执行效率等原因，在渲染性能和交互流畅度上很难突破浏览器限制。相较而言，采用类 RN 技术栈开发的页面由于核心渲染层 &amp; 组件基于原生实现，整体性能体验能够提升一个台阶，且付出的开发效率/发版效率代价相对而言较小。</p>
<p>举个例子，快手商业化大前端团队以磁力建站落地页作为试点，完成动态化改造后的性能收益提升 35%以上，性能提升也带来了显著的业务 CVR 和预期消耗增长。因此，如下图所示，我们搭建了一套端内页面的技术选型标准，完善动态化技术基建，持续推动端内项目完成动态化改造。</p>
<img src="../imgs/141/36.webp" />

<p>值得一提的是，在探索 Web 和 Native 紧密结合过程中，我们也在思考一套渐进式增强方案。以商业化磁力金牛和粉条为例，这两个项目主要流量在端内，且有很强的 B 端属性，历史包袱较重。经过与业务同学共同评估，贸然地切换至动态化技术栈的成本较高。因此，我们希望能在保留原有 Web 开发模式的同时，进一步提供性能极佳的富交互组件来创建 Hybrid 应用，让这些 Web 应用具有媲美 Native 的用户体验。</p>
<img src="../imgs/141/37.webp" />

<img src="../imgs/141/38.webp" />

<p>如上图所示，以磁力金牛和粉条的多 Tab 场景为例，我们的思路是基于 Native 实现多 Tab 容器，用于承载复杂的多 Tab 页面结构。主要能力如下：</p>
<ul>
<li><strong>容器能力：</strong> 提供 RN、TK、webview 等渲染容器，并提供定制化的容器能力，如资源预加载、数据预请求、容器预热等方案</li>
<li><strong>配置化能力：</strong> 支持自定义底部导航栏、底部 Tab、骨架屏等配置化能力</li>
<li><strong>框架交互能力：</strong> 支持容器间数据共享&amp;通信，可切换 tab，控制元素展现等</li>
</ul>
<h2>四. 阶段性成果</h2>
<p>经过一系列的努力与优化，我们取得了显著的阶段性成果：</p>
<ul>
<li><p>北极星达标情况：<strong>性能优秀达标率提升 61.63%，性能良好达标率提升 41.95%</strong>，这充分表明我们的性能优化策略正在逐步显现成效。</p>
</li>
<li><p>B/C 端 FMP 月均值整体呈逐月下降趋势，核心页面的整体性能（P90 分位）提升 43.23%</p>
</li>
<li><p>B 端业务：B 端核心页面整体性能提升 45.74%，核心广告投放平台的卡顿率指标均降低至 20%以下</p>
</li>
<li><p>C 端业务：C 端核心页面整体性能提升 42.12%，C 端核心页面的触达率提升 10.16pp，C 端核心页面的秒开率提升 31.62pp</p>
</li>
</ul>
<img src="../imgs/141/39.webp" />

<p>综上所述，无论是从北极星指标的提升，还是从 B/C 端 FMP 月均值的下降，再到 B 端卡顿率和 C 端触达率&amp;秒开率等指标的提升，都充分证明了我们的努力是值得的。</p>
<h2>五.总结与展望</h2>
<p>本篇文章主要基于大前端视角，解决不同领域场景下的页面性能问题。展望未来，我们将继续把性能体验作为重点关注领域，打造标准化、平台化的性能优化领域体系建设，推动商业化大前端页面性能水平达到业界领先，以确保商业化用户在使用我们的产品时获得流畅、快捷和满意的体验，从而推动业务的持续增长和发展。</p>

        </article>
      </main>

      <!-- Table of Contents Sidebar -->
      <aside class="toc-sidebar">
        <div class="toc-header">
          <h3>Table of Contents</h3>
        </div>
        <div class="toc-content" id="tocContent">
          <!-- TOC will be generated dynamically -->
        </div>
      </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M12 19V5M5 12l7-7 7 7" />
      </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(
          135deg,
          var(--accent),
          rgba(59, 130, 246, 0.8)
        );
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
      @media screen and (max-width: 768px) {
        .back-to-top {
          right: 15px;
          bottom: 15px;
          width: 36px;
          height: 36px;
        }
      }

      @media screen and (max-width: 480px) {
        .back-to-top {
          right: 12px;
          bottom: 12px;
          width: 32px;
          height: 32px;
        }
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // Sidebar Toggle
      const toggleBtn = document.getElementById("toggleSidebar");
      const sidebar = document.querySelector(".sidebar");
      const mainContent = document.querySelector(".main-content");

      function toggleSidebar() {
        sidebar.classList.toggle("hidden");
        // Store sidebar state in localStorage
        localStorage.setItem(
          "sidebarHidden",
          sidebar.classList.contains("hidden")
        );
      }

      toggleBtn.addEventListener("click", toggleSidebar);

      // Keyboard shortcut (Ctrl + B)
      window.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "b") {
          e.preventDefault(); // Prevent browser's default behavior
          toggleSidebar();
        }
      });

      // Restore sidebar state from localStorage
      document.addEventListener("DOMContentLoaded", () => {
        const sidebarHidden = localStorage.getItem("sidebarHidden") === "true";
        if (sidebarHidden) {
          sidebar.classList.add("hidden");
        }
      });

      // Generate Table of Contents
      function generateTOC() {
        const article = document.querySelector(".content-body");
        const headings = article.querySelectorAll("h1, h2, h3, h4");
        const tocContent = document.getElementById("tocContent");
        const toc = document.createElement("ul");

        headings.forEach((heading, index) => {
          const id = `heading-${index}`;
          heading.id = id;

          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = `#${id}`;
          a.textContent = heading.textContent;
          a.className = `toc-level-${heading.tagName.toLowerCase()}`;

          li.appendChild(a);
          toc.appendChild(li);
        });

        tocContent.appendChild(toc);
      }

      // Initialize TOC
      document.addEventListener("DOMContentLoaded", generateTOC);

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }

      // 监听 ctrl + b
      window.addEventListener("keydown", (e) => {
        const leftDom = document.querySelector(".sidebar");
        if (e.ctrlKey && e.key === "b") {
          leftDom.classList.toggle("hidden");
        }
      });

      // Modal
      // const modal = document.getElementById("myModal");
      // const modalContent = modal.querySelector(".modal-content");
      // const openModal = document.getElementById("openModal");
      // const close = modal.querySelector(".close");

      // openModal.addEventListener("click", () => {
      //     modal.style.display = "block";
      // });

      // close.addEventListener("click", () => {
      //     modal.style.display = "none";
      // });

      // window.addEventListener("click", (e) => {
      //     if (e.target === modal) {
      //         modal.style.display = "none";
      //     }
      // });

      // Back to top button
      const backToTop = document.getElementById("backToTop");
      window.addEventListener("scroll", () => {
        if (window.scrollY > 200) {
          backToTop.style.display = "block";
        } else {
          backToTop.style.display = "none";
        }
      });

      backToTop.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      // Theme toggle
      document.addEventListener("DOMContentLoaded", () => {
        const themeToggle = document.getElementById("themeToggle");
        const html = document.documentElement;
        const prismTheme = document.getElementById("prismTheme");

        // Function to update theme and stylesheet
        function updateTheme(theme) {
          html.className = theme;
          prismTheme.href = `../css/prism${theme === "dark" ? "2" : ""}.css`;
          localStorage.setItem("theme", theme);
        }

        // Check for saved theme preference
        const savedTheme = localStorage.getItem("theme") || "light";
        updateTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const currentTheme = html.className;
          const newTheme = currentTheme === "light" ? "dark" : "light";
          updateTheme(newTheme);
        });
      });
    </script>
  </body>
</html>
