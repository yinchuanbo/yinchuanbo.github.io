<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>pnpm 的崛起：如何降维打击 npm 和 yarn</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    
    <link rel="stylesheet" href="../css/prism.css" />
    
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700B3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
</head>

<body class="fade-in">
    <button class="toggle-sidebar" id="toggleSidebar" aria-label="Toggle Sidebar">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
    
    <div class="app-container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <button class="toggle-sidebar" id="toggleSidebar">
                    <span></span>
                </button>
            </div>
            <div class="sidebar-content">
                <div class="nav-section">
                    <li class="active"><a title="pnpm 的崛起：如何降维打击 npm 和 yarn" href="/md/pnpm 的崛起：如何降维打击 npm 和 yarn.html">02 pnpm 的崛起：如何降维打击 npm 和 yarn</a></li><li class=""><a title="Rspack 与 Rolldown 下一代前端打包工具的巅峰对决" href="/md/Rspack 与 Rolldown 下一代前端打包工具的巅峰对决.html">01 Rspack 与 Rolldown 下一代前端打包工具的巅峰对决</a></li>
                </div>
            </div>
        </nav>

        <!-- Main Content Area -->
        <main class="main-content">
            <header class="content-header">
                <div class="header-left">
                    <h1 class="page-title">pnpm 的崛起：如何降维打击 npm 和 yarn</h1>
                    <p class="time">HaoTian · 2025-01-19 19:03:21</p>
                </div>
                <div class="header-right">
                    <div class="tag-container">
                        <span class="tag">打包工具</span>
                    </div>
                </div>
            </header>

            <!-- Article Content -->
            <article class="content-body md md ">
                <h2>npm2</h2>
<p>在 npm 3.0 版本之前，项目的 <code>node_modules</code> 会呈现出嵌套结构，也就是说，我安装的依赖、依赖的依赖、依赖的依赖的依赖...，都是递归嵌套的</p>
<pre><code class="language-sh">node_modules
    ├─ express
    │  ├─ index.js
    │  ├─ package.json
    │  └─ node_modules
    │     ├─ accepts
    │     │  ├─ index.js
    │     │  ├─ package.json
    │     │  └─ node_modules
    │     │     ├─ mime-types
    |     |     |   └─ node_modules
    |     |     |      └─ mime-db
    |     │     └─ negotiator
    │     ├─ array-flatten
    │ 		├─ ...
    │  		└─ ...
    └─ A
       ├─ index.js
       ├─ package.json
       └─ node_modules
          └─ accepts
             ├─ index.js
             ├─ package.json
             └─ node_modules
                ├─ mime-types
                |   └─ node_modules
                |      └─ mime-db
                └─ negotiator
</code></pre>
<h3>设计缺陷</h3>
<p>这种嵌套依赖树的设计确实存在几个严重的问题</p>
<ol>
<li><strong>「路径过长问题：」</strong> 由于包的嵌套结构 ， <code>node_modules</code> 的目录结构可能会变得非常深，甚至可能会超出系统路径长度上限 ，毕竟 windows 系统的文件路径默认最多支持 256 个字符</li>
<li><strong>「磁盘空间浪费：」</strong> 多个包之间难免会有公共的依赖，公共依赖会被多次安装在不同的包目录下，导致磁盘空间被大量浪费 。比如上面 <code>express</code> 和 A 都依赖了 <code>accepts</code>，它就被安装了两次</li>
<li><strong>「安装速度慢」</strong>：由于依赖包之间的嵌套结构，<code>npm</code> 在安装包时需要多次处理和下载相同的包，导致安装速度变慢，尤其是在依赖关系复杂的项目中</li>
</ol>
<p>当时 npm 还没解决这些问题， 社区便推出了新的解决方案 ，就是 yarn。它引入了一种新的依赖管理方式——<strong>「扁平化依赖。」</strong></p>
<p>看到 yarn 的成功，npm 在 3.0 版本中也引入了类似的扁平化依赖结构</p>
<h2>yarn</h2>
<p><strong>「yarn 的主要改进之一就是通过扁平化依赖结构来解决嵌套依赖树的问题」</strong></p>
<p>具体来说铺平，yarn 尽量将所有依赖包安装在项目的顶层 <code>node_modules</code> 目录下，而不是嵌套在各自的 <code>node_modules</code> 目录中。</p>
<p>这样一来，减少了目录的深度，避免了路径过长的问题 ，也尽可能避免了依赖被多次重复安装的问题</p>
<img src="../imgs/138/27.webp" />

<p>我们可以在 yarn-example 看到整个目录，全部铺平在了顶层 <code>node_modules</code> 目录下，展开下面的包大部分是没有二层 <code>node_modules</code> 的</p>
<p>然而，有些依赖包还是会在自己的目录下有一个 <code>node_modules</code> 文件夹，出现嵌套的情况，例如 yarn-example 下的<code>http-errors</code> 依赖包就有自己的 <code>node_modules</code>，原因是：</p>
<p>当一个项目的多个依赖包需要同一个库的不同版本时，<strong>「yarn 只能将一个版本的库提升到顶层」</strong> <strong>「<code>node_modules</code>」</strong> <strong>「目录中。」</strong> 对于需要 <strong>「这个库其他版本」</strong> 的依赖，yarn 仍然需要在这些依赖包的目录下创建一个嵌套的 <code>node_modules</code> 来存放不同版本的包</p>
<p>比如，包 A 依赖于 <code>lodash@4.0.0</code>，而包 B 依赖于 <code>lodash@3.0.0</code>。由于这两个版本的 <code>lodash</code> 不能合并，<code>yarn</code> 会将 <code>lodash@4.0.0</code> 提升到顶层 <code>node_modules</code>，而 <code>lodash@3.0.0</code> 则被嵌套在包 B 的 <code>node_modules</code> 目录下。</p>
<h3>幽灵依赖</h3>
<p><strong>「虽然 yarn 和 npm 都采用了扁平化的方案来解决依赖嵌套的问题，但这种方案本身也有一些缺陷，其中幽灵依赖是一个主要问题。」</strong></p>
<p>幽灵依赖，也就是你明明没有在 <code>package.json</code> 文件中声明的依赖项，但在项目代码里却可以 <code>require</code> 进来 这个也很容易理解，因为依赖的依赖被扁平化安装在顶层 <code>node_modules</code> 中，所以我们能访问到依赖的依赖</p>
<p>但是这样是有隐患的，因为没有显式依赖，未来某个时候这些包可能会因为某些原因消失（例如新版本库不再引用这个包了，然后我们更新了库），就会引发代码运行错误</p>
<h3>浪费磁盘空间</h3>
<p><strong>「而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题」</strong></p>
<p>那社区有没有解决这俩问题的思路呢？pnpm 就是其中最成功的一个</p>
<h2>pnpm</h2>
<p>pnpm 通过 <strong>「全局存储和符号链接机制」</strong> 从根源上解决了依赖重复安装和路径长度问题，同时也避免了扁平化依赖结构带来的幽灵依赖问题 pnpm 的优势概括来说就是“快、准、狠”：</p>
<ul>
<li>快：安装速度快</li>
<li>准：安装过的依赖会准确复用缓存，甚至包版本升级带来的变化都只 diff，绝不浪费一点空间</li>
<li>狠：直接废掉了幽灵依赖</li>
</ul>
<p>执行 <code>npm add express</code>，我们可以在 pnpm-example 看到整个目录，由于只安装了 <code>express</code>，那 <code>node_modules</code> 下就只有 <code>express</code></p>
<img src="../imgs/138/28.webp" />

<p>那么所有的（次级）依赖去哪了呢？binggo，在<code>node_modules/.pnpm/</code>目录下，<code>.pnpm/</code> 以平铺的形式储存着所有的包</p>
<img src="../imgs/138/29.webp" />

<h3>三层寻址</h3>
<p>所有 npm 包都安装在全局目录 <code>~/.pnpm-store/v3/files</code> 下，同一版本的包仅存储一份内容，甚至不同版本的包也仅存储 diff 内容。</p>
<p>顶层 <code>node_modules</code> 下有 <code>.pnpm</code> 目录以打平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。</p>
<p>每个项目 <code>node_modules</code> 下安装的包以软链接方式将内容指向 <code>node_modules/.pnpm</code> 中的包。所以每个包的寻找都要经过三层结构：<code>node_modules/package-a</code> &gt; 软链接 <code>node_modules/.pnpm/package-a@1.0.0/node_modules/package-a</code> &gt; 硬链接 <code>~/.pnpm-store/v3/files/00/xxxxxx</code>。</p>
<p>这就是 pnpm 的实现原理。官方给了一张原理图，可以搭配食用</p>
<img src="../imgs/138/30.webp" />

<p>前面说过，npm 包都被安装在全局 <code>pnpm store</code> ，默认情况下，会创建多个存储（每个驱动器（盘符）一个），并在项目所在盘符的根目录</p>
<p>所以，同一个盘符下的不同项目，都可以共用同一个全局 <code>pnpm store</code>，绝绝子啊 👏，大大节省了磁盘空间，提高了安装速度</p>
<img src="../imgs/138/31.webp" />

<h3>软硬链接</h3>
<p>也就是说，所有的依赖都是从全局 store 硬连接到了 <code>node_modules/.pnpm</code> 下，然后之间通过软链接来相互依赖。</p>
<p>那么，这里的软连接、硬链接到底是什么东西？</p>
<p>硬链接是指向磁盘上原始文件所在的同一位置 （直接指向相同的数据块）</p>
<p>软连接可以理解为新建一个文件，它包含一个指向另一个文件或目录的路径 （指向目标路径）</p>
<img src="../imgs/138/32.webp" />

<h2>总结</h2>
<p><strong>「npm2 的嵌套结构」</strong>：每个依赖项都会有自己的 <code>node_modules</code> 目录，导致了依赖被重复安装，严重浪费了磁盘空间 💣；在依赖层级比较深的项目中，甚至会超出 windows 系统的文件路径长度 💣</p>
<p><strong>「npm3+ 和 Yarn 的扁平化策略：」</strong> 尽量将所有依赖包安装在项目的顶层 <code>node_modules</code> 目录下，解决了 <code>npm2</code> 嵌套依赖的问题。但是该方案有一个重大缺陷就是“幽灵依赖”💣；而且依赖包有多个版本时，只会提升一个，那其余版本依然会被重复安装，还是有浪费磁盘空间的问题 💣</p>
<p><strong>「pnpm 全局存储和符号链接机制：」</strong> 结合软硬链和三层寻址，解决了依赖被重复安装的问题，更加变态的是，同一盘符下的不同项目都可以共用一个全局 <code>pnpm store</code>。节省了磁盘空间，并且根本不存在“幽灵依赖”，安装速度还贼快 💪💪💪</p>

            </article>
        </main>

        <!-- Table of Contents Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-header">
                <h3>Table of Contents</h3>
            </div>
            <div class="toc-content" id="tocContent">
                <!-- TOC will be generated dynamically -->
            </div>
        </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>
    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
        // Sidebar Toggle
        const toggleBtn = document.getElementById('toggleSidebar');
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');
        
        function toggleSidebar() {
            sidebar.classList.toggle('hidden');
            // Store sidebar state in localStorage
            localStorage.setItem('sidebarHidden', sidebar.classList.contains('hidden'));
        }
        
        toggleBtn.addEventListener('click', toggleSidebar);

        // Keyboard shortcut (Ctrl + B)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'b') {
                e.preventDefault(); // Prevent browser's default behavior
                toggleSidebar();
            }
        });

        // Restore sidebar state from localStorage
        document.addEventListener('DOMContentLoaded', () => {
            const sidebarHidden = localStorage.getItem('sidebarHidden') === 'true';
            if (sidebarHidden) {
                sidebar.classList.add('hidden');
            }
        });

        // Generate Table of Contents
        function generateTOC() {
            const article = document.querySelector('.content-body');
            const headings = article.querySelectorAll('h1, h2, h3, h4');
            const tocContent = document.getElementById('tocContent');
            const toc = document.createElement('ul');

            headings.forEach((heading, index) => {
                const id = `heading-${index}`;
                heading.id = id;
                
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${id}`;
                a.textContent = heading.textContent;
                a.className = `toc-level-${heading.tagName.toLowerCase()}`;
                
                li.appendChild(a);
                toc.appendChild(li);
            });

            tocContent.appendChild(toc);
        }

        // Initialize TOC
        document.addEventListener('DOMContentLoaded', generateTOC);

        // Image zoom with FLIP animation
        const overlay = document.querySelector(".zoom-overlay");
        let activeImage = null;

        document.querySelectorAll("img").forEach((img) => {
            if (img.closest("a")) return; // Skip images that are inside links
            img.style.cursor = "zoom-in";
            img.addEventListener("click", handleImageClick);
        });

        function handleImageClick(event) {
            const img = event.target;

            if (activeImage) {
                // If an image is already zoomed, unzoom it
                unzoomImage();
                return;
            }

            // Get the initial position and size
            const rect = img.getBoundingClientRect();
            const first = {
                x: rect.left,
                y: rect.top,
                width: rect.width,
                height: rect.height,
            };

            // Create a clone of the image
            const clone = img.cloneNode();
            clone.classList.add("zoomed-image");
            document.body.appendChild(clone);

            // Position the clone exactly over the original
            clone.style.position = "fixed";
            clone.style.left = `${first.x}px`;
            clone.style.top = `${first.y}px`;
            clone.style.width = `${first.width}px`;
            clone.style.height = `${first.height}px`;
            clone.style.margin = "0";
            clone.style.transformOrigin = "top left";

            // Show the overlay
            overlay.style.display = "block";

            // Calculate the final position and scale
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
            const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
            const scaleX = targetWidth / first.width;
            const scaleY = targetHeight / first.height;
            const scale = Math.min(scaleX, scaleY);

            const last = {
                width: first.width * scale,
                height: first.height * scale,
            };
            last.x = (viewportWidth - last.width) / 2;
            last.y = (viewportHeight - last.height) / 2;

            // Calculate and apply the transform
            const dx = last.x - first.x;
            const dy = last.y - first.y;

            requestAnimationFrame(() => {
                clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
                clone.style.transition = "transform 0.3s ease-out";
            });

            activeImage = { original: img, clone: clone };

            // Add click handlers for closing
            clone.addEventListener("click", unzoomImage);
            overlay.addEventListener("click", unzoomImage);
        }

        function unzoomImage() {
            if (!activeImage) return;

            const { original, clone } = activeImage;
            const rect = original.getBoundingClientRect();

            // Animate back to the original position
            clone.style.transform = `translate(0, 0) scale(1)`;

            // Clean up after the animation
            clone.addEventListener(
                "transitionend",
                () => {
                    clone.remove();
                    overlay.style.display = "none";
                },
                { once: true }
            );

            activeImage = null;
        }

        // 监听 ctrl + b
        window.addEventListener("keydown", (e) => {
            const leftDom = document.querySelector(".sidebar");
            if (e.ctrlKey && e.key === "b") {
                leftDom.classList.toggle("hidden");
            }
        });

        // Modal
        const modal = document.getElementById("myModal");
        const modalContent = modal.querySelector(".modal-content");
        const openModal = document.getElementById("openModal");
        const close = modal.querySelector(".close");

        openModal.addEventListener("click", () => {
            modal.style.display = "block";
        });

        close.addEventListener("click", () => {
            modal.style.display = "none";
        });

        window.addEventListener("click", (e) => {
            if (e.target === modal) {
                modal.style.display = "none";
            }
        });
    </script>
</body>
</html>
