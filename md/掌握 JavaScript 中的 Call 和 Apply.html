<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>掌握 JavaScript 中的 Call 和 Apply</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>
  <body class="line-numbers">
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left">
          <ul>
            <li class=""><a title="高精度实现定时器" href="/md/高精度实现定时器.html">高精度实现定时器</a></li><li class=""><a title="高效检查 JS 对象中的键是否存在" href="/md/高效检查 JS 对象中的键是否存在.html">高效检查 JS 对象中的键是否存在</a></li><li class=""><a title="非常强大的标准 JavaScript API - AbortController" href="/md/非常强大的标准 JavaScript API - AbortController.html">非常强大的标准 JavaScript API - AbortController</a></li><li class=""><a title="谈谈前端路由的实现原理 hash ＆ history" href="/md/谈谈前端路由的实现原理 hash ＆ history.html">谈谈前端路由的实现原理 hash ＆ history</a></li><li class=""><a title="获取上传进度的几种方式" href="/md/获取上传进度的几种方式.html">获取上传进度的几种方式</a></li><li class=""><a title="聊聊禁止页面滚动的几种方法" href="/md/聊聊禁止页面滚动的几种方法.html">聊聊禁止页面滚动的几种方法</a></li><li class=""><a title="缓存 http 错误，避免多次报错提示" href="/md/缓存 http 错误，避免多次报错提示.html">缓存 http 错误，避免多次报错提示</a></li><li class=""><a title="文件操作" href="/md/文件操作.html">文件操作</a></li><li class=""><a title="数据类型判断方法" href="/md/数据类型判断方法.html">数据类型判断方法</a></li><li class="active"><a title="掌握 JavaScript 中的 Call 和 Apply" href="/md/掌握 JavaScript 中的 Call 和 Apply.html">掌握 JavaScript 中的 Call 和 Apply</a></li><li class=""><a title="属性的 getter 和 setter" href="/md/属性的 getter 和 setter.html">属性的 getter 和 setter</a></li><li class=""><a title="实现鼠标滚轮缩放 SVG 内容" href="/md/实现鼠标滚轮缩放 SVG 内容.html">实现鼠标滚轮缩放 SVG 内容</a></li><li class=""><a title="实现基于用户操作系统偏好的明暗主题切换" href="/md/实现基于用户操作系统偏好的明暗主题切换.html">实现基于用户操作系统偏好的明暗主题切换</a></li><li class=""><a title="宏任务和微任务" href="/md/宏任务和微任务.html">宏任务和微任务</a></li><li class=""><a title="十个超级好用的 Js 技巧" href="/md/十个超级好用的 Js 技巧.html">十个超级好用的 Js 技巧</a></li><li class=""><a title="前端的网络状态" href="/md/前端的网络状态.html">前端的网络状态</a></li><li class=""><a title="使用 JS 向现有 SVG 中添加元素" href="/md/使用 JS 向现有 SVG 中添加元素.html">使用 JS 向现有 SVG 中添加元素</a></li><li class=""><a title="使用 JavaScript 加载字体" href="/md/使用 JavaScript 加载字体.html">使用 JavaScript 加载字体</a></li><li class=""><a title="你需要知道的 Symbols" href="/md/你需要知道的 Symbols.html">你需要知道的 Symbols</a></li><li class=""><a title="一文整懂事件对象 event 的常用方法" href="/md/一文整懂事件对象 event 的常用方法.html">一文整懂事件对象 event 的常用方法</a></li><li class=""><a title="Set 和 WeakSet 的用法和区别" href="/md/Set 和 WeakSet 的用法和区别.html">Set 和 WeakSet 的用法和区别</a></li><li class=""><a title="sessionStorage 能在多个标签页之间共享数据吗" href="/md/sessionStorage 能在多个标签页之间共享数据吗.html">sessionStorage 能在多个标签页之间共享数据吗</a></li><li class=""><a title="scrollIntoview" href="/md/scrollIntoview.html">scrollIntoview</a></li><li class=""><a title="reduce 的高级用法" href="/md/reduce 的高级用法.html">reduce 的高级用法</a></li><li class=""><a title="js 小众且好用的技巧" href="/md/js 小众且好用的技巧.html">js 小众且好用的技巧</a></li><li class=""><a title="js 如何监听一个变量改变" href="/md/js 如何监听一个变量改变.html">js 如何监听一个变量改变</a></li><li class=""><a title="JS 单行代码集" href="/md/JS 单行代码集.html">JS 单行代码集</a></li><li class=""><a title="javascript 奇葩行为大赏" href="/md/javascript 奇葩行为大赏.html">javascript 奇葩行为大赏</a></li><li class=""><a title="JavaScript 原生实现图片复制与粘贴" href="/md/JavaScript 原生实现图片复制与粘贴.html">JavaScript 原生实现图片复制与粘贴</a></li><li class=""><a title="JavaScript 中设置器和获取器" href="/md/JavaScript 中设置器和获取器.html">JavaScript 中设置器和获取器</a></li><li class=""><a title="FileReader" href="/md/FileReader.html">FileReader</a></li><li class=""><a title="EventSource" href="/md/EventSource.html">EventSource</a></li><li class=""><a title="ES14 中 5 个最具变革性的 JavaScript 特性" href="/md/ES14 中 5 个最具变革性的 JavaScript 特性.html">ES14 中 5 个最具变革性的 JavaScript 特性</a></li><li class=""><a title="document.referrer 拦截问题" href="/md/document.referrer 拦截问题.html">document.referrer 拦截问题</a></li><li class=""><a title="7 种开发人员都应该知道的高级 JavaScript 技术" href="/md/7 种开发人员都应该知道的高级 JavaScript 技术.html">7 种开发人员都应该知道的高级 JavaScript 技术</a></li><li class=""><a title="7 种位运算符的神奇用法" href="/md/7 种位运算符的神奇用法.html">7 种位运算符的神奇用法</a></li><li class=""><a title="7 个 Promise 静态方法" href="/md/7 个 Promise 静态方法.html">7 个 Promise 静态方法</a></li>
          </ul>
        </div>
        <div
          class="layout__main_right md "
        >
          <h1>掌握 JavaScript 中的 Call 和 Apply</h1>
          <p>在学习 JavaScript 时，你可能会遇到 call 和 apply 这两个方法。它们的作用其实很相似，都是用来调用函数并设置函数内部的 this 值，但它们的使用方式稍有不同。</p>
<p>想象一下，你和朋友们一起拍照。call 就像是你一一叫朋友们的名字，让他们各自摆好姿势然后拍照，而 apply 则像是你一次性告诉大家一个姿势，让所有人一起摆好再拍照。虽然最终目的是一样的，但方式有些差别。</p>
<h2>Function.prototype.call()</h2>
<p><code>call</code>方法接受的第一个参数是要作为<code>this</code>值的对象，其余参数是传递给函数的参数。语法如下：</p>
<pre><code class="language-js">function.call(thisArg, arg1, arg2, …)
</code></pre>
<p>假设你正在开发一个线上购物网站，用户可以在不同商品上添加评论。你有一个函数<code>addComment</code>，它会打印出用户的名字和评论内容：</p>
<pre><code class="language-js">function addComment(comment) {
  console.log(`${this.username} commented: ${comment}`);
}

const user = { username: &quot;Alice&quot; };
addComment.call(user, &quot;This is a great product!&quot;); // 输出：Alice commented: This is a great product!
</code></pre>
<p>在这个例子中，我们用<code>call</code>方法调用<code>addComment</code>函数，并将<code>user</code>对象作为<code>this</code>的值。附加参数<code>&#39;This is a great product!&#39;</code>作为评论内容传递给<code>addComment</code>函数。</p>
<h2>Function.prototype.apply()</h2>
<p><code>apply</code>方法与<code>call</code>类似，但它接受一个数组（或类数组对象）作为第二个参数，数组中包含的是要传递给函数的参数。语法如下：</p>
<pre><code class="language-js">function.apply(thisArg, [argsArray])
</code></pre>
<p>假设你正在开发一个线上购物网站，用户可以在不同商品上添加评论。你有一个函数<code>addComment</code>，它会打印出用户的名字和评论内容：</p>
<pre><code class="language-js">function addComment(rating, comment) {
  console.log(
    `${this.username} rated: ${rating} stars and commented: ${comment}`
  );
}

const user = { username: &quot;Alice&quot; };
addComment.apply(user, [5, &quot;This is a fantastic product!&quot;]); // 输出：Alice rated: 5 stars and commented: This is a fantastic product!
</code></pre>
<p>在这个例子中，我们用<code>apply</code>方法调用<code>addComment</code>函数，并将<code>user</code>对象作为<code>this</code>的值。附加参数数组<code>[5, &#39;This is a fantastic product!&#39;]</code>分别作为评分和评论内容传递给<code>addComment</code>函数。</p>
<h2>何时使用 call 和 apply</h2>
<p>在 JavaScript 中，<code>call</code>和<code>apply</code>方法都能调用函数并设置函数内部的<code>this</code>值。那么，什么时候该用<code>call</code>，什么时候该用<code>apply</code>呢？让我们通过生活中的比喻来理解它们的不同之处。</p>
<h3>选择 call 的情况</h3>
<p>想象你在组织一个聚会，需要邀请几位朋友。你直接给每个朋友打电话，告诉他们聚会的时间和地点。这种方式就像<code>call</code>方法，你逐个传递参数，而不用准备额外的东西。</p>
<pre><code class="language-js">function inviteFriend(time, place) {
  console.log(
    `${this.name}, you are invited to the party at ${place} on ${time}.`
  );
}

const friend = { name: &quot;Alice&quot; };
inviteFriend.call(friend, &quot;7 PM&quot;, &quot;Central Park&quot;); // 输出：Alice, you are invited to the party at Central Park on 7 PM.
</code></pre>
<p>在这个例子中，我们用<code>call</code>方法直接传递了时间和地点两个参数，就像逐个打电话通知朋友一样。</p>
<h3>选择<code>apply</code>的情况</h3>
<p>现在，想象你要邀请一群朋友，你准备了一份邀请函，把所有信息都写在上面，然后把邀请函发给每个人。这就像<code>apply</code>方法，你准备了一个包含所有参数的数组，一次性传递给函数。</p>
<pre><code class="language-js">function addNumbers() {
  const numbers = Array.from(arguments);
  return numbers.reduce((sum, num) =&gt; sum + num, 0);
}

const sum = addNumbers.apply(null, [1, 2, 3, 4, 5]); // 输出：15
</code></pre>
<p>在这个例子中，我们用<code>apply</code>方法传递了一个包含所有数字的数组，就像发出一份邀请函，让所有人一起收到。</p>
<p>总的来说，选择 call 还是 apply，主要取决于你如何传递参数。如果参数是分开的，使用 call；如果参数已经在一个数组中，使用 apply。</p>
<h2>性能考虑</h2>
<p>虽然在大多数情况下，<code>call</code>和<code>apply</code>的性能差异可以忽略不计，但在传递大量参数时，<code>call</code>稍微有一些优势。因为使用<code>apply</code>时，JavaScript 引擎需要将参数转换成类数组对象，这会引入一些开销，而<code>call</code>则直接传递参数，没有这个额外步骤。</p>
<p>然而，要记住在编程中过早优化通常是不可取的。除非你正在处理一个性能关键的应用程序，并且已经确定函数调用是瓶颈，否则<code>call</code>和<code>apply</code>之间的性能差异不太可能成为重大问题。</p>
<h2>应用实例</h2>
<h3>1、借用方法</h3>
<p>在编写 JavaScript 代码时，有时候你会遇到需要在不同对象之间复用方法的情况。这时，<code>call</code>和<code>apply</code>方法可以派上用场。它们允许你在不同的上下文中重用现有方法，而不需要继承或编写复杂的代码。</p>
<p><strong>使用 call 的例子</strong></p>
<p>假设你有一个类数组对象<code>arrayLike</code>，但它没有内置的数组方法。我们可以通过<code>call</code>方法从<code>Array.prototype</code>借用<code>slice</code>方法：</p>
<pre><code class="language-js">const arrayLike = { 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 };
const letters = Array.prototype.slice.call(arrayLike, 1);
console.log(letters); // 输出：[&#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>在这个例子中，我们用<code>call</code>方法调用了<code>Array.prototype.slice</code>方法，并将<code>arrayLike</code>作为<code>this</code>的值。这使我们可以像对待数组一样对待<code>arrayLike</code>对象，并使用<code>slice</code>方法创建一个新数组，其中包含它的一部分元素。</p>
<p>想象你在厨房里做饭，你有一把非常好用的厨师刀（<code>slice</code>方法），但你的朋友只有一把普通的水果刀（<code>arrayLike</code>对象）。你把你的厨师刀借给朋友，让他也能享受切菜的便利。这就像是用<code>call</code>方法借用数组的方法来处理类数组对象。</p>
<p><strong>使用 apply 的例子</strong></p>
<p>同样的，我们也可以用<code>apply</code>方法来实现类似的功能，假设我们需要传递一个参数数组：</p>
<pre><code class="language-js">const max = Math.max.apply(null, [1, 2, 3, 4, 5]);
console.log(max); // 输出：5
</code></pre>
<p>在这个例子中，我们用<code>apply</code>方法调用了<code>Math.max</code>，并传递了一个数字数组。这里我们不需要设置<code>this</code>的特定值，所以传递了<code>null</code>。</p>
<h3>2、使用 apply 展开数组</h3>
<p>在 JavaScript 中，展开嵌套数组是一个常见的需求。虽然可以使用<code>concat</code>方法来实现，但这需要将每个嵌套数组作为单独的参数传递。这时，<code>apply</code>方法就非常有用了。为了更好地理解，我们来打个比方。</p>
<p>想象你有几个装满礼物的小盒子（嵌套数组），而你想把所有礼物放到一个大盒子里（展平成一个数组）。通常情况下，你需要一个一个地把小盒子里的礼物取出来，放到大盒子里。这就像用<code>concat</code>方法，需要逐个传递每个小盒子。</p>
<p>而使用<code>apply</code>方法，就像你有一个助手，他可以一口气把所有小盒子里的礼物都倒进大盒子里。这样不仅省时省力，还避免了逐个处理的麻烦。</p>
<pre><code class="language-js">const nestedArray = [1, 2, [3, 4], [5, 6]];
const flattenedArray = [].concat.apply([], nestedArray);
console.log(flattenedArray); // 输出：[1, 2, 3, 4, 5, 6]
</code></pre>
<p>在这个例子中，我们用<code>apply</code>方法调用了<code>concat</code>方法，将一个空数组<code>[]</code>作为<code>this</code>值，并传递<code>nestedArray</code>作为参数。这样，<code>nestedArray</code>中的所有元素，包括子数组中的元素，都被展开并连接到空数组中，最终形成一个平铺的数组。</p>
<p>通过这种方式，你可以轻松地将嵌套数组展开为一个单一的数组，就像让助手一次性处理所有小盒子里的礼物一样，不仅简化了代码，还提高了效率。这种方法在处理复杂数据结构时非常有用，也让你的代码更简洁、更易读。</p>
<h3>3、用 call 和 apply 创建可复用的函数装饰器</h3>
<p>在 JavaScript 中，<code>call</code>和<code>apply</code>不仅可以用来调用函数，还可以用来创建可复用的函数装饰器。函数装饰器是一种高级函数，它可以修改其他函数的行为。为了让你更容易理解，我们用一个日常生活中的比喻来说明。</p>
<p>想象一下，你在准备礼物（原始函数），但为了让礼物看起来更特别，你决定先给它们包装一下（装饰器）。这个包装过程就是装饰器在做的事情。你可以选择在礼物外面加一层精美的包装纸，然后再递给朋友。包装纸不仅让礼物更有吸引力，还增加了额外的惊喜。这就是装饰器为函数所做的事情——它们在函数执行前后添加额外的行为。</p>
<p>下面是一个使用<code>apply</code>创建函数装饰器的例子，它会在执行原始函数之前，先打印出传递给函数的参数：</p>
<pre><code class="language-js">function logArgs(func) {
  return function () {
    console.log(&quot;Arguments:&quot;, arguments);
    return func.apply(this, arguments);
  };
}

function multiply(a, b) {
  return a * b;
}

const loggedMultiply = logArgs(multiply);
console.log(loggedMultiply(3, 4)); // 输出：Arguments: [3, 4], 12
</code></pre>
<ul>
<li><strong>原始礼物（原始函数）：</strong><code>multiply</code>函数，它只是简单地将两个数字相乘。</li>
<li><strong>包装纸（装饰器）：</strong><code>logArgs</code>函数，它在执行原始函数之前先打印出所有的参数，就像在礼物上先包上一层漂亮的纸。</li>
<li><strong>打包后的礼物（装饰后的函数）：</strong><code>loggedMultiply</code>函数，它不仅完成了乘法运算，还在此之前打印了传递的参数，就像朋友收到礼物时，看到包装纸后更期待里面的内容。</li>
</ul>
<p>通过这种方式，你可以为任何函数添加额外的功能，而不需要修改原始函数本身。这就像为礼物包上精美的包装纸一样，使得原本普通的礼物变得更加特别和有趣。<code>call</code>和<code>apply</code>在这里扮演着将装饰器与原始函数结合的角色，让你可以灵活地在不同的场合下为函数添加不同的“包装”。</p>
<h2>结束</h2>
<p>在日常开发中，如果你有固定数量的参数，或者需要逐个处理参数，<code>call</code>通常是更直接的选择。而当你需要传递数组或类数组对象作为参数时，<code>apply</code>则更为方便。</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // const leftBorder = document.querySelector(".left__border");
      // const resizer = document.querySelector(".layout__main_left");
      // const resizable = document.querySelector(".layout__main_right");
      // leftBorder.addEventListener("mousedown", initResize);
      // function initResize(e) {
      //   e.preventDefault();
      //   document.addEventListener("mousemove", startResizing);
      //   document.addEventListener("mouseup", stopResizing);
      // }
      // function startResizing(e) {
      //   const resizerRect = resizer.getBoundingClientRect();
      //   const resizableRect = resizable.getBoundingClientRect();
      //   let newWidth = e.clientX - resizerRect.left;
      //   if (newWidth < 300) {
      //     newWidth = 300;
      //   } else if (newWidth > 850) {
      //     newWidth = 850;
      //   }
      //   resizer.style.width = `${newWidth}px`;
      // }
      // function stopResizing() {
      //   document.removeEventListener("mousemove", startResizing);
      //   document.removeEventListener("mouseup", stopResizing);
      // }
      const liActive = document.querySelector(".layout__main_left li.active");
      liActive.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest",
      });
      const imgs = document.querySelectorAll("img");
      imgs.forEach((img) => {
        img.onclick = () => {
          let imgHove = document.querySelector(".img-hover");
          if (imgHove) imgHove.remove();
          const src = img.src;
          const html = `
            <div class="img-hover">
              <img src="${src}" />
            </div>
          `;
          document.body.insertAdjacentHTML("beforeend", html);
          document.body.style.overflow = "hidden";
          imgHove = document.querySelector(".img-hover");
          imgHove.onclick = () => {
            imgHove.remove();
            document.body.style.overflow = "initial";
          };
        };
      });
    </script>
  </body>
</html>
