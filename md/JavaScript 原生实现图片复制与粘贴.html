<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>JavaScript 原生实现图片复制与粘贴</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    
    <link rel="stylesheet" href="../css/prism.css" />
    
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700B3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
</head>

<body class="fade-in">
    <button class="toggle-sidebar" id="toggleSidebar" aria-label="Toggle Sidebar">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
    
    <div class="app-container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <button class="toggle-sidebar" id="toggleSidebar">
                    <span></span>
                </button>
            </div>
            <div class="sidebar-content">
                <div class="nav-section">
                    <li class=""><a title="15个 JavaScript 代码规范" href="/md/15个 JavaScript 代码规范.html">60 15个 JavaScript 代码规范</a></li><li class=""><a title="8个 JavaScript 错误处理技巧 Bug 减少百分之 75" href="/md/8个 JavaScript 错误处理技巧 Bug 减少百分之 75.html">59 8个 JavaScript 错误处理技巧 Bug 减少百分之 75</a></li><li class=""><a title="WebWorker、SharedWorker 和 ServiceWorker 还在傻傻分不清" href="/md/WebWorker、SharedWorker 和 ServiceWorker 还在傻傻分不清.html">58 WebWorker、SharedWorker 和 ServiceWorker 还在傻傻分不清</a></li><li class=""><a title="用 JavaScript 实现 Live2D 虚拟人口型同步" href="/md/用 JavaScript 实现 Live2D 虚拟人口型同步.html">57 用 JavaScript 实现 Live2D 虚拟人口型同步</a></li><li class=""><a title="ES6 中引入的 new.target 你知道吗" href="/md/ES6 中引入的 new.target 你知道吗.html">56 ES6 中引入的 new.target 你知道吗</a></li><li class=""><a title="ES 新特性全解密" href="/md/ES 新特性全解密.html">55 ES 新特性全解密</a></li><li class=""><a title="前端 reduce 函数100 种使用方法整理" href="/md/前端 reduce 函数100 种使用方法整理.html">54 前端 reduce 函数100 种使用方法整理</a></li><li class=""><a title="proxy 和 Object.defineProperty()" href="/md/proxy 和 Object.defineProperty().html">53 proxy 和 Object.defineProperty()</a></li><li class=""><a title="为何说 AbortController 是前端一把利剑" href="/md/为何说 AbortController 是前端一把利剑.html">52 为何说 AbortController 是前端一把利剑</a></li><li class=""><a title="前端 Money 类" href="/md/前端 Money 类.html">51 前端 Money 类</a></li><li class=""><a title="理解JS里的WeakMap" href="/md/理解JS里的WeakMap.html">50 理解JS里的WeakMap</a></li><li class=""><a title="token无感刷新的基本实现" href="/md/token无感刷新的基本实现.html">49 token无感刷新的基本实现</a></li><li class=""><a title="前端中的 File 和 Blob两个对象到底有什么不同" href="/md/前端中的 File 和 Blob两个对象到底有什么不同.html">48 前端中的 File 和 Blob两个对象到底有什么不同</a></li><li class=""><a title="js 检测网页空闲状态(一定时间内无操作)" href="/md/js 检测网页空闲状态(一定时间内无操作).html">47 js 检测网页空闲状态(一定时间内无操作)</a></li><li class=""><a title="Javascirpt 时区" href="/md/Javascirpt 时区.html">46 Javascirpt 时区</a></li><li class=""><a title="实用的 Javascript 小功能" href="/md/实用的 Javascript 小功能.html">45 实用的 Javascript 小功能</a></li><li class=""><a title="前端实现直接粘贴图片到 html 页面" href="/md/前端实现直接粘贴图片到 html 页面.html">44 前端实现直接粘贴图片到 html 页面</a></li><li class=""><a title="前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器" href="/md/前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器.html">43 前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器</a></li><li class=""><a title="JS 中数组的 map 鲜为人知但绝妙的使用方法" href="/md/JS 中数组的 map 鲜为人知但绝妙的使用方法.html">42 JS 中数组的 map 鲜为人知但绝妙的使用方法</a></li><li class=""><a title="在 Web 中判断页面是不是刷新" href="/md/在 Web 中判断页面是不是刷新.html">41 在 Web 中判断页面是不是刷新</a></li><li class=""><a title="Js 小技巧" href="/md/Js 小技巧.html">40 Js 小技巧</a></li><li class=""><a title="split 方法我算是白学了" href="/md/split 方法我算是白学了.html">39 split 方法我算是白学了</a></li><li class=""><a title="拼接 URL" href="/md/拼接 URL.html">38 拼接 URL</a></li><li class=""><a title="ES14 中 5 个最具变革性的 JavaScript 特性" href="/md/ES14 中 5 个最具变革性的 JavaScript 特性.html">37 ES14 中 5 个最具变革性的 JavaScript 特性</a></li><li class=""><a title="JavaScript 中设置器和获取器" href="/md/JavaScript 中设置器和获取器.html">36 JavaScript 中设置器和获取器</a></li><li class=""><a title="非常强大的标准 JavaScript API - AbortController" href="/md/非常强大的标准 JavaScript API - AbortController.html">35 非常强大的标准 JavaScript API - AbortController</a></li><li class=""><a title="掌握 JavaScript 中的 Call 和 Apply" href="/md/掌握 JavaScript 中的 Call 和 Apply.html">34 掌握 JavaScript 中的 Call 和 Apply</a></li><li class=""><a title="一文整懂事件对象 event 的常用方法" href="/md/一文整懂事件对象 event 的常用方法.html">33 一文整懂事件对象 event 的常用方法</a></li><li class=""><a title="7 种开发人员都应该知道的高级 JavaScript 技术" href="/md/7 种开发人员都应该知道的高级 JavaScript 技术.html">32 7 种开发人员都应该知道的高级 JavaScript 技术</a></li><li class=""><a title="实现基于用户操作系统偏好的明暗主题切换" href="/md/实现基于用户操作系统偏好的明暗主题切换.html">31 实现基于用户操作系统偏好的明暗主题切换</a></li><li class="active"><a title="JavaScript 原生实现图片复制与粘贴" href="/md/JavaScript 原生实现图片复制与粘贴.html">30 JavaScript 原生实现图片复制与粘贴</a></li><li class=""><a title="高精度实现定时器" href="/md/高精度实现定时器.html">29 高精度实现定时器</a></li><li class=""><a title="获取上传进度的几种方式" href="/md/获取上传进度的几种方式.html">28 获取上传进度的几种方式</a></li><li class=""><a title="聊聊禁止页面滚动的几种方法" href="/md/聊聊禁止页面滚动的几种方法.html">27 聊聊禁止页面滚动的几种方法</a></li><li class=""><a title="缓存 http 错误，避免多次报错提示" href="/md/缓存 http 错误，避免多次报错提示.html">26 缓存 http 错误，避免多次报错提示</a></li><li class=""><a title="文件操作" href="/md/文件操作.html">25 文件操作</a></li><li class=""><a title="数据类型判断方法" href="/md/数据类型判断方法.html">24 数据类型判断方法</a></li><li class=""><a title="宏任务和微任务" href="/md/宏任务和微任务.html">23 宏任务和微任务</a></li><li class=""><a title="十个超级好用的 Js 技巧" href="/md/十个超级好用的 Js 技巧.html">22 十个超级好用的 Js 技巧</a></li><li class=""><a title="前端的网络状态" href="/md/前端的网络状态.html">21 前端的网络状态</a></li><li class=""><a title="使用 JavaScript 加载字体" href="/md/使用 JavaScript 加载字体.html">20 使用 JavaScript 加载字体</a></li><li class=""><a title="你需要知道的 Symbols" href="/md/你需要知道的 Symbols.html">19 你需要知道的 Symbols</a></li><li class=""><a title="Set 和 WeakSet 的用法和区别" href="/md/Set 和 WeakSet 的用法和区别.html">18 Set 和 WeakSet 的用法和区别</a></li><li class=""><a title="sessionStorage 能在多个标签页之间共享数据吗" href="/md/sessionStorage 能在多个标签页之间共享数据吗.html">17 sessionStorage 能在多个标签页之间共享数据吗</a></li><li class=""><a title="scrollIntoview" href="/md/scrollIntoview.html">16 scrollIntoview</a></li><li class=""><a title="reduce 的高级用法" href="/md/reduce 的高级用法.html">15 reduce 的高级用法</a></li><li class=""><a title="js 小众且好用的技巧" href="/md/js 小众且好用的技巧.html">14 js 小众且好用的技巧</a></li><li class=""><a title="js 如何监听一个变量改变" href="/md/js 如何监听一个变量改变.html">13 js 如何监听一个变量改变</a></li><li class=""><a title="javascript 奇葩行为大赏" href="/md/javascript 奇葩行为大赏.html">12 javascript 奇葩行为大赏</a></li><li class=""><a title="FileReader" href="/md/FileReader.html">11 FileReader</a></li><li class=""><a title="EventSource" href="/md/EventSource.html">10 EventSource</a></li><li class=""><a title="document.referrer 拦截问题" href="/md/document.referrer 拦截问题.html">09 document.referrer 拦截问题</a></li><li class=""><a title="7 个 Promise 静态方法" href="/md/7 个 Promise 静态方法.html">08 7 个 Promise 静态方法</a></li><li class=""><a title="谈谈前端路由的实现原理 hash ＆ history" href="/md/谈谈前端路由的实现原理 hash ＆ history.html">07 谈谈前端路由的实现原理 hash ＆ history</a></li><li class=""><a title="属性的 getter 和 setter" href="/md/属性的 getter 和 setter.html">06 属性的 getter 和 setter</a></li><li class=""><a title="高效检查 JS 对象中的键是否存在" href="/md/高效检查 JS 对象中的键是否存在.html">05 高效检查 JS 对象中的键是否存在</a></li><li class=""><a title="实现鼠标滚轮缩放 SVG 内容" href="/md/实现鼠标滚轮缩放 SVG 内容.html">04 实现鼠标滚轮缩放 SVG 内容</a></li><li class=""><a title="使用 JS 向现有 SVG 中添加元素" href="/md/使用 JS 向现有 SVG 中添加元素.html">03 使用 JS 向现有 SVG 中添加元素</a></li><li class=""><a title="JS 单行代码集" href="/md/JS 单行代码集.html">02 JS 单行代码集</a></li><li class=""><a title="7 种位运算符的神奇用法" href="/md/7 种位运算符的神奇用法.html">01 7 种位运算符的神奇用法</a></li>
                </div>
            </div>
        </nav>

        <!-- Main Content Area -->
        <main class="main-content">
            <header class="content-header">
                <div class="header-left">
                    <h1 class="page-title">JavaScript 原生实现图片复制与粘贴</h1>
                    <p class="time">HaoTian · 2024-09-08 12:25:22</p>
                </div>
                <div class="header-right">
                    <div class="tag-container">
                        <span class="tag">JavaScript</span>
                    </div>
                </div>
            </header>

            <!-- Article Content -->
            <article class="content-body md md ">
                <p>微信内置浏览器下载图片一直是个问题，通常需要引导用户跳出微信到外置浏览器进行下载。然而，这样操作繁琐，用户体验不佳。那么，是否可以直接将图片复制到剪贴板呢？答案是可以的，下面一起来看看具体实现。</p>
<h2>h2 复制图片:从网络到剪贴板</h2>
<h3>第一步:获取图片数据</h3>
<p>首先,我们需要从网络上获取图片数据。这里我们使用<code>fetch</code>函数,它就像一个网络搬运工,帮我们从指定的 URL 搬来图片数据。</p>
<pre><code class="language-js">async function copyImageToClipboard(imageUrl) {
  // 使用fetch获取图片数据
  const response = await fetch(imageUrl);
  // 将响应转换为Blob对象
  const blob = await response.blob();
  // ... (下一步)
}
</code></pre>
<p>这里的<code>blob</code>就像是图片数据的一个大箱子,里面装着我们需要的所有信息。</p>
<h3>第二步:放入剪贴板</h3>
<p>接下来,我们需要把这个&quot;图片箱子&quot;放入剪贴板。这就像是把图片放入一个随身携带的口袋里。</p>
<pre><code class="language-js">async function copyImageToClipboard(imageUrl) {
  // ... (前面的代码)

  try {
    // 创建一个剪贴板项目
    const item = new ClipboardItem({ &quot;image/png&quot;: blob });
    // 将项目写入剪贴板
    await navigator.clipboard.write([item]);
    console.log(&quot;图片已成功复制到剪贴板!&quot;);
  } catch (error) {
    console.error(&quot;复制图片到剪贴板时出错:&quot;, error);
  }
}
</code></pre>
<p>这里我们使用<code>ClipboardItem</code>和<code>navigator.clipboard.write</code>方法,就像是用一个特殊的魔法口袋,可以存放我们的图片数据。</p>
<h2>h2 粘贴图片:从剪贴板到页面</h2>
<h3>第一步:读取剪贴板</h3>
<p>当我们想要粘贴图片时,首先需要从剪贴板中取出数据。</p>
<pre><code class="language-js">async function pasteImage() {
  try {
    // 读取剪贴板内容
    const clipboardItems = await navigator.clipboard.read();
    // ... (下一步)
  } catch (error) {
    console.error(&quot;读取剪贴板时出错:&quot;, error);
  }
}
</code></pre>
<h3>第二步:处理图片数据</h3>
<p>接下来,我们需要从剪贴板项目中提取图片数据,并将其转换为可以在网页上显示的格式。</p>
<pre><code class="language-js">async function pasteImage() {
  try {
    // ... (前面的代码)

    for (const clipboardItem of clipboardItems) {
      // 检查是否有图片类型的数据
      if (clipboardItem.types.includes(&quot;image/png&quot;)) {
        // 获取图片数据
        const blob = await clipboardItem.getType(&quot;image/png&quot;);
        // 创建一个可以在网页上使用的URL
        const imageUrl = URL.createObjectURL(blob);
        // ... (下一步:显示图片)
      }
    }
  } catch (error) {
    console.error(&quot;处理剪贴板数据时出错:&quot;, error);
  }
}
</code></pre>
<h3>第三步:显示图片</h3>
<p>最后,我们将创建的图片 URL 用于在页面上显示图片。</p>
<pre><code class="language-js">async function pasteImage() {
  try {
    // ... (前面的代码)

    // 创建一个新的图片元素
    const imgElement = document.createElement(&quot;img&quot;);
    // 设置图片源为我们创建的URL
    imgElement.src = imageUrl;
    // 将图片添加到页面上
    document.body.appendChild(imgElement);

    console.log(&quot;图片已成功粘贴到页面!&quot;);
  } catch (error) {
    console.error(&quot;显示图片时出错:&quot;, error);
  }
}
</code></pre>
<h2>h2 总结</h2>
<p>通过以上步骤，我们实现了在浏览器中复制和粘贴图片的功能，有效解决了微信内置浏览器下载图片的问题。这种方法不仅简化了用户操作，还显著提升了用户体验。</p>
<p>目前，这个方案在 iOS 17 上测试完全没有问题。对于其他机型的兼容性，建议进行进一步的测试和验证。</p>

            </article>
        </main>

        <!-- Table of Contents Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-header">
                <h3>Table of Contents</h3>
            </div>
            <div class="toc-content" id="tocContent">
                <!-- TOC will be generated dynamically -->
            </div>
        </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 19V5M5 12l7-7 7 7"/>
        </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(135deg, var(--accent), rgba(59, 130, 246, 0.8));
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
        // Sidebar Toggle
        const toggleBtn = document.getElementById('toggleSidebar');
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');
        
        function toggleSidebar() {
            sidebar.classList.toggle('hidden');
            // Store sidebar state in localStorage
            localStorage.setItem('sidebarHidden', sidebar.classList.contains('hidden'));
        }
        
        toggleBtn.addEventListener('click', toggleSidebar);

        // Keyboard shortcut (Ctrl + B)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'b') {
                e.preventDefault(); // Prevent browser's default behavior
                toggleSidebar();
            }
        });

        // Restore sidebar state from localStorage
        document.addEventListener('DOMContentLoaded', () => {
            const sidebarHidden = localStorage.getItem('sidebarHidden') === 'true';
            if (sidebarHidden) {
                sidebar.classList.add('hidden');
            }
        });

        // Generate Table of Contents
        function generateTOC() {
            const article = document.querySelector('.content-body');
            const headings = article.querySelectorAll('h1, h2, h3, h4');
            const tocContent = document.getElementById('tocContent');
            const toc = document.createElement('ul');

            headings.forEach((heading, index) => {
                const id = `heading-${index}`;
                heading.id = id;
                
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${id}`;
                a.textContent = heading.textContent;
                a.className = `toc-level-${heading.tagName.toLowerCase()}`;
                
                li.appendChild(a);
                toc.appendChild(li);
            });

            tocContent.appendChild(toc);
        }

        // Initialize TOC
        document.addEventListener('DOMContentLoaded', generateTOC);

        // Image zoom with FLIP animation
        const overlay = document.querySelector(".zoom-overlay");
        let activeImage = null;

        document.querySelectorAll("img").forEach((img) => {
            if (img.closest("a")) return; // Skip images that are inside links
            img.style.cursor = "zoom-in";
            img.addEventListener("click", handleImageClick);
        });

        function handleImageClick(event) {
            const img = event.target;

            if (activeImage) {
                // If an image is already zoomed, unzoom it
                unzoomImage();
                return;
            }

            // Get the initial position and size
            const rect = img.getBoundingClientRect();
            const first = {
                x: rect.left,
                y: rect.top,
                width: rect.width,
                height: rect.height,
            };

            // Create a clone of the image
            const clone = img.cloneNode();
            clone.classList.add("zoomed-image");
            document.body.appendChild(clone);

            // Position the clone exactly over the original
            clone.style.position = "fixed";
            clone.style.left = `${first.x}px`;
            clone.style.top = `${first.y}px`;
            clone.style.width = `${first.width}px`;
            clone.style.height = `${first.height}px`;
            clone.style.margin = "0";
            clone.style.transformOrigin = "top left";

            // Show the overlay
            overlay.style.display = "block";

            // Calculate the final position and scale
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
            const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
            const scaleX = targetWidth / first.width;
            const scaleY = targetHeight / first.height;
            const scale = Math.min(scaleX, scaleY);

            const last = {
                width: first.width * scale,
                height: first.height * scale,
            };
            last.x = (viewportWidth - last.width) / 2;
            last.y = (viewportHeight - last.height) / 2;

            // Calculate and apply the transform
            const dx = last.x - first.x;
            const dy = last.y - first.y;

            requestAnimationFrame(() => {
                clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
                clone.style.transition = "transform 0.3s ease-out";
            });

            activeImage = { original: img, clone: clone };

            // Add click handlers for closing
            clone.addEventListener("click", unzoomImage);
            overlay.addEventListener("click", unzoomImage);
        }

        function unzoomImage() {
            if (!activeImage) return;

            const { original, clone } = activeImage;
            const rect = original.getBoundingClientRect();

            // Animate back to the original position
            clone.style.transform = `translate(0, 0) scale(1)`;

            // Clean up after the animation
            clone.addEventListener(
                "transitionend",
                () => {
                    clone.remove();
                    overlay.style.display = "none";
                },
                { once: true }
            );

            activeImage = null;
        }

        // 监听 ctrl + b
        window.addEventListener("keydown", (e) => {
            const leftDom = document.querySelector(".sidebar");
            if (e.ctrlKey && e.key === "b") {
                leftDom.classList.toggle("hidden");
            }
        });

        // Modal
        // const modal = document.getElementById("myModal");
        // const modalContent = modal.querySelector(".modal-content");
        // const openModal = document.getElementById("openModal");
        // const close = modal.querySelector(".close");

        // openModal.addEventListener("click", () => {
        //     modal.style.display = "block";
        // });

        // close.addEventListener("click", () => {
        //     modal.style.display = "none";
        // });

        // window.addEventListener("click", (e) => {
        //     if (e.target === modal) {
        //         modal.style.display = "none";
        //     }
        // });

        // Back to top button
        const backToTop = document.getElementById('backToTop');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 200) {
                backToTop.style.display = 'block';
            } else {
                backToTop.style.display = 'none';
            }
        });

        backToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    </script>
</body>
</html>
