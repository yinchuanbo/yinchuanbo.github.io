<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>Vuex 状态管理</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link id="prismTheme" rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700b3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
  </head>

  <body class="fade-in">
    <button
      class="toggle-sidebar"
      id="toggleSidebar"
      aria-label="Toggle Sidebar"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <div class="app-container">
      <!-- Sidebar Navigation -->
      <nav class="sidebar">
        <div class="sidebar-header">
          <button class="toggle-sidebar" id="toggleSidebar">
            <span></span>
          </button>
        </div>
        <div class="sidebar-content">
          <div class="nav-section"><li class="active"><a title="Vuex 状态管理" href="/md/Vuex 状态管理.html">21 Vuex 状态管理</a></li><li class=""><a title="Vue Router" href="/md/Vue Router.html">20 Vue Router</a></li><li class=""><a title="Vue 3 异常处理终极秘籍" href="/md/Vue 3 异常处理终极秘籍.html">19 Vue 3 异常处理终极秘籍</a></li><li class=""><a title="组件化高级详解" href="/md/组件化高级详解.html">18 组件化高级详解</a></li><li class=""><a title="你还不会调试线上 vue 组件" href="/md/你还不会调试线上 vue 组件.html">17 你还不会调试线上 vue 组件</a></li><li class=""><a title="如何构建高效的 Vue 3 前端项目结构" href="/md/如何构建高效的 Vue 3 前端项目结构.html">16 如何构建高效的 Vue 3 前端项目结构</a></li><li class=""><a title="vue3 vite 使用 代理转发" href="/md/vue3 vite 使用 代理转发.html">15 vue3 vite 使用 代理转发</a></li><li class=""><a title="分享一些 Vue 实用且常用的开发工具库" href="/md/分享一些 Vue 实用且常用的开发工具库.html">14 分享一些 Vue 实用且常用的开发工具库</a></li><li class=""><a title="Motion Vue 尤雨溪力荐的 Vue 动画库" href="/md/Motion Vue 尤雨溪力荐的 Vue 动画库.html">13 Motion Vue 尤雨溪力荐的 Vue 动画库</a></li><li class=""><a title="Composition API 详解" href="/md/Composition API 详解.html">12 Composition API 详解</a></li><li class=""><a title="实现过渡动画" href="/md/实现过渡动画.html">11 实现过渡动画</a></li><li class=""><a title="组件化进阶详解" href="/md/组件化进阶详解.html">10 组件化进阶详解</a></li><li class=""><a title="组件化基础详解" href="/md/组件化基础详解.html">09 组件化基础详解</a></li><li class=""><a title="组件化开发" href="/md/组件化开发.html">08 组件化开发</a></li><li class=""><a title="v-model和表单输入" href="/md/v-model和表单输入.html">07 v-model和表单输入</a></li><li class=""><a title="vue3 的 Options API" href="/md/vue3 的 Options API.html">06 vue3 的 Options API</a></li><li class=""><a title="模板语法和内置命令" href="/md/模板语法和内置命令.html">05 模板语法和内置命令</a></li><li class=""><a title="前端 vue 项目使用 ffmpeg 处理视频" href="/md/前端 vue 项目使用 ffmpeg 处理视频.html">04 前端 vue 项目使用 ffmpeg 处理视频</a></li><li class=""><a title="Vue Router 4 的 scrollBehavior 方法" href="/md/Vue Router 4 的 scrollBehavior 方法.html">03 Vue Router 4 的 scrollBehavior 方法</a></li><li class=""><a title="浅浅聊一下 vue 中的 nextTick 的实现原理" href="/md/浅浅聊一下 vue 中的 nextTick 的实现原理.html">02 浅浅聊一下 vue 中的 nextTick 的实现原理</a></li><li class=""><a title="Vue3.x 生态最能打的组合" href="/md/Vue3.x 生态最能打的组合.html">01 Vue3.x 生态最能打的组合</a></li></div>
        </div>
      </nav>

      <!-- Main Content Area -->
      <main class="main-content">
        <header class="content-header">
          <div class="header-left">
            <h1 class="page-title">Vuex 状态管理</h1>
            <p class="time">HaoTian · 2025-01-22 13:27:30</p>
          </div>
          <div class="header-right">
            <div class="tag-container">
              <span class="tag">Vue</span>
            </div>
            <button
              id="themeToggle"
              class="theme-toggle"
              aria-label="Toggle theme"
            >
              <svg
                class="sun-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
              <svg
                class="moon-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
            </button>
            <button class="theme-toggle" aria-label="Toggle theme" style="width: 36px;height: 36px;" onclick="window.location.href='/md';">
              <svg t="1737442501710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5258" width="20" height="20"><path d="M883.773793 626.047476c-17.308201 0-31.408337 14.029528-31.408337 31.304983l0 207.437469c0 17.204847-14.098089 31.302937-31.406291 31.302937L203.040834 896.092865c-17.340947 0-31.408337-14.098089-31.408337-31.302937L171.632497 657.352459c0-17.275455-14.099113-31.304983-31.408337-31.304983-17.380856 0-31.444153 14.029528-31.444153 31.304983l0 207.437469c0 51.773154 42.261523 93.91188 94.260827 93.91188l617.918331 0c52.031027 0 94.259804-42.139749 94.259804-93.91188L915.21897 657.352459C915.21897 640.077004 901.152603 626.047476 883.773793 626.047476L883.773793 626.047476zM230.262826 614.286618c55.523571 0 104.556311-27.674293 134.394896-69.762877 32.487925 46.451962 86.303598 77.0744 147.343813 77.0744 61.036122 0 114.846678-30.623461 147.306974-77.0744 29.943986 42.018999 78.902024 69.762877 134.426619 69.762877 90.948385 0 164.968216-73.77526 164.968216-164.371628 0-11.062963-2.342348-22.859637-5.130857-35.178197-0.209778-1.134847 0.031722-2.26867-0.277316-3.38612l-0.629333-2.267647c-0.24764-0.924045-0.140193-1.535983-0.352017-2.547009-0.138146-0.505513-0.521886-0.87288-0.695848-1.39579l-85.364203-316.671313c-3.699252-13.645788-16.051581-23.172769-30.293957-23.172769L187.965487 65.296145c-14.238282 0-26.665313 9.526981-30.360472 23.24133L72.309374 405.1566c-0.103354 0.50756-0.48607 0.820692-0.62524 1.309832-0.210801 0.942465-0.107447 1.639337-0.349971 2.511193l-0.62524 2.373047c-0.318248 1.11745 0 2.25025-0.210801 3.38612-2.863211 12.31856-5.201465 24.115234-5.201465 35.178197C65.295634 540.511357 139.315464 614.286618 230.262826 614.286618L230.262826 614.286618z" fill="currentColor" p-id="5259"></path></svg>
            </button>
          </div>
        </header>

        <!-- Article Content -->
        <article
          class="content-body md md "
        >
          <h2>认识 Vuex 状态管理</h2>
<h3>认识状态管理</h3>
<p>在开发中，应用程序需要处理各种各样的数据，这些数据需要保存在应用程序中的某一个位置。对这些数据的管理，我们就称为<strong>状态管理</strong>。</p>
<p>实际上，Vue3 组件内部的数据以单向数据流的形式进行管理。具体来说，Vue3 组件的数据定义在 State(即 data 或 setup)中，在 View 层(即 template)使用 State 中的数据，View 层中会产生一些 Actions (比如单击事件)，而这些 Actions 可能会修改 State 的数据。</p>
<p>这就是以单向数据流的形式进行状态管理</p>
<p>如今 JavaScript 开发的应用程序变得越来越复杂，需要管理的状态也越来越多。比如，服务器返回的数据、缓存数据、用户操作产生的数据等；还有一些 UI 状态，比如元素是否被选中、是否显示加载动效等。通常，这些状态也需要在多个组件之间共享。</p>
<img src="../imgs/139/02.png" />

<p>然而，如果还是通过 Props 传递或 Provide 等方式来共享这些复杂且需要在多个组件中共享的数据，状态就会变得非常难以控制和追踪，也难以实现在兄弟组件之间共享数据。比如，状态之间相互存在依赖、一个状态的变化会引起另一个状态的变化、状态需要在多个组件之间共享等。</p>
<p>因此，我们可以考虑将组件内部状态抽离出来，以一个全局单例的方式进行管理。这样，我们可以通过插件的形式将该单例挂载到 Vue3 实例上，任何组件都能从该单例上获取状态或触发行为。这种方式能够更好地控制和追踪状态的变化，同时能够更好地实现兄弟组件之间共享数据。这就是 Vuex 背后的基本思想。</p>
<p><strong>下面来看看 Vuex 状态管理流程：</strong></p>
<p>(1) 在 State 中定义全局状态(变量)。</p>
<p>(2) 在 Vue Components 组件树中使用 State 定义的状态</p>
<p>(3) Vue Components 组件树通过 Dispatch 分发 Actions (也可直接通过 Commit 提交到 Mutations)</p>
<p>(4) Actions 支持编写异步逻辑，可将异步请求的数据提交到 Mutations 中</p>
<p>(5) Mutations 以同步的方式修改 State 状态，并且 State 的状态只能在 Mutations 中修改。</p>
<img src="../imgs/139/03.png" />

<h3>Vuex 的基本使用</h3>
<p><strong>第一步: 安装 Vuex 库</strong></p>
<pre><code class="language-sh">npm i vuex@4.0.2 --save
# 或者
npm i vuex@next --save
</code></pre>
<p><strong>第二步: 创建 Store</strong></p>
<p>在 Vue3 中，Vuex 的核心是 Store(仓库)。仓库本质上是一个容器，用于存储应用程序大部分的状态。仓库中存储的状态具有以下特点</p>
<ol>
<li><p>状态是响应式的。当组件从仓库中读取状态时，如果仓库中的状态发生变化，那么相应的组件也会更新</p>
</li>
<li><p>不能直接改变仓库中的状态。改变仓库中的状态的唯一途径是显式提交 mutation。这样可以方便地跟踪每个状态的变化，从而让我们能够通过一些工具(如 Vue.js devtools) 更好地管理应用状态。</p>
</li>
</ol>
<pre><code class="language-sh">|--src
  |--store
    |--index.js
</code></pre>
<pre><code class="language-js">import { createStore } from &quot;vuex&quot;;
const store = createStore({
  state() {
    return {
      counter: 0,
    };
  },
});
export default store;
</code></pre>
<p><strong>第三步: 将 Vuex 插件安装到 Vue3 框架中</strong></p>
<ul>
<li>src/main.js</li>
</ul>
<pre><code class="language-js">import { createApp } from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
import store from &quot;./store&quot;;
const app = createApp(App);
app.use(store);
app.mount(&quot;#app&quot;);
</code></pre>
<p><strong>第四步: 使用 store</strong></p>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div&gt;当前计数: {{ $store.state.counter }}&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>下面继续演示修改 store 中的 counter 变量 <code>注意: 修改 store 中的变量必须在 mutations 中进行</code></p>
<ul>
<li>src/store/index.js</li>
</ul>
<pre><code class="language-js">import { createStore } from &quot;vuex&quot;;
const store = createStore({
  state() {
    return {
      counter: 0,
    };
  },
  // 在 mutations 中修改全局状态
  mutations: {
    increment(state) {
      state.counter++; // 修改全局的 counter
    },
    decrement(state) {
      state.counter--; // 修改全局的 counter
    },
  },
});
export default store;
</code></pre>
<blockquote>
<p>需要注意的是: 在 mutations 中定义的函数，第一个参数默认会获取 <code>state()</code> 函数中返回的对象 slate</p>
</blockquote>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div&gt;当前计数: {{ $store.state.counter }}&lt;/div&gt;
  &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
  &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useStore } from &quot;vuex&quot;;
  export default {
    name: &quot;App&quot;,
    methods: {
      increment() {
        this.$store.commit(&quot;increment&quot;);
      },
    },
    setup() {
      const store = useStore();
      const decrement = () =&gt; {
        store.commit(&quot;decrement&quot;);
      };
      return {
        decrement,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h2>Vuex 的核心概念</h2>
<p>Vue 3 的响应式系统和双向数据绑定是 Vuex 底层原理的基础。Vuex 的核心概念包括以下内容。</p>
<p>(1) state: 即存储数据的地方，所有组件都可以访问和使用 store 中的状态。</p>
<p>(2) getters: 可以理解为 store 中的计算属性，用于从 store 中的 state 中派生一些状态</p>
<p>(3) mutations: 用于同步修改 store 中的状态，必须是同步函数。</p>
<p>(4) actions: 用于异步提交 mutations，可以包含任意异步操作。</p>
<p>(5) modules: 用于将 store 分割成多个模块，每个模块可以维护自己的 state、getter、mutation、action 。</p>
<h3>state</h3>
<p>state 表示应用的状态，即存储数据的地方。Vuex 通过 “单一状态树” 来管理应用层级的全部状态，将应用的所有状态存储在一个单独的 store 中，而不是分散在多个 store 对象或各个组件的 data 属性中。</p>
<p>这种设计模式可以方便地对数据进行全局状态的管理，避免组件间状态共享带来的复杂性，也更容易追踪状态的变化等。</p>
<p><strong>1. 使用计算属性读取状态</strong></p>
<p>对于存储在 store 中的状态，除了可以在模板中使用 <code>$store.state</code> 来读取，也可以使用计算属性来读取。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ counter }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { computed } from &quot;vue&quot;;
  export default {
    name: &quot;Home&quot;,
    computed: {
      counter() {
        return this.$store.state.counter; // 使用计算属性来读取状态
      },
    },
  };
</code></pre>
<p>在计算属性中，尽管可以读取状态，但是一旦读取的状态过多，代码就会变得烦琐。为了简化状态的获取过程，Vuex 提供了 mapState 辅助函数。</p>
<p>mapState 辅助函数有两种使用方式:</p>
<ul>
<li><p>mapState 函数，接收对象类型参数</p>
</li>
<li><p>mapState 函数，接收数组类型参数</p>
</li>
</ul>
<p>(1) mapState 函数，接收对象类型参数</p>
<pre><code class="language-js">// src/store/index.js
import { createStore } from &quot;vuex&quot;;
const store = createStore({
  state() {
    return {
      counter: 0,
      name: &quot;why&quot;,
      age: 18,
    };
  },
  //...
});

export default store;
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ name }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ HyAge }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapState } from &quot;vuex&quot;;
  export default {
    name: &quot;Home&quot;,
    data() {
      return {
        firstName: &quot;coder&quot;,
      };
    },
    computed: {
      // mapState 函数，接收对象类型参数
      ...mapState({
        // 箭头函数，不绑定 this
        counter: (state) =&gt; state.counter,
        name(state) {
          return this.firstName + state.name;
        },
        HyAge: &quot;age&quot;,
      }),
    },
  };
&lt;/script&gt;
</code></pre>
<p>(2) mapState 函数，接收数组类型参数</p>
<p>mapState 函数还可以接收数组类型参数，并返回一个对象。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ name }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapState } from &quot;vuex&quot;;
  export default {
    name: &quot;Home&quot;,
    computed: {
      // mapState 函数，接收数组类型参数
      ...mapState([&quot;counter&quot;, &quot;name&quot;]),
    },
  };
</code></pre>
<p><strong>2. 在 setup 函数中读取状态</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ name }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ age }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapState, useStore } from &quot;vuex&quot;;
  import { computed } from &quot;vue&quot;;
  export default {
    name: &quot;Home&quot;,
    setup() {
      const store = useStore();
      // 在 computed 中通过 store 来获取状态
      const counter = computed(() =&gt; store.state.counter);
      const name = computed(() =&gt; store.state.name);
      const age = computed(() =&gt; store.state.age);
      return {
        counter,
        name,
        age,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>下面看看如何在 setup 函数中使用 mapState 函数</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ name }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ age }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapState, useStore } from &quot;vuex&quot;;
  import { computed } from &quot;vue&quot;;
  export default {
    name: &quot;Home&quot;,
    setup() {
      const store = useStore();
      const storeStateFns = mapState([&quot;counter&quot;, &quot;name&quot;, &quot;age&quot;]);
      // storeStateFns 打印为：{ name: function, age: function, counter: function  }
      const storeState = {};
      Object.keys(storeStateFns).forEach((fnKey) =&gt; {
        const fn = storeStateFns[fnKey].bind({ $store: store }); // 绑定 this 为 { $store: store }
        storeState[fnKey] = computed(fn);
      });
      // storeState 打印为：{name: ref, age: ref, counter: ref}
      return {
        ...storeState,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>可以看到，这里使用 mapState 辅助函数对 state 中的 counter、name 和 age 变量进行映射。由于这里使用的是 setup 语法，mapState 函数返回的对象赋值给了 storeStateFns 变量，而不是 computed 选项。</p>
<p>因此，我们需要将 storeStateFns 对象里的函数转换成计算属性，以便在 template 中使用，接着，遍历 storeStateFns 对象，取出对象中的每个函数,并为函数绑定 this (即绑定 <code>{$store:store}</code> 对象)。然后，将这些函数转换成计算属性函数，并赋值给 storeState 对象。最后，在 return 语
句中将 storeState 对象解构并返回。</p>
<p><strong>3. mapState 的封装</strong></p>
<pre><code class="language-sh">|--src
  |--hooks
    |--useState.js
    |--index.js
</code></pre>
<pre><code class="language-js">// useState.js
import { mapState, useStore } from &quot;vuex&quot;;
import { computed } from &quot;vue&quot;;

export function useState(mapper) {
  const store = useStore();
  const storeStateFns = mapState(mapper);
  const storeState = {};
  Object.keys(storeStateFns).forEach((fnKey) =&gt; {
    const fn = storeStateFns[fnKey].bind({ $store: store });
    storeState[fnKey] = computed(fn);
  });
  return storeState;
}
</code></pre>
<pre><code class="language-js">// index.js
import { useState } from &quot;./useState&quot;;
export { useState };
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ counter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ name }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ age }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useState } from &quot;../hooks&quot;;
  export default {
    name: &quot;Home&quot;,
    setup() {
      // 数组形式
      const storeState = useState([&quot;counter&quot;]);
      // 对象形式
      const storeState2 = useState({
        name: (state) =&gt; state.name,
        age: (state) =&gt; state.age,
      });
      return {
        ...storeState,
        ...storeState2,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>getters</h3>
<p>Vuex 允许我们在 store 中定义 getters。geters 可以理解为 Vuex 的计算属性，可以从 store 中的 state 中派生出一些状态。这样，我们就可以在任意组件中直接使用 getters 中定义的方法了。</p>
<p><strong>1. getters 的基本使用</strong></p>
<pre><code class="language-js">// src/store/index.js
const Store = createStore({
  state() {
    return {
      books: [
        {
          name: &quot;Vue.js&quot;,
          count: 10,
          price: 10,
        },
        {
          name: &quot;Java&quot;,
          count: 20,
          price: 20,
        },
        {
          name: &quot;Python&quot;,
          count: 30,
          price: 30,
        },
      ],
      discount: 0.8,
    };
  },
  getters: {
    totalPrice(state) {
      let totalPrice = 0;
      state.books.forEach((book) =&gt; {
        totalPrice += book.count * book.price;
      });
      return totalPrice;
    },
  },
});
export default Store;
</code></pre>
<p>使用 getters</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;书籍总价: {{ $store.getters.totalPrice }}&lt;/h4&gt;
  &lt;/div&gt;&lt;/template
&gt;
</code></pre>
<p><strong>2. getters 中方法的参数</strong></p>
<p>在 getters 中定义的方法可以接收两个参数，分别为 state 对象和 getters 对象</p>
<pre><code class="language-js">// src/store/index.js
const Store = createStore({
  state() {
    return {
      //...
      discount: 0.8,
    };
  },
  getters: {
    totalPrice(state, getters) {
      let totalPrice = 0;
      state.books.forEach((book) =&gt; {
        totalPrice += book.count * book.price;
      });
      return totalPrice * getters.currentDiscount;
    },
    currentDiscount(state) {
      return state.discount;
    },
  },
});
export default Store;
</code></pre>
<p><strong>3. getters 中定义的方法返回函数类型</strong></p>
<p>在 getters 中定义的方法不仅可以返回值，还支持返回一个函数。如果返回的是函数，那么在使用时相当于调用这个函数。同时，我们可以向该函数传递参数，以实现数据的传递。</p>
<pre><code class="language-js">// src/store/index.js
const Store = createStore({
  state() {
    return {
      //...
      discount: 0.8,
    };
  },
  getters: {
    totalPrice(state, getters) {
      let totalPrice = 0;
      state.books.forEach((book) =&gt; {
        totalPrice += book.count * book.price;
      });
      return totalPrice * getters.currentDiscount;
    },
    currentDiscount(state) {
      return state.discount;
    },
    totalPriceByName(state) {
      return function (name) {
        let totalPrice = 0;
        state.books.forEach((book) =&gt; {
          if (book.name === name) {
            totalPrice += book.count * book.price;
          }
        });
        return totalPrice;
      };
    },
  },
});
export default Store;
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;书籍总价: {{ $store.getters.totalPrice }}&lt;/h4&gt;
    &lt;h4&gt;书籍总价: {{ $store.getters.totalPriceByName(&#39;Java&#39;) }}&lt;/h4&gt;
  &lt;/div&gt;&lt;/template
&gt;
</code></pre>
<p><strong>4. mapGetters 辅助函数</strong></p>
<p>Vuex 同样提供了 mapGetters 辅助函数，用于简化获取 getters 的操作，其语法与 mapState 函数类似。</p>
<p>(1) computed 属性中使用 mapGetters 函数</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;{{ $store.getters.totalPrice }}&lt;/h4&gt;
    &lt;h4&gt;{{ $store.getters.totalPriceByName(&#39;Java&#39;) }}&lt;/h4&gt;

    &lt;h4&gt;{{ totalPrice }}&lt;/h4&gt;
    &lt;h4&gt;{{ discount }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapGetters } from &quot;vuex&quot;;
  export default {
    name: &quot;Home&quot;,
    computed: {
      ...mapGetters([&quot;totalPrice&quot;]), // 数组语法
      ...mapGetters({
        discount: &quot;currentDiscount&quot;, // 对象语法
      }),
    },
  };
&lt;/script&gt;
</code></pre>
<p>(2) setup 函数中使用 mapGetters 函数</p>
<p>与 mapState 类似，mapGetters 函数返回对象中的属性并不是计算属性，因此不能直接在页面中展示。下面封装一个 useGetters 函数来统一处理，</p>
<pre><code class="language-sh">|--src
  |--hooks
    |--useGetters.js
    |--index.js
</code></pre>
<pre><code class="language-js">// useGetters.js
import { mapGetters, useStore } from &quot;vuex&quot;;
import { computed } from &quot;vue&quot;;

export function useGetters(mapper) {
  const store = useStore();
  const storeGettersFns = mapGetters(mapper);
  const storeGetters = {};
  Object.keys(storeGettersFns).forEach((fnKey) =&gt; {
    const fn = storeGettersFns[fnKey].bind({ $store: store });
    storeGetters[fnKey] = computed(fn);
  });
  return storeGetters;
}
</code></pre>
<pre><code class="language-js">// hooks/index.js
import { useGetters } from &quot;./useGetters&quot;;
export { useGetters };
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;{{ totalPriceByName(&quot;Java&quot;) }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useGetters } from &quot;../hooks&quot;;
  export default {
    setup() {
      const storeGetters = useGetters([&quot;totalPriceByName&quot;]);
      return {
        ...storeGetters,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<h3>mutations</h3>
<p>在 Vuex 状态管理模式中，mutations 是一个重要的概念，用于更改 store 中的状态。需要注意的是，mutations 必须是同步的，因为它是直接更改 store 中状态的唯一方法。</p>
<p><strong>1. mutations 的基本使用</strong></p>
<pre><code class="language-js">// src/store/index.js`
const Store = createStore({
  state() {
    return {
      counter: 0,
    };
  },
  mutations: {
    increment(state) {
      state.counter++;
    },
    decrement(state) {
      state.counter--;
    },
  },
});
export default Store;
</code></pre>
<p>可以看到，在 mutations 中，我们定义了两个函数，分别是 <code>increment</code> 和 <code>decrement</code>。这两个函数不能直接调用，因为在 mutations 中定义的选项更像事件注册。需要调用 <code>$store.commit</code> 方法提交一个类型为 increment 的 mutation 函数，才能调用 increment 函数。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;当前计数: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;button @click=&quot;$store.commit(&#39;increment&#39;)&quot;&gt;+1&lt;/button&gt;
    &lt;button @click=&quot;$store.commit(&#39;decrement&#39;)&quot;&gt;-1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><strong>2. mutations 接收参数</strong></p>
<p>在 mutations 中定义的方法可以接收两个参数，分别为 state 对象和 payload 对象。payload 对象是一个对象</p>
<p>其中 payload 用于接收提交 (commit) 时传递过来的参数，</p>
<pre><code class="language-js">// src/store/index.js`
const Store = createStore({
  state() {
    return {
      counter: 0,
    };
  },
  mutations: {
    increment(state) {
      state.counter++;
    },
    decrement(state) {
      state.counter--;
    },
    incrementN(state, payload) {
      state.counter += payload.num;
    },
  },
});
export default Store;
</code></pre>
<pre><code class="language-js">export default {
  methods: {
    addTen() {
      this.$store.commit(&quot;incrementN&quot;, {
        num: 10,
        name: &quot;why&quot;
        age: 18
      });
    },
  },
};
</code></pre>
<p>另外，<code>$store.commit</code> 还支持对象的方式</p>
<pre><code class="language-js">this.$store.commit({
	type: &quot;incrementN&quot;,
	// 将下面的属性都传递给 payload 参数
	num: 10,
	name: &quot;why&quot;
	age: 18
});
</code></pre>
<p><strong>3. mutations 常量类型</strong></p>
<p>从上面的案例中可以看出，为了触发 mutations 中的回调函数，<code>$store.commit</code> 提交的 type 值必须与 mutations 中定义的函数名称相同。</p>
<p>为了确保 type 值与函数名称一一对应，我们通会将 type 值提取为一个常量，这样可以避免在工作中出现不必要的错误。</p>
<pre><code class="language-sh">|--src
  |--store
		|--mutation-types.js
</code></pre>
<pre><code class="language-js">// mutation-types.js
export const INCREMENT_N = &quot;incrementN&quot;;
</code></pre>
<pre><code class="language-js">// src/store/index.js`
import { INCREMENT_N } from &quot;./mutation-types&quot;;
const Store = createStore({
  state() {
    return {
      counter: 0,
    };
  },
  mutations: {
    increment(state) {
      state.counter++;
    },
    decrement(state) {
      state.counter--;
    },
    // 使用一个常量作为函数名字
    [INCREMENT_N](state, payload) {
      state.counter += payload.num;
    },
  },
});
export default Store;
</code></pre>
<pre><code class="language-js">import { INCREMENT_N } from &quot;../store/mutation-types&quot;;
export default {
	methods: {
		addTen() {
			this.$store.commit(INCREMENT_N, {
				num: 10,
				name: &quot;why&quot;
				age: 18
			});
		},
	},
};
</code></pre>
<p><strong>4. mapMutations 辅助函数</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
  &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt;
  &lt;button @click=&quot;incrementN({num: 20})&quot;&gt;+20&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapMutations } from &quot;vuex&quot;;
  import { INCREMENT_N } from &quot;../store/mutation-types&quot;;
  export default {
    methods: {
      ...mapMutations([&quot;increment&quot;]),
      ...mapMutations({
        incrementN: INCREMENT_N,
      }),
    },
    setup() {
      const storeMutations = mapMutations([&quot;decrement&quot;]);
      return {
        ...storeMutations,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>在 Vuex 中，mutations 必须是同步的。这是因为 Vue.js devtools 工具会记录 mutations 函数的日志，每条 mutation 被记录时，Vue.js devtools 都需要捕捉到前一次状态和后一次状态的快照。如果在 mutation 中执行异步操作，就无法追踪到数据的变化。</p>
</blockquote>
<h3>actions</h3>
<p>在 Vuex 状态管理模式中，actions 是一个重要的概念。与 mutations 不同，actions 用于异步更改 Store 中的状态。它类似于 mutations,但是负责提交 mutation 函数，而不是直接变更状态，可以用于执行异步操作。</p>
<p><strong>1. actions 的基本使用</strong></p>
<pre><code class="language-js">// src/store/index.js
const Store = createStore({
  // ...
  actions: {
    incrementAction(context) {
      // 模拟异步
      setTimeout(() =&gt; {
        context.commit(&quot;increment&quot;); // 提交一个 type 为 increment 的 mutation 函数
      }, 1000);
    },
    decrementAction(context) {
      // 解构
      const { commit, dispatch, state, rootState, getters, rootGetters } =
        context;
      commit(&quot;decrement&quot;);
    },
  },
});
</code></pre>
<blockquote>
<p>context 是一个与 store 实例具有相同方法和属性的上下文对象。</p>
</blockquote>
<p>context 参数也支持 ES6 解构写法：</p>
<pre><code class="language-js">// ...
actions: {
	incrementAction({ commit, dispatch, state, rootState, getters, rootGetters }) {
		// 也可以提交多个
		commit(&quot;increment&quot;)
		commit(&quot;increment&quot;)
	},
}
//...
</code></pre>
<p>调用 actions 中的方法要使用 <code>$store.dispatch</code></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;当前计数: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useStore } from &quot;vuex&quot;;
  export default {
    methods: {
      increment() {
        this.$store.dispatch(&quot;incrementAction&quot;); // 分发 action
      },
    },
    setup() {
      const store = useStore();
      const decrement = () =&gt; {
        store.dispatch(&quot;decrementAction&quot;); // 分发 action
      };
      return {
        decrement,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>mutation 必须是同步函数，action 函数不受这种约束。因此可以在 action 函数中执行异步操作。</p>
</blockquote>
<p><strong>2. actions 接收参数</strong></p>
<p>与 mutations 类，在 actions 中定义的 action 函数也可以接收两个参数，分别为 context 对象和 payload 对象。</p>
<p>其中，context 是一个与 store 实例具有相同方法和属性的对象。payload 用于接收分发 action 时传递过来的参数。</p>
<pre><code class="language-html">&lt;template&gt;
	&lt;div&gt;&lt;/div&gt;
		&lt;!-- ... --&gt;
		&lt;button @click=&quot;addTen&quot;&gt;+10&lt;/button&gt;
	&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
	setup() {
		//...
		const addTen = () =&gt; {
			this.$store.dispatch(&quot;incrementNAction&quot;, {
				num: 10
			});
		};
		return {
			addTen
		}
	}
}
&lt;/script&gt;
</code></pre>
<p>需要注意的是，<code>store.dispatch</code> 也支持对象的方式</p>
<pre><code class="language-js">const addTen = () =&gt; {
  this.$store.dispatch({
    type: &quot;incrementNAction&quot;,
    num: 10,
  });
};
</code></pre>
<pre><code class="language-js">// src/store/index.js
import { INCREMENT_N } from &quot;./mutation-types&quot;;
const Store = createStore({
  //...
  actions: {
    //...
    incrementNAction(context, payload) {
      // 在 actions 中执行 mutations 中的函数，
      // 直接修改 state 中的数据，只有通过 mutations 中函数才行
      context.commit(INCREMENT_N, payload);
    },
  },
});

export default Store;
</code></pre>
<p><strong>3. mapActions 辅助函数</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;当前计数: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;button @click=&quot;incrementAction&quot;&gt;+1&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt;
    &lt;button @click=&quot;addTen({ num: 20 })&quot;&gt;+20&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapActions } from &quot;vuex&quot;;
  import { INCREMENT_N } from &quot;../store/mutation-types&quot;;
  export default {
    methods: {
      ...mapActions([&quot;incrementAction&quot;]), // 数组形式
    },
    setup() {
      // 对象形式
      const actionsFuncs = mapActions({
        decrement: &quot;decrementAction&quot;,
        addTen: &quot;incrementNAction&quot;,
      });
      return {
        ...actionsFuncs,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>4. action 返回 Promise 对象</strong></p>
<p>Action 通常用于处理异步操作。如果想在分发时知道 action 何时结束，可以让 action 函数返回一个 Promise 对象，并在 then 中监听 action 的结束</p>
<pre><code class="language-js">// src/store/index.js
const store = createStore({
  state() {
    return {
      uuid: null,
    };
  },
  mutations: {
    addUUID(state, payload) {
      state.uuid = payload;
    },
  },
  actions: {
    getUUIDAction({ commit }) {
      return new Promise((resolve, reject) =&gt; {
        fetch(&quot;https://httpbin.org/uuid&quot;)
          .then((res) =&gt; res.json())
          .then((data) =&gt; {
            commit(&quot;addUUID&quot;, data.uuid);
            resolve(data);
          })
          .catch((err) =&gt; {
            reject(err);
          });
      });
    },
  },
});
</code></pre>
<p>使用</p>
<pre><code class="language-js">import { onMounted } from &quot;vue&quot;;
import { useStore } from &quot;vuex&quot;;
export default {
  setup() {
    const store = useStore();
    onMounted(() =&gt; {
      store.dispatch(&quot;getUUIDAction&quot;).then((res) =&gt; {
        console.log(res);
      });
    });
  },
};
</code></pre>
<h3>modules</h3>
<p>Vuex 通过“单一状态树”来管理应用层级的全部状态。然而，当 store 中的状态数据变得越来越多时，会难以维护和管理。</p>
<p>为了解决这个问题，我们可以使用 modules 将状态数据模块化，将 store 分割成多个模块 (module)。每个模块都拥有自己的 state、mutation、action、getter，甚至嵌套子模块。这样就可以更好地组织和管理状态数据，使代码更加清晰和易于维护。</p>
<pre><code class="language-js">// 模块 A
const moduleA = {
  state: () =&gt; ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

// 模块 B
const moduleB = {
  state: () =&gt; ({... }),
  mutations: {... },
  actions: {... }
}

const store = createStore({
	state: () =&gt; ({ ... }),
	mutations: {... },
	actions: {... },
	modules: {
		a: moduleA,
		b: moduleB
	}
})

// 访问模块 A 的状态
store.state.a
// 访问模块 B 的状态
store.state.b
</code></pre>
<p><strong>1. modules 的基本使用</strong></p>
<pre><code class="language-sh">|--src
  |--store
		|--modules
			|--home.js
			|--user.js
</code></pre>
<pre><code class="language-js">// src/store/modules/home.js
const homeModule = {
  state() {
    return {
      homeCounter: 100,
    };
  },
  getters: {},
  mutations: {},
  actions: {},
};
export default homeModule;
</code></pre>
<pre><code class="language-js">// src/store/modules/user.js
const userModule = {
  state() {
    return {
      userCounter: 1000,
    };
  },
  getters: {},
  mutations: {},
  actions: {},
};
export default userModule;
</code></pre>
<p>引入根模块：</p>
<pre><code class="language-js">// src/store/index.js
import { createStore } from &quot;vuex&quot;;
import home from &quot;./modules/home&quot;;
import user from &quot;./modules/user&quot;;
const Store = createStore({
  state() {
    return {
      counter: 0,
    };
  },
  getters: {},
  mutations: {},
  actions: {},
  modules: {
    home: home,
    user,
  },
});
export default Store;
</code></pre>
<p>在组件中使用：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.home.homeCounter }}&lt;/h4&gt;
    &lt;h4&gt;User: {{ $store.state.user.userCounter }}&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><strong>2. modules 的局部状态</strong></p>
<p>子模块会拥有自己的状态，包括 state、mutation、action、getter，以及嵌套的子模块。以下是子模块的一些特点：</p>
<ul>
<li><p>模块定义的 state 属于子模块的状态，称为局部状态。</p>
</li>
<li><p>在子模块内部，mutation 和 getter 函数接收的第一个参数 state 也是局部状态</p>
</li>
<li><p>在子模块内部，对于 action 函数，局部状态可以通过 context.state 暴露出来，而根节点状态则通过 context.rootState 暴露出来</p>
</li>
<li><p>在子模块内部，getter 函数的根节点状态 (rootState) 会作为第三个参数暴露出来。</p>
</li>
</ul>
<pre><code class="language-js">// src/store/modules/user.js
const userModule = {
  state() {
    return {
      userCounter: 1000,
    };
  },
  // user 模块的 mutation 和 getter 函数接收的第一个参数是局部状态 state
  getters: {
    doubleUserCount(state) {
      return state.userCounter * 2;
    },
    // 根节点状态 (rootState) 会作为第三个参数暴露出来
    userCountAddRootCount(state, getters, rootState) {
      return state.userCounter + rootState.counter;
    },
  },
  mutations: {
    increment(state) {
      state.userCounter++;
    },
  },
  actions: {
    incrementAction({ commit, state, rootState }) {
      commit(&quot;increment&quot;);
    },
  },
};
export default userModule;
</code></pre>
<p>组件中应用：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;root state 根模块的状态: {{ $store.state.counter }}&lt;/h4&gt;
    &lt;h4&gt;
      root state 根模块 currentDiscount: {{ $store.getters.currentDiscount }}
    &lt;/h4&gt;
    &lt;h4&gt;User 子模块: {{ $store.state.user.userCounter }}&lt;/h4&gt;
    &lt;h4&gt;User: {{ $store.getters[&quot;doubleUserCount&quot;] }}&lt;/h4&gt;
    &lt;h4&gt;User: {{ $store.getters.userCountAddRootCount }}&lt;/h4&gt;
    &lt;button @click=&quot;incrementAction&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;&lt;/template
&gt;
&lt;script&gt;
  import { useStore } from &quot;vuex&quot;;
  export default {
    setup() {
      const store = useStore();
      const incrementAction = () =&gt; {
        // store.dispatch(&quot;user/incrementAction&quot;);
        // 会触发 root 模块的 incrementAction 函数和 user 子模块的 incrementAction 函数
        store.dispatch(&quot;incrementAction&quot;);
      };
      return {
        incrementAction,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<blockquote>
<p>过 <code>$store.getters</code> 可以获取所有模块的 getters 对象</p>
</blockquote>
<p><strong>3. modules 命名空间</strong></p>
<p>上述案例存在一个问题，多个模块可以对同一个 action 作出响应。例如，当单击“+1”按钮，分发 type 为 incrementAction 的 action 时，会触发根模块和 user 子模块的 incrementAction 函数回调。这是因为在默认情况下，子模块内部的 action、getter 和 mutation 仍然注册在全局的命名空间中，使得多个模块可以对同一个 action 或 mutation 作出响应。</p>
<p>为了解决这个问题，我们希望子模块具有更高的封装度和复用性，因此可以添加 <code>namespaced: true</code> 使其成为带有命名空间的模块。这样当子模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<pre><code class="language-js">// src/store/modules/home.js
const homeModule = {
  namespaced: true,
  state() {
    return {
      homeCounter: 20,
    };
  },
  getters: {
    doubleHomeCount(state) {
      return state.homeCounter * 2;
    },
    homeCountAddRootCount(state, getters, rootState) {
      return state.homeCounter + rootState.counter;
    },
  },
  mutations: {
    increment(state) {
      state.homeCounter++;
    },
  },
  actions: {
    incrementAction({ commit, state, rootState }) {
      commit(&quot;increment&quot;);
    },
  },
};
export default homeModule;
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ $store.state.home.homeCounter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ $store.getters[&quot;home/doubleHomeCount&quot;] }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ $store.getters[&quot;home/homeCountAddRootCount&quot;] }}&lt;/h4&gt;
    &lt;button @click=&quot;incrementAction&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useStore } from &quot;vuex&quot;;
  export default {
    setup() {
      const store = useStore();
      const incrementAction = () =&gt; {
        store.dispatch(&quot;home/incrementAction&quot;);
      };
      return {
        incrementAction,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>4. 带命名空间的子模块访问根模块</strong></p>
<p>如果希望在子模块中使用根 state 和 getter，那么可以将 rootState 和 rootGetters 作为 getter 函数的第三个和第四个参数传入，也可以通过 context 对象的属性进行访问。</p>
<p>在子模块中，如果想要分发全局命名空间内的 action 或提交 mutation，只需将 <code>{ root: true }</code> 作为第三个参数传递给 dispatch 或 commit</p>
<pre><code class="language-js">// src/store/modules/home.js
const homeModule = {
  namespaced: true,
  state() {
    return {
      homeCounter: 20,
    };
  },
  getters: {
    doubleHomeCount(state) {
      return state.homeCounter * 2;
    },
    homeCountAddRootCount(state, getters, rootState, rootGetters) {
      return state.homeCounter + rootState.counter;
    },
  },
  mutations: {
    increment(state) {
      state.homeCounter++;
    },
  },
  actions: {
    incrementAction({
      commit,
      state,
      rootState,
      dispatch,
      rootGetters,
      rootState,
    }) {
      commit(&quot;increment&quot;); // 提交到当前模块的 mutation
      commit(&quot;increment&quot;, null, { root: true }); // 提交到根模块的 mutation

      dispatch(&quot;incrementAction&quot;); // 分发到当前模块的 action
      dispatch(&quot;incrementAction&quot;, null, { root: true }); // 分发到根模块的 action
    },
  },
};
export default homeModule;
</code></pre>
<p><strong>5. modules 辅助函数</strong></p>
<p>方式一：映射时指定模块名前缀</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h4&gt;Home: {{ homeCounter }}&lt;/h4&gt;
    &lt;h4&gt;Home: {{ doubleHomeCount }}&lt;/h4&gt;
    &lt;button @click=&quot;homeIncrementCommit&quot;&gt;+1&lt;/button&gt;
    &lt;button @click=&quot;incrementAction&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { mapState, mapGetters, mapMutations, mapActions } from &quot;vuex&quot;;
  export default {
    computed: {
      ...mapState({
        homeCounter: (state) =&gt; state.home.homeCounter,
      }),
      ...mapGetters({
        doubleHomeCount: &quot;home/doubleHomeCount&quot;,
      }),
    },
    methods: {
      ...mapMutations({
        homeIncrementCommit: &quot;home/increment&quot;,
      }),
      ...mapActions({
        incrementAction: &quot;home/incrementAction&quot;,
      }),
    },
  };
&lt;/script&gt;
</code></pre>
<p>方式二：辅助函数第一个参数作为模块名前缀</p>
<pre><code class="language-html">&lt;script&gt;
  import { mapState, mapGetters, mapMutations, mapActions } from &quot;vuex&quot;;
  export default {
    computed: {
      ...mapState(&quot;home&quot;, [&quot;homeCounter&quot;]),
      ...mapGetters(&quot;home&quot;, [&quot;doubleHomeCount&quot;]),
    },
    methods: {
      ...mapMutations(&quot;home&quot;, {
        homeIncrementCommit: &quot;increment&quot;,
      }),
      ...mapActions(&quot;home&quot;, [&quot;incrementAction&quot;]),
    },
  };
&lt;/script&gt;
</code></pre>
<p>方式三：借助辅助函数统一添加模块名前缀（推荐）</p>
<pre><code class="language-html">&lt;script&gt;
  import { createNamespacedHelpers } from &quot;vuex&quot;;
  const { mapState, mapGetters, mapMutations, mapActions } =
    createNamespacedHelpers(&quot;home&quot;);
  export default {
    computed: {
      ...mapState([&quot;homeCounter&quot;]),
      ...mapGetters([&quot;doubleHomeCount&quot;]),
    },
    methods: {
      ...mapMutations({
        homeIncrementCommit: &quot;increment&quot;,
      }),
      ...mapActions([&quot;incrementAction&quot;]),
    },
  };
&lt;/script&gt;
</code></pre>
<p>方式四：在 setup 中统一添加模块名前缀（推荐）</p>
<pre><code class="language-html">&lt;script&gt;
  import { createNamespacedHelpers } from &quot;vuex&quot;;
  import { computed } from &quot;vue&quot;;
  import { useMapper } from &quot;../hooks/index&quot;;
  const { mapState, mapGetters, mapMutations, mapActions } =
    createNamespacedHelpers(&quot;home&quot;);
  export default {
    setup() {
      const stateFunc = useMapper(mapState, [&quot;homeCounter&quot;]);
      const gettersFunc = useMapper(mapGetters, [&quot;doubleHomeCount&quot;]);
      const mutationsFunc = mapMutations({
        homeIncrementCommit: &quot;increment&quot;,
      });
      const actionsFunc = mapActions([&quot;incrementAction&quot;]);
      return {
        ...stateFunc,
        ...gettersFunc,
        ...mutationsFunc,
        ...actionsFunc,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<pre><code class="language-js">// src/hooks/useMapper.js
import { computed } from &quot;vue&quot;;
import { useStore } from &quot;vuex&quot;;
export function useMapper(mapFn, mapper) {
  const store = useStore();
  const storeStateFns = mapFn(mapper);
  const storeState = {};
  Object.keys(storeStateFns).forEach((fnKey) =&gt; {
    const fn = storeStateFns[fnKey];
    storeState[fnKey] = computed(fn.bind({ $store: store }));
  });
  return storeState;
}
</code></pre>

        </article>
      </main>

      <!-- Table of Contents Sidebar -->
      <aside class="toc-sidebar">
        <div class="toc-header">
          <h3>Table of Contents</h3>
        </div>
        <div class="toc-content" id="tocContent">
          <!-- TOC will be generated dynamically -->
        </div>
      </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M12 19V5M5 12l7-7 7 7" />
      </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(
          135deg,
          var(--accent),
          rgba(59, 130, 246, 0.8)
        );
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // Sidebar Toggle
      const toggleBtn = document.getElementById("toggleSidebar");
      const sidebar = document.querySelector(".sidebar");
      const mainContent = document.querySelector(".main-content");

      function toggleSidebar() {
        sidebar.classList.toggle("hidden");
        // Store sidebar state in localStorage
        localStorage.setItem(
          "sidebarHidden",
          sidebar.classList.contains("hidden")
        );
      }

      toggleBtn.addEventListener("click", toggleSidebar);

      // Keyboard shortcut (Ctrl + B)
      window.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "b") {
          e.preventDefault(); // Prevent browser's default behavior
          toggleSidebar();
        }
      });

      // Restore sidebar state from localStorage
      document.addEventListener("DOMContentLoaded", () => {
        const sidebarHidden = localStorage.getItem("sidebarHidden") === "true";
        if (sidebarHidden) {
          sidebar.classList.add("hidden");
        }
      });

      // Generate Table of Contents
      function generateTOC() {
        const article = document.querySelector(".content-body");
        const headings = article.querySelectorAll("h1, h2, h3, h4");
        const tocContent = document.getElementById("tocContent");
        const toc = document.createElement("ul");

        headings.forEach((heading, index) => {
          const id = `heading-${index}`;
          heading.id = id;

          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = `#${id}`;
          a.textContent = heading.textContent;
          a.className = `toc-level-${heading.tagName.toLowerCase()}`;

          li.appendChild(a);
          toc.appendChild(li);
        });

        tocContent.appendChild(toc);
      }

      // Initialize TOC
      document.addEventListener("DOMContentLoaded", generateTOC);

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }

      // 监听 ctrl + b
      window.addEventListener("keydown", (e) => {
        const leftDom = document.querySelector(".sidebar");
        if (e.ctrlKey && e.key === "b") {
          leftDom.classList.toggle("hidden");
        }
      });

      // Modal
      // const modal = document.getElementById("myModal");
      // const modalContent = modal.querySelector(".modal-content");
      // const openModal = document.getElementById("openModal");
      // const close = modal.querySelector(".close");

      // openModal.addEventListener("click", () => {
      //     modal.style.display = "block";
      // });

      // close.addEventListener("click", () => {
      //     modal.style.display = "none";
      // });

      // window.addEventListener("click", (e) => {
      //     if (e.target === modal) {
      //         modal.style.display = "none";
      //     }
      // });

      // Back to top button
      const backToTop = document.getElementById("backToTop");
      window.addEventListener("scroll", () => {
        if (window.scrollY > 200) {
          backToTop.style.display = "block";
        } else {
          backToTop.style.display = "none";
        }
      });

      backToTop.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      // Theme toggle
      document.addEventListener("DOMContentLoaded", () => {
        const themeToggle = document.getElementById("themeToggle");
        const html = document.documentElement;
        const prismTheme = document.getElementById("prismTheme");

        // Function to update theme and stylesheet
        function updateTheme(theme) {
          html.className = theme;
          prismTheme.href = `../css/prism${theme === "dark" ? "2" : ""}.css`;
          localStorage.setItem("theme", theme);
        }

        // Check for saved theme preference
        const savedTheme = localStorage.getItem("theme") || "light";
        updateTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const currentTheme = html.className;
          const newTheme = currentTheme === "light" ? "dark" : "light";
          updateTheme(newTheme);
        });
      });
    </script>
  </body>
</html>
