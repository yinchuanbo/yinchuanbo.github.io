<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>非常强大的标准 JavaScript API - AbortController</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism2.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>
  <body class="line-numbers">
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 2">
          <div class="layout__main_left-switch"></div>
          <ul>
            <li class=""><a title="理解JS里的WeakMap" href="/md/理解JS里的WeakMap.html">50 理解JS里的WeakMap</a></li><li class=""><a title="token无感刷新的基本实现" href="/md/token无感刷新的基本实现.html">49 token无感刷新的基本实现</a></li><li class=""><a title="前端中的 File 和 Blob两个对象到底有什么不同" href="/md/前端中的 File 和 Blob两个对象到底有什么不同.html">48 前端中的 File 和 Blob两个对象到底有什么不同</a></li><li class=""><a title="js 检测网页空闲状态(一定时间内无操作)" href="/md/js 检测网页空闲状态(一定时间内无操作).html">47 js 检测网页空闲状态(一定时间内无操作)</a></li><li class=""><a title="Javascirpt 时区" href="/md/Javascirpt 时区.html">46 Javascirpt 时区</a></li><li class=""><a title="实用的 Javascript 小功能" href="/md/实用的 Javascript 小功能.html">45 实用的 Javascript 小功能</a></li><li class=""><a title="前端实现直接粘贴图片到 html 页面" href="/md/前端实现直接粘贴图片到 html 页面.html">44 前端实现直接粘贴图片到 html 页面</a></li><li class=""><a title="前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器" href="/md/前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器.html">43 前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器</a></li><li class=""><a title="JS 中数组的 map 鲜为人知但绝妙的使用方法" href="/md/JS 中数组的 map 鲜为人知但绝妙的使用方法.html">42 JS 中数组的 map 鲜为人知但绝妙的使用方法</a></li><li class=""><a title="在 Web 中判断页面是不是刷新" href="/md/在 Web 中判断页面是不是刷新.html">41 在 Web 中判断页面是不是刷新</a></li><li class=""><a title="Js 小技巧" href="/md/Js 小技巧.html">40 Js 小技巧</a></li><li class=""><a title="split 方法我算是白学了" href="/md/split 方法我算是白学了.html">39 split 方法我算是白学了</a></li><li class=""><a title="拼接 URL" href="/md/拼接 URL.html">38 拼接 URL</a></li><li class=""><a title="ES14 中 5 个最具变革性的 JavaScript 特性" href="/md/ES14 中 5 个最具变革性的 JavaScript 特性.html">37 ES14 中 5 个最具变革性的 JavaScript 特性</a></li><li class=""><a title="JavaScript 中设置器和获取器" href="/md/JavaScript 中设置器和获取器.html">36 JavaScript 中设置器和获取器</a></li><li class="active"><a title="非常强大的标准 JavaScript API - AbortController" href="/md/非常强大的标准 JavaScript API - AbortController.html">35 非常强大的标准 JavaScript API - AbortController</a></li><li class=""><a title="掌握 JavaScript 中的 Call 和 Apply" href="/md/掌握 JavaScript 中的 Call 和 Apply.html">34 掌握 JavaScript 中的 Call 和 Apply</a></li><li class=""><a title="一文整懂事件对象 event 的常用方法" href="/md/一文整懂事件对象 event 的常用方法.html">33 一文整懂事件对象 event 的常用方法</a></li><li class=""><a title="7 种开发人员都应该知道的高级 JavaScript 技术" href="/md/7 种开发人员都应该知道的高级 JavaScript 技术.html">32 7 种开发人员都应该知道的高级 JavaScript 技术</a></li><li class=""><a title="实现基于用户操作系统偏好的明暗主题切换" href="/md/实现基于用户操作系统偏好的明暗主题切换.html">31 实现基于用户操作系统偏好的明暗主题切换</a></li><li class=""><a title="JavaScript 原生实现图片复制与粘贴" href="/md/JavaScript 原生实现图片复制与粘贴.html">30 JavaScript 原生实现图片复制与粘贴</a></li><li class=""><a title="高精度实现定时器" href="/md/高精度实现定时器.html">29 高精度实现定时器</a></li><li class=""><a title="获取上传进度的几种方式" href="/md/获取上传进度的几种方式.html">28 获取上传进度的几种方式</a></li><li class=""><a title="聊聊禁止页面滚动的几种方法" href="/md/聊聊禁止页面滚动的几种方法.html">27 聊聊禁止页面滚动的几种方法</a></li><li class=""><a title="缓存 http 错误，避免多次报错提示" href="/md/缓存 http 错误，避免多次报错提示.html">26 缓存 http 错误，避免多次报错提示</a></li><li class=""><a title="文件操作" href="/md/文件操作.html">25 文件操作</a></li><li class=""><a title="数据类型判断方法" href="/md/数据类型判断方法.html">24 数据类型判断方法</a></li><li class=""><a title="宏任务和微任务" href="/md/宏任务和微任务.html">23 宏任务和微任务</a></li><li class=""><a title="十个超级好用的 Js 技巧" href="/md/十个超级好用的 Js 技巧.html">22 十个超级好用的 Js 技巧</a></li><li class=""><a title="前端的网络状态" href="/md/前端的网络状态.html">21 前端的网络状态</a></li><li class=""><a title="使用 JavaScript 加载字体" href="/md/使用 JavaScript 加载字体.html">20 使用 JavaScript 加载字体</a></li><li class=""><a title="你需要知道的 Symbols" href="/md/你需要知道的 Symbols.html">19 你需要知道的 Symbols</a></li><li class=""><a title="Set 和 WeakSet 的用法和区别" href="/md/Set 和 WeakSet 的用法和区别.html">18 Set 和 WeakSet 的用法和区别</a></li><li class=""><a title="sessionStorage 能在多个标签页之间共享数据吗" href="/md/sessionStorage 能在多个标签页之间共享数据吗.html">17 sessionStorage 能在多个标签页之间共享数据吗</a></li><li class=""><a title="scrollIntoview" href="/md/scrollIntoview.html">16 scrollIntoview</a></li><li class=""><a title="reduce 的高级用法" href="/md/reduce 的高级用法.html">15 reduce 的高级用法</a></li><li class=""><a title="js 小众且好用的技巧" href="/md/js 小众且好用的技巧.html">14 js 小众且好用的技巧</a></li><li class=""><a title="js 如何监听一个变量改变" href="/md/js 如何监听一个变量改变.html">13 js 如何监听一个变量改变</a></li><li class=""><a title="javascript 奇葩行为大赏" href="/md/javascript 奇葩行为大赏.html">12 javascript 奇葩行为大赏</a></li><li class=""><a title="FileReader" href="/md/FileReader.html">11 FileReader</a></li><li class=""><a title="EventSource" href="/md/EventSource.html">10 EventSource</a></li><li class=""><a title="document.referrer 拦截问题" href="/md/document.referrer 拦截问题.html">09 document.referrer 拦截问题</a></li><li class=""><a title="7 个 Promise 静态方法" href="/md/7 个 Promise 静态方法.html">08 7 个 Promise 静态方法</a></li><li class=""><a title="谈谈前端路由的实现原理 hash ＆ history" href="/md/谈谈前端路由的实现原理 hash ＆ history.html">07 谈谈前端路由的实现原理 hash ＆ history</a></li><li class=""><a title="属性的 getter 和 setter" href="/md/属性的 getter 和 setter.html">06 属性的 getter 和 setter</a></li><li class=""><a title="高效检查 JS 对象中的键是否存在" href="/md/高效检查 JS 对象中的键是否存在.html">05 高效检查 JS 对象中的键是否存在</a></li><li class=""><a title="实现鼠标滚轮缩放 SVG 内容" href="/md/实现鼠标滚轮缩放 SVG 内容.html">04 实现鼠标滚轮缩放 SVG 内容</a></li><li class=""><a title="使用 JS 向现有 SVG 中添加元素" href="/md/使用 JS 向现有 SVG 中添加元素.html">03 使用 JS 向现有 SVG 中添加元素</a></li><li class=""><a title="JS 单行代码集" href="/md/JS 单行代码集.html">02 JS 单行代码集</a></li><li class=""><a title="7 种位运算符的神奇用法" href="/md/7 种位运算符的神奇用法.html">01 7 种位运算符的神奇用法</a></li>
          </ul>
        </div>
        <div class="layout__main_map" style="order: 0">
          <div class="layout__main_map_content"></div>
          <div class="layout__main_map_swicth">
          </div>
        </div>
        <div
          style="order: 1"
          class="layout__main_right md "
        >
          <div class="page-header">
            <h1>非常强大的标准 JavaScript API - AbortController</h1>
            <p class="time">HaoTian · 2024-09-29 22:09:04</p>
          </div>
          <p>今天，我们来聊聊一个可能被你忽视，而且非常强大的标准 JavaScript API - <code>AbortController</code> 。</p>
<p>在过去，大家在提到 <code>AbortController</code> 的时候，一般会举请求中断的例子，就连 MDN 给到的描述也是这样的：</p>
<img src="../imgs/80/01.webp" />

<p>但是 <code>AbortController</code> 的能力可不止于此，<code>AbortController</code> 是 JavaScript 中的一个全局类，它可以用来终止任何异步操作，使用方法如下：</p>
<pre><code class="language-js">const controller = new AbortController();
controller.signal;
controller.abort();
</code></pre>
<p>我们创建一个 <code>AbortController</code> 实例后，会得到两个东西：</p>
<ul>
<li><code>signal</code> 属性，这是一个 <code>AbortSignal</code> 实例，我们可以将它传递给要中断的 API，来响应中断事件并进行相应处理，例如，传递给 <code>fetch()</code> 方法就可以终止这个请求了；</li>
<li><code>.abort()</code> 方法，调用这个方法会触发 <code>signal</code> 上的中止事件，并将信号标记为已中止。</li>
</ul>
<p>我们可以通过监听 <code>abort</code> 事件，然后根据特定的逻辑实现中止：</p>
<pre><code class="language-js">controller.signal.addEventListener(&quot;abort&quot;, () =&gt; {
  // 实现中止逻辑
});
</code></pre>
<p>我们来了解一些支持 <code>AbortSignal</code> 的标准 JavaScript API。</p>
<h2>用法</h2>
<h3>事件监听器</h3>
<p>我们可以在添加事件监听器时提供一个中止 <code>signal</code>，这样在中止发生时，监听器会自动删除。</p>
<pre><code class="language-js">const controller = new AbortController();
window.addEventListener(&quot;resize&quot;, listener, { signal: controller.signal });
controller.abort();
</code></pre>
<p>如果我们调用 <code>controller.abort()</code> ，就会从 <code>window</code> 中删除 <code>resize</code> 监听器。这是一种非常优雅的处理事件监听器的方式，因为我们不再需要抽象监听器函数来调用 <code>removeEventListener()</code> 。</p>
<pre><code class="language-js">// const listener = () =&gt; {}
// window.addEventListener(&#39;resize&#39;, listener)
// window.removeEventListener(&#39;resize&#39;, listener)
const controller = new AbortController();
window.addEventListener(&quot;resize&quot;, () =&gt; {}, { signal: controller.signal });
controller.abort();
</code></pre>
<p>如果应用的不同部分负责删除监听器，传递一个 <code>AbortController</code> 实例会更加方便，然后我就发现可以使用单个 <code>signal</code> 来删除多个事件监听器！</p>
<pre><code class="language-js">useEffect(() =&gt; {
  const controller = new AbortController();
  window.addEventListener(&quot;resize&quot;, handleResize, {
    signal: controller.signal,
  });
  window.addEventListener(&quot;hashchange&quot;, handleHashChange, {
    signal: controller.signal,
  });
  window.addEventListener(&quot;storage&quot;, handleStorageChange, {
    signal: controller.signal,
  });
  return () =&gt; {
    // 调用 `.abort()` 会删除所有关联的事件监听器
    controller.abort();
  };
}, []);
</code></pre>
<p>在上面的例子中，我在 React 中添加了一个 <code>useEffect()</code> 钩子，其中引入了一些具有不同用途和逻辑的事件监听器。然后，在清理函数中，我只需调用一次 <code>controller.abort()</code> 就可以删除所有添加的监听器，还是很好用的！</p>
<h3>Fetch 请求</h3>
<p><code>fetch()</code> 函数也支持 <code>AbortSignal</code>，中断请求应该也是 <code>AbortController</code> 使用最多的场景。</p>
<p>一旦 <code>signal</code> 上的 <code>abort</code> 事件被触发，<code>fetch()</code> 函数返回的请求 <code>Promise</code> 就会被拒绝，从而终止未完成的请求。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;文件上传示例&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; /&gt;
    &lt;button id=&quot;uploadButton&quot;&gt;上传&lt;/button&gt;
    &lt;button id=&quot;cancelButton&quot;&gt;取消上传&lt;/button&gt;

    &lt;script&gt;
      function uploadFile(file) {
        const controller = new AbortController();

        // 将中止信号传递给 fetch 请求
        const response = fetch(&quot;/upload&quot;, {
          method: &quot;POST&quot;,
          body: file,
          signal: controller.signal,
        });

        return { response, controller };
      }

      document.getElementById(&quot;uploadButton&quot;).addEventListener(&quot;click&quot;, () =&gt; {
        const fileInput = document.getElementById(&quot;fileInput&quot;);
        const file = fileInput.files[0];

        if (!file) {
          alert(&quot;请选择一个文件&quot;);
          return;
        }

        const { response, controller } = uploadFile(file);

        response
          .then((res) =&gt; res.json())
          .then((data) =&gt; {
            console.log(&quot;文件上传成功:&quot;, data);
          })
          .catch((err) =&gt; {
            if (err.name === &quot;AbortError&quot;) {
              console.log(&quot;文件上传被取消&quot;);
            } else {
              console.error(&quot;文件上传失败:&quot;, err);
            }
          });

        // 保存 controller 以便取消上传
        window.currentUploadController = controller;
      });

      document.getElementById(&quot;cancelButton&quot;).addEventListener(&quot;click&quot;, () =&gt; {
        if (window.currentUploadController) {
          window.currentUploadController.abort();
          console.log(&quot;点击了取消上传按钮&quot;);
        } else {
          console.log(&quot;没有正在进行的上传操作&quot;);
        }
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>上面例子中的 <code>uploadFile()</code> 函数发起了一个 <code>POST</code> 请求，返回关联的 <code>response</code> Promise 以及一个 <code>AbortController</code> 实例，当用户点击取消上传按钮的时候，我们可以通过 <code>AbortController</code> 实例随时终止这个请求。</p>
<p>Node.js 中由 <code>http</code> 模块发出的请求也支持 <code>signal</code> 属性！</p>
<pre><code class="language-js">const http = require(&quot;http&quot;);
const { AbortController } = require(&quot;abort-controller&quot;);

function makeRequest() {
  const controller = new AbortController();

  const options = {
    hostname: &quot;example.com&quot;,
    port: 80,
    path: &quot;/&quot;,
    method: &quot;GET&quot;,
    // 将 AbortSignal 传递给请求
    signal: controller.signal,
  };

  const req = http.request(options, (res) =&gt; {
    let data = &quot;&quot;;
    res.on(&quot;data&quot;, (chunk) =&gt; {
      data += chunk;
    });

    res.on(&quot;end&quot;, () =&gt; {
      console.log(&quot;Response:&quot;, data);
    });
  });

  req.on(&quot;error&quot;, (e) =&gt; {
    if (e.name === &quot;AbortError&quot;) {
      console.log(&quot;请求被取消&quot;);
    } else {
      console.error(`请求遇到问题: ${e.message}`);
    }
  });

  req.end();

  // 模拟取消操作，例如在 2 秒后取消请求
  setTimeout(() =&gt; {
    controller.abort();
  }, 2000);
}

makeRequest();
</code></pre>
<h2><code>AbortSignal</code> 类的静态方法</h2>
<p><code>AbortSignal</code> 类还具有一些静态方法，可以简化 JavaScript 中的请求处理。</p>
<h3><code>AbortSignal.timeout</code></h3>
<p>我们可以使用 <code>AbortSignal.timeout()</code> 静态方法作为快捷方式，创建一个在经过一定超时时间后会触发中止事件的信号。如果只想在请求超时后取消请求，就不需要创建一个 <code>AbortController</code> 了：</p>
<pre><code class="language-js">document.getElementById(&quot;fetchButton&quot;).addEventListener(&quot;click&quot;, () =&gt; {
  const url = &quot;https://jsonplaceholder.typicode.com/posts/1&quot;; // 示例 API 地址

  fetch(url, {
    // 如果请求超过 1700 毫秒则自动中止
    signal: AbortSignal.timeout(1700),
  })
    .then((response) =&gt; {
      if (!response.ok) {
        throw new Error(&quot;网络响应失败&quot;);
      }
      return response.json();
    })
    .then((data) =&gt; {
      console.log(&quot;请求成功:&quot;, data);
    })
    .catch((error) =&gt; {
      if (error.name === &quot;AbortError&quot;) {
        console.error(&quot;请求超时被取消:&quot;, error);
      } else {
        console.error(&quot;请求出错:&quot;, error);
      }
    });
});
</code></pre>
<h3><code>AbortSignal.any</code></h3>
<p>类似于 <code>Promise.race()</code> 处理多个 Promise 的方式，我们可以使用 <code>AbortSignal.any()</code> 静态方法将多个中止信号组合到一个里面，下面是一个具体的例子：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;AbortSignal.any 示例&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button id=&quot;stopButton&quot;&gt;停止监听&lt;/button&gt;

    &lt;script&gt;
      const publicController = new AbortController();
      const internalController = new AbortController();

      // 创建 WebSocket 连接
      const socket = new WebSocket(&quot;wss://conardli.websocket.org&quot;);

      // 当 WebSocket 连接打开时触发
      socket.addEventListener(&quot;open&quot;, () =&gt; {
        console.log(&quot;WebSocket 连接已建立&quot;);
        socket.send(&quot;Hello WebSocket!&quot;);
      });

      // 处理收到的消息
      function handleMessage(event) {
        console.log(&quot;收到消息:&quot;, event.data);
      }

      // 使用 AbortSignal.any 将多个中止信号组合到一个中
      socket.addEventListener(&quot;message&quot;, handleMessage, {
        signal: AbortSignal.any([
          publicController.signal,
          internalController.signal,
        ]),
      });

      // 模拟取消操作
      document.getElementById(&quot;stopButton&quot;).addEventListener(&quot;click&quot;, () =&gt; {
        publicController.abort();
        console.log(&quot;停止监听消息事件&quot;);
      });

      // 也可以通过内部控制器取消
      setTimeout(() =&gt; {
        internalController.abort();
        console.log(&quot;内部控制器自动中止监听&quot;);
      }, 5000);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>创建了两个 <code>AbortController</code> 实例，分别为 <code>publicController</code> 和 <code>internalController</code>。</li>
<li>使用 WebSocket 建立连接，并在连接建立后发送一条消息。</li>
<li>为 WebSocket 的 <code>message</code> 事件添加监听器，并通过 <code>AbortSignal.any</code> 组合两个中止信号。</li>
<li>在页面中添加了一个按钮，当点击按钮时将调用 <code>publicController.abort()</code> 来停止监听消息事件。</li>
<li>另外，使用 <code>setTimeout</code> 模拟了一个内部控制器在 5 秒后自动中止监听操作。</li>
</ol>
<p>通过这种方式，可以灵活地组合多个中止信号，当任意一个信号触发时，相关的事件监听器都会被取消。</p>
<h2>取消流</h2>
<p>我们还可以使用 <code>AbortController</code> 和 <code>AbortSignal</code> 来取消流。</p>
<p>在下面个例子中，我们创建一个 <code>WritableStream</code>，并通过监听 <code>controller.signal</code> 的 <code>abort</code> 事件来处理流的中止操作。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;取消流操作示例&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button id=&quot;cancelButton&quot;&gt;取消写操作&lt;/button&gt;

    &lt;script&gt;
      async function example() {
        const abortController = new AbortController();

        const stream = new WritableStream({
          write(chunk, controller) {
            console.log(&quot;正在写入:&quot;, chunk);

            // 监听中止信号
            controller.signal.addEventListener(&quot;abort&quot;, () =&gt; {
              console.log(&quot;写操作被取消&quot;);
              // 处理流中止逻辑，例如清理资源或通知用户
            });
          },
          close() {
            console.log(&quot;写入完成&quot;);
          },
          abort(reason) {
            console.warn(&quot;写入中止:&quot;, reason);
          },
        });

        const writer = stream.getWriter();

        // 模拟写入操作
        writer.write(&quot;数据块 1&quot;);
        writer.write(&quot;数据块 2&quot;);

        // 保存 abortController 以便取消操作
        window.currentAbortController = abortController;
        writer.releaseLock(); // 创建新写操作前释放写锁

        // 监听取消按钮的点击事件
        document
          .getElementById(&quot;cancelButton&quot;)
          .addEventListener(&quot;click&quot;, async () =&gt; {
            if (window.currentAbortController) {
              await writer.abort();
              window.currentAbortController.abort();
              console.log(&quot;点击了取消写操作按钮&quot;);
            } else {
              console.log(&quot;没有正在进行的写操作&quot;);
            }
          });
      }

      example();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>WritableStream</code> 控制器暴露了 <code>signal</code> 属性，即同样的 <code>AbortSignal</code>。这样，我可以调用 <code>writer.abort()</code>，这会在流的 <code>write()</code> 方法中的 <code>controller.signal</code> 上冒泡触发中止事件。</p>
<h2>中止任何逻辑</h2>
<p>实际上 <code>AbortController</code> 的能力还不仅于此，我们可以借助它让任何逻辑变得可中止！</p>
<p>比如下面的例子，我们将 <code>AbortController</code> 添加到 Drizzle ORM 事务中，让我们能够一次取消多个事务。</p>
<pre><code class="language-js">import { TransactionRollbackError } from &quot;drizzle-orm&quot;;

function makeCancelableTransaction(db) {
  return (callback, options = {}) =&gt; {
    return db.transaction((tx) =&gt; {
      return new Promise((resolve, reject) =&gt; {
        options.signal?.addEventListener(&quot;abort&quot;, async () =&gt; {
          reject(new TransactionRollbackError());
        });

        return Promise.resolve(callback.call(this, tx)).then(resolve, reject);
      });
    });
  };
}
</code></pre>
<p><code>makeCancelableTransaction()</code> 函数接受一个数据库实例，并返回一个高阶事务函数，然后可以接受一个中止 <code>signal</code> 作为参数。</p>
<p>通过在 <code>signal</code> 实例上添加 <code>abort</code> 事件的监听器，我可以知道中止在何时发生。这个事件监听器会在中止事件触发时被调用，也就是在 <code>controller.abort()</code> 被调用时。因此，发生中止时，我可以通过返回一个 <code>TransactionRollbackError</code> 错误来回滚整个事务（这等同于调用 <code>tx.rollback()</code> 并抛出相同的错误）。</p>
<p>然后，我们在 Drizzle 中使用它。</p>
<pre><code class="language-js">const db = drizzle(options);

const controller = new AbortController();
const transaction = makeCancelableTransaction(db);

await transaction(
  async (tx) =&gt; {
    await tx
      .update(accounts)
      .set({ balance: sql`${accounts.balance} - 100.00` })
      .where(eq(users.name, &quot;Dan&quot;));
    await tx
      .update(accounts)
      .set({ balance: sql`${accounts.balance} + 100.00` })
      .where(eq(users.name, &quot;Andrew&quot;));
  },
  { signal: controller.signal }
);
</code></pre>
<p>我们调用了 <code>makeCancelableTransaction()</code> 工具函数，并传入 <code>db</code> 实例来创建一个自定义可中止事务。从现在开始，我可以像通常在 Drizzle 中一样使用这个自定义事务来执行多个数据库操作，还可以为其提供一个中止 <code>signal</code> ，以一次取消所有操作。</p>
<h2>中止错误处理</h2>
<p>每个中止事件都附带中止原因，这让我们能够进行更多的定制化，我们可以对不同的中止原因做出不同的反应。</p>
<p>中止原因是 <code>controller.abort()</code> 方法的可选参数。你可以在任何 <code>AbortSignal</code> 实例的 <code>reason</code> 属性中访问中止原因。</p>
<pre><code class="language-js">async function fetchData() {
  const controller = new AbortController();
  const signal = controller.signal;

  // 监听 abort 事件，并打印中止原因
  signal.addEventListener(&quot;abort&quot;, () =&gt; {
    console.log(&quot;请求中止原因:&quot;, signal.reason); // 打印自定义的中止原因
  });

  try {
    const response = await fetch(
      &quot;https://jsonplaceholder.typicode.com/posts/1&quot;,
      { signal }
    );
    const data = await response.json();
    console.log(&quot;请求成功:&quot;, data);
  } catch (error) {
    if (error.name === &quot;AbortError&quot;) {
      console.error(&quot;请求因中止被取消:&quot;, error.message);
    } else {
      console.error(&quot;请求出错:&quot;, error.message);
    }
  }

  // 保存 controller 以便取消操作
  window.currentAbortController = controller;
}

fetchData();

// 监听取消按钮的点击事件
document.getElementById(&quot;cancelButton&quot;).addEventListener(&quot;click&quot;, () =&gt; {
  if (window.currentAbortController) {
    window.currentAbortController.abort(&quot;用户取消了请求&quot;); // 提供自定义的中止原因
    console.log(&quot;点击了取消请求按钮&quot;);
  } else {
    console.log(&quot;没有正在进行的请求&quot;);
  }
});
</code></pre>
<p><code>reason</code> 参数可以是任何 JavaScript 值，所以我们可以传递字符串、错误，甚至对象。</p>
<h2>兼容性</h2>
<img src="../imgs/80/02.webp" />

<p><code>AbortController</code> 的兼容性非常好，很久之前就已经被纳入了 Web 兼容性 Baseline，从 2019 年 3 月起，就可在所有主流浏览器中使用了。</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // 滚动动画
      document.addEventListener('DOMContentLoaded', () => {
        // 为所有段落、标题和列表添加 fade-in 类
        const elements = document.querySelectorAll('.md p, .md h2, .md h3, .md ul, .md ol, .md img, .code-toolbar');
        elements.forEach(el => el.classList.add('fade-in'));

        // 为左侧导航项添加动画延迟
        const navItems = document.querySelectorAll('.layout__main_left ul li');
        navItems.forEach((item, index) => {
          item.style.setProperty('--i', index);
        });

        // 滚动时添加动画
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('visible');
              // 一旦元素显示，就停止观察它
              observer.unobserve(entry.target);
            }
          });
        }, {
          threshold: 0.1,
          rootMargin: '0px 0px -20px 0px' // 调整触发距离
        });

        // 延迟添加观察者，确保页面完全加载
        setTimeout(() => {
          elements.forEach(el => observer.observe(el));
        }, 100);

        // 确保初始可见区域的元素立即显示
        const checkInitialVisibility = () => {
          elements.forEach(el => {
            const rect = el.getBoundingClientRect();
            if (rect.top < window.innerHeight) {
              el.classList.add('visible');
            }
          });
        };
        
        checkInitialVisibility();
        
        // 平滑滚动到锚点
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
          anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
              target.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
              });
            }
          });
        });
      });

      const liActive = document.querySelector(".layout__main_left li.active");
      liActive.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest",
      });
      const imgs = document.querySelectorAll("img");
      imgs.forEach((img) => {
        img.onclick = () => {
          img.style.opacity = 0;
          let imgHove = document.querySelector(".img-hover");
          if (imgHove) imgHove.remove();
          const src = img.src;
          const html = `
            <div class="img-hover">
              <img src="${src}" />
            </div>
          `;
          document.body.insertAdjacentHTML("beforeend", html);
          document.body.style.overflow = "hidden";
          imgHove = document.querySelector(".img-hover");
          imgHove.onclick = () => {
            imgHove.remove();
            document.body.style.overflow = "initial";
            img.style.opacity = 1;
          };
        };
      });
      const headings = document.querySelectorAll(".md h2, .md h3");
      const navContainer = document.querySelector(".layout__main_map_content");
      const layoutMainMap = document.querySelector(".layout__main_map");
      if (!headings?.length) {
        layoutMainMap.style.display = "none";
      }
      headings.forEach((heading, index) => {
        const id = `heading-${index}`;
        heading.id = id;
        const link = document.createElement("a");
        link.href = `#${id}`;
        link.textContent =
          heading.tagName === "H2"
            ? `▪ ${heading.textContent}`
            : `· ${heading.textContent}`;
        link.title = link.textContent;
        link.style.display = "block";
        link.style.margin = "5px 0";
        link.style.color = heading.tagName === "H2" ? "blue" : "darkblue";
        link.style.cursor = "pointer";
        link.className = heading.tagName === "H2" ? "H2" : "H3";
        link.addEventListener("click", (event) => {
          event.preventDefault();
          document.getElementById(id).scrollIntoView({ behavior: "smooth" });
        });
        navContainer.appendChild(link);
      });
      const swicthDom = document.querySelector(".layout__main_map_swicth");
      const mapDom = document.querySelector(".layout__main_map");
      swicthDom.onclick = () => {
        mapDom.classList.toggle("show");
      };
      const swicthDom2 = document.querySelector(".layout__main_left-switch");
      const mapDom2 = document.querySelector(".layout__main_left");
      swicthDom2.onclick = () => {
        mapDom2.classList.toggle("show");
      };
    </script>
  </body>
</html>
