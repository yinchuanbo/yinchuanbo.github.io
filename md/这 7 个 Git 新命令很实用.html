<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>这 7 个 Git 新命令很实用</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>

  <body>
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 0">
          <div class="layout__main_left-switch"></div>
          <ul>
            <li class=""><a title="git如何仅复制某个commit的功能到当前分支" href="/md/git如何仅复制某个commit的功能到当前分支.html">08 git如何仅复制某个commit的功能到当前分支</a></li><li class="active"><a title="这 7 个 Git 新命令很实用" href="/md/这 7 个 Git 新命令很实用.html">07 这 7 个 Git 新命令很实用</a></li><li class=""><a title="如何撤销已提交的 Git 代码-已 push 和已 commit" href="/md/如何撤销已提交的 Git 代码-已 push 和已 commit.html">06 如何撤销已提交的 Git 代码-已 push 和已 commit</a></li><li class=""><a title="如何优雅地使用 git commit 命令" href="/md/如何优雅地使用 git commit 命令.html">05 如何优雅地使用 git commit 命令</a></li><li class=""><a title="git commit 时检查是否有中文字符并阻断" href="/md/git commit 时检查是否有中文字符并阻断.html">04 git commit 时检查是否有中文字符并阻断</a></li><li class=""><a title="Git 生成 patch 和应用 patch" href="/md/Git 生成 patch 和应用 patch.html">03 Git 生成 patch 和应用 patch</a></li><li class=""><a title="Git Worktree 让你无需切换分支" href="/md/Git Worktree 让你无需切换分支.html">02 Git Worktree 让你无需切换分支</a></li><li class=""><a title="git cherry-pick" href="/md/git cherry-pick.html">01 git cherry-pick</a></li>
          </ul>
        </div>
        <div
          style="order: 1"
          class="layout__main_right md "
        >
          <div class="page-header">
            
            <a href="/md/" class="back-button"
              ><svg t="1737007603776" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4546" width="200" height="200"><path d="M853.333333 245.333333H245.333333l93.866667-93.866666c12.8-12.8 12.8-34.133333 0-46.933334-12.8-12.8-34.133333-12.8-46.933333 0l-145.066667 145.066667c-12.8 12.8-12.8 34.133333 0 46.933333l145.066667 145.066667c6.4 6.4 14.933333 10.666667 23.466666 10.666667s17.066667-4.266667 23.466667-10.666667c12.8-12.8 12.8-34.133333 0-46.933333L256 311.466667h597.333333c6.4 0 10.666667 4.266667 10.666667 10.666666v426.666667c0 6.4-4.266667 10.666667-10.666667 10.666667H170.666667c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32h682.666666c40.533333 0 74.666667-34.133333 74.666667-74.666667V320c0-40.533333-34.133333-74.666667-74.666667-74.666667z" fill="#ffffff" p-id="4547"></path></svg></a>
            
            <h1>这 7 个 Git 新命令很实用</h1>
            <p class="time">HaoTian · 2024-12-28 20:29:58</p>
          </div>
          <p>自 Git 在 2005 年诞生以来，诸如 <code>clone</code>、<code>pull</code>、<code>push</code>、<code>merge</code>、<code>checkout</code> 和 <code>commit</code> 等核心命令便已存在，支撑着日常的开发工作。随着版本控制需求的演变，Git 持续迭代更新，引入了诸多增强功能和新命令。本文将聚焦于近年来新增的七个 Git 命令，探索它们如何进一步提升工作效率！</p>
<h2>git switch：安全切换分支</h2>
<p><code>git switch</code> 命令是在 Git 2.23.0 版本中引入的，以解决 <code>git checkout</code> 命令职责过重的问题，并使得 Git 的命令更加直观和易于理解。</p>
<p>在 Git 2.23 之前，<code>git checkout</code> 既用于切换分支，也用于还原文件内容，很容易引起混淆。通过将 <code>git checkout</code> 的功能拆分，Git 团队创建了两个新的、更专业的命令：</p>
<ul>
<li><code>git switch</code>：专门用于在分支之间进行切换。</li>
<li><code>git restore</code>：专门用于还原文件内容。</li>
</ul>
<p>使用 <code>git switch</code> 切换分支非常简单，以下是基本用法：</p>
<pre><code class="language-sh"># 切换到已存在的分支
$ git switch &lt;branch-name&gt;

# 创建并切换到新分支
$ git switch -c &lt;new-branch-name&gt;

# 从远程仓库创建并跟踪一个本地分支
$ git switch -c &lt;new-branch-name&gt; --track &lt;remote&gt;/&lt;branch-name&gt;

# 返回到上一个分支
$ git switch -
</code></pre>
<blockquote>
<p>注意：如果遇到错误信息 <code>&#39;switch&#39; is not a git command</code>，那么可能是因为 Git 版本低于 2.23.0。可以通过运行 <code>git --version</code> 来检查 Git 版本，并升级到最新版本以使用这些新特性。</p>
</blockquote>
<h2>git restore：安全撤销更改</h2>
<p><code>git restore</code> 命令同样是在 Git 2.23.0 版本中引入的，专门用于恢复工作目录中的文件内容。</p>
<p><code>git restore</code> 主要用来撤销工作目录中的更改，可以用来丢弃未提交的工作树修改、还原删除的文件，或者将文件重置为之前的某个提交状态。以下是 <code>git restore</code> 的基本用法：</p>
<pre><code class="language-sh"># 恢复工作目录中的文件到最近一次提交的状态
$ git restore &lt;file&gt;

# 从指定的提交中恢复文件到工作目录
$ git restore --source=&lt;commit&gt; &lt;file&gt;

# 取消暂存区的更改（类似于 git reset HEAD &lt;file&gt;）
$ git restore --staged &lt;file&gt;

# 恢复所有文件到指定的提交状态
$ git restore --source=&lt;commit&gt; .

# 恢复所有已删除的文件
$ git restore -w -- *

# 丢弃暂存区和工作目录中的更改（即恢复到指定的提交状态）
$ git restore --staged --worktree &lt;file&gt;
</code></pre>
<p>使用 <code>git restore</code> 时，可以选择性地指定 <code>--staged</code> 来影响暂存区，或者 <code>--worktree</code> 来影响工作目录。如果同时指定了这两个选项，则会同时影响暂存区和工作目录。</p>
<p><code>git restore</code> 是一个相对安全的操作，因为它不会改变分支的历史记录，它只会影响工作目录和/或暂存区。</p>
<h2>git worktree：同时在多个分支工作</h2>
<p><code>git worktree</code> 命令是在 Git 2.5 版本中引入的，它允许在同一个仓库中创建多个工作目录（worktrees），每个工作目录可以检出不同的分支或提交。这为开发者提供了同时处理多个任务的能力，比如在不同的分支上进行开发、测试，而不需要来回切换分支。</p>
<p>以下是 <code>git worktree</code> 的基本用法：</p>
<pre><code class="language-sh"># 添加一个新的工作目录，并检出指定分支
$ git worktree add &lt;path&gt; [&lt;branch&gt;]

# 列出所有的工作目录
$ git worktree list

# 移除一个工作目录（必须先确保该目录没有未提交的更改）
$ git worktree remove &lt;path&gt;

# 移动一个工作目录到新的位置
$ git worktree move &lt;current-path&gt; &lt;new-path&gt;
</code></pre>
<p>例如，如果想要添加一个新的工作目录来检出名为 <code>feature-branch</code> 的分支，可以这样做：</p>
<pre><code class="language-sh">$ git worktree add ../my-feature-worktree feature-branch
</code></pre>
<p>这将在 <code>../my-feature-worktree</code> 目录下创建一个新的工作目录，并检出 <code>feature-branch</code> 分支。</p>
<h2>git sparse-checkout：高效处理大型仓库</h2>
<p><code>git sparse-checkout</code> 是在 Git 2.25.0 版本中引入的，个功能是对之前存在的稀疏检出机制的一个重大改进。通过 <code>git sparse-checkout</code>，开发者可以更高效地克隆大型仓库，只检出部分文件或目录，而不是整个项目。</p>
<p>要启用 <code>sparse-checkout</code>，首先需要设置仓库以使用稀疏检出模式：</p>
<pre><code class="language-sh"># 启用 sparse-checkout 模式
$ git sparse-checkout init

# 设置你想要包括的模式或路径
$ git sparse-checkout set &lt;pattern&gt;...
</code></pre>
<p>例如，如果只想检出 <code>src</code> 目录及其子目录中的文件，可以这样做：</p>
<pre><code class="language-sh">$ git sparse-checkout set src/
</code></pre>
<p>如果想添加多个模式或路径，可以在 <code>set</code> 命令后列出所有路径，或者分多次调用该命令。</p>
<p>除了 <code>set</code> 命令，还可以使用 <code>add</code> 和 <code>list</code> 来管理稀疏检出模式：</p>
<pre><code class="language-sh"># 添加额外的路径到稀疏检出模式
$ git sparse-checkout add &lt;pattern&gt;...

# 列出现有的稀疏检出模式
$ git sparse-checkout list
</code></pre>
<p>如果不再需要稀疏检出模式，可以通过以下命令禁用它，并恢复完整的检出状态：</p>
<pre><code class="language-sh"># 禁用 sparse-checkout 模式并恢复完整检出
$ git sparse-checkout disable
</code></pre>
<h2>git range-diff：比较提交范围之间的更改</h2>
<p><code>git range-diff</code> 是在 Git 2.19.0 版本中引入的，用于比较两个提交范围之间的差异。它可以帮助开发者理解在一次变基（rebase）、合并（merge）或历史改写操作后，一系列提交发生了哪些变化。</p>
<p><code>git range-diff</code> 的基本用法如下：</p>
<pre><code class="language-sh"># 比较两个分支上的最近 n 个提交
$ git range-diff A~n..A B~n..B

# 或者更常见的用法是直接指定两个范围
$ git range-diff A..B C..D
</code></pre>
<p>这里的 <code>A..B</code> 和 <code>C..D</code> 分别表示两个不同的提交范围。例如，如果想比较 <code>feature</code> 分支在变基前后的差异，可以这样做：</p>
<pre><code class="language-sh"># 假设 origin/feature 是变基之前的远程分支状态
# 而 feature 是变基之后的本地分支状态
$ git range-diff origin/feature..feature~n feature~n..feature
</code></pre>
<p><code>git range-diff</code> 会输出每个提交的摘要信息，包括提交消息、作者、日期等，并高亮显示两个范围内的提交之间的差异。如果提交的内容完全相同，它将只显示提交消息并指出它们是相同的；如果有差异，则会详细列出差异之处。</p>
<h2>git maintenance：自动化仓库健康</h2>
<p><code>git maintenance</code>是在 Git 2.30.0 版本中引入的，用于管理和自动化各种维护任务的命令。这个命令旨在简化和优化仓库的维护工作，通过提供一组预定义的任务来帮助保持仓库的健康状态和高效性能。</p>
<p><code>git maintenance</code> 提供了几种子命令来管理不同的维护任务：</p>
<ul>
<li><strong>启用和禁用自动维护：</strong></li>
</ul>
<pre><code class="language-sh"># 启用自动维护
$ git maintenance start

# 禁用自动维护
$ git maintenance stop
</code></pre>
<ul>
<li><strong>执行一次性维护任务</strong>：手动触发一次性的维护任务，这对于在特定时间点（如大型提交之后）优化仓库非常有用。</li>
</ul>
<pre><code class="language-sh"># 执行所有配置的维护任务
$ git maintenance run

# 执行特定类型的维护任务
$ git maintenance run --task=&lt;task&gt;
</code></pre>
<p>常见的维护任务包括：</p>
<ul>
<li><p><code>gc</code>：运行完整的垃圾收集，包括压缩对象数据库。</p>
</li>
<li><p><code>commit-graph</code>：构建或更新提交图文件以加速提交历史查询。</p>
</li>
<li><p><code>loose-objects</code>：清理松散对象并将其打包。</p>
</li>
<li><p><code>incremental-repack</code>：逐步重新打包对象以优化存储。</p>
</li>
<li><p><code>prefetch</code>：预先获取远程分支的新数据，以加速未来的克隆和拉取操作。</p>
</li>
<li><p><strong>配置自动维护计划</strong>：可以通过配置文件设置哪些任务应该被定期执行以及它们的执行频率。例如，在 <code>.git/config</code> 文件中添加如下内容：</p>
</li>
</ul>
<pre><code class="language-sh">[maintenance &quot;daily&quot;]
    task = prefetch
    task = loose-objects
[maintenance &quot;hourly&quot;]
    task = commit-graph
[maintenance &quot;weekly&quot;]
    task = incremental-repack
[maintenance &quot;monthly&quot;]
    task = gc
</code></pre>
<p>然后启用这些计划：</p>
<pre><code class="language-sh">$ git maintenance start --schedule=daily
$ git maintenance start --schedule=hourly
$ git maintenance start --schedule=weekly
$ git maintenance start --schedule=monthly
</code></pre>
<h2>git log --remerge-diff：更好地理解合并</h2>
<p>从 Git 2.35 版本开始，可以使用 <code>git log --remerge-diff</code>  命令来更好地理解合并提交。通常情况下，合并提交会显示哪些分支被合并了，但并不总是能清晰地解释合并过程中引入的具体更改，特别是在解决合并冲突时所做的改动。</p>
<p><code>git log --remerge-diff</code>  通过重播记录的合并策略来重建合并提交，并展示该合并引入的确切更改。这对于调试合并冲突或审查复杂的合并历史非常有用。</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>
    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      const switchBtn = document.querySelector(".layout__main_left-switch");
      const left = document.querySelector(".layout__main_left");

      // li active 滚动到中间位置
      const liA = document.querySelector(".layout__main_left li.active");
      if (liA) {
        liA.scrollIntoView({
          behavior: "smooth", // 平滑滚动
          block: "center", // 垂直方向滚动到视口中间
        });
      }

      switchBtn.addEventListener("click", () => {
        left.classList.toggle("show");
      });

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }
    </script>
  </body>
</html>
