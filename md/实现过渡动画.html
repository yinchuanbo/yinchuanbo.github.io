<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>实现过渡动画</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>

  <body>
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 0">
          <div class="layout__main_left-switch"></div>
          <ul>
            <li class="active"><a title="实现过渡动画" href="/md/实现过渡动画.html">11 实现过渡动画</a></li><li class=""><a title="组件化进阶详解" href="/md/组件化进阶详解.html">10 组件化进阶详解</a></li><li class=""><a title="组件化基础详解" href="/md/组件化基础详解.html">09 组件化基础详解</a></li><li class=""><a title="组件化开发" href="/md/组件化开发.html">08 组件化开发</a></li><li class=""><a title="v-model和表单输入" href="/md/v-model和表单输入.html">07 v-model和表单输入</a></li><li class=""><a title="vue3 的 Options API" href="/md/vue3 的 Options API.html">06 vue3 的 Options API</a></li><li class=""><a title="模板语法和内置命令" href="/md/模板语法和内置命令.html">05 模板语法和内置命令</a></li><li class=""><a title="前端 vue 项目使用 ffmpeg 处理视频" href="/md/前端 vue 项目使用 ffmpeg 处理视频.html">04 前端 vue 项目使用 ffmpeg 处理视频</a></li><li class=""><a title="Vue Router 4 的 scrollBehavior 方法" href="/md/Vue Router 4 的 scrollBehavior 方法.html">03 Vue Router 4 的 scrollBehavior 方法</a></li><li class=""><a title="浅浅聊一下 vue 中的 nextTick 的实现原理" href="/md/浅浅聊一下 vue 中的 nextTick 的实现原理.html">02 浅浅聊一下 vue 中的 nextTick 的实现原理</a></li><li class=""><a title="Vue3.x 生态最能打的组合" href="/md/Vue3.x 生态最能打的组合.html">01 Vue3.x 生态最能打的组合</a></li>
          </ul>
        </div>
        <div
          style="order: 1"
          class="layout__main_right md "
        >
          <div class="page-header">
            
            <a href="/md/" class="back-button"
              ><svg t="1737007603776" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4546" width="200" height="200"><path d="M853.333333 245.333333H245.333333l93.866667-93.866666c12.8-12.8 12.8-34.133333 0-46.933334-12.8-12.8-34.133333-12.8-46.933333 0l-145.066667 145.066667c-12.8 12.8-12.8 34.133333 0 46.933333l145.066667 145.066667c6.4 6.4 14.933333 10.666667 23.466666 10.666667s17.066667-4.266667 23.466667-10.666667c12.8-12.8 12.8-34.133333 0-46.933333L256 311.466667h597.333333c6.4 0 10.666667 4.266667 10.666667 10.666666v426.666667c0 6.4-4.266667 10.666667-10.666667 10.666667H170.666667c-17.066667 0-32 14.933333-32 32s14.933333 32 32 32h682.666666c40.533333 0 74.666667-34.133333 74.666667-74.666667V320c0-40.533333-34.133333-74.666667-74.666667-74.666667z" fill="#ffffff" p-id="4547"></path></svg></a>
            
            <h1>实现过渡动画</h1>
            <p class="time">HaoTian · 2025-01-17 11:08:13</p>
          </div>
          <h2>基本过渡动画</h2>
<h3>认识过渡动画</h3>
<p>在开发中，为了增强用户体验，我们通常会为组件的显示和隐藏添加一些过渡动画，下面介绍 Vue3 和 React 是如何实现过渡动画的。</p>
<p>(1) React 框架本身没有提供动画相关的 API，因此在使用过渡动画的时候需要引入第三方库，比如 react-transition-group。</p>
<p>(2) Vue3 框架本身提供了动画相关的 API，因此在使用过渡动画的时候不需要引入第三方库。</p>
<ul>
<li>App.vue 组件，通过 v-if 控制显示和隐藏 <code>&lt;h4&gt;</code> 元素</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;show = !show&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;h4 v-if=&quot;show&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;你好，Vue3&lt;/h4&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        show: true,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>上面代码是没有过渡效果的，为了实现单个元素或组件的过渡动画效果，在 Vue3 中，可以使用内置组件 <code>&lt;transition&gt;</code>。</p>
<p>改组件是对 CSS 中 transition 属性的封装，在<strong>条件渲染（v-if）、条件展示（v-show）、动态组件，以及组件根节点</strong>等情况下，都可以为任何元素和组件添加进入/离开过渡效果。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;show = !show&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition name=&quot;why&quot;&gt;
      &lt;h4 v-if=&quot;show&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;
        你好，Vue3
      &lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        show: true,
      };
    },
  };
&lt;/script&gt;
&lt;style scoped&gt;
  /* h4 元素进入之前和离开之后应用的样式 */
  .why-enter-from,
  .why-leave-to {
    opacity: 0;
  }
  /* h4 元素开始进入和离开时应用的样式 */
  .why-enter-to,
  .why-leave-from {
    opacity: 1;
  }
  /* 定义过渡动画的持续时间 */
  .why-enter-active,
  .why-leave-active {
    transition: opacity 2s ease;
  }
&lt;/style&gt;
</code></pre>
<h3>过渡动画特有的类</h3>
<p>在前面的案例中，我们在 <code>&lt;style&gt;</code> 标签中编写了很多类（class），例如 why-enter-from、why-enter-to 等，实际上，vue3 过渡动画的实现原理是：在适当的时机，会自动在这些 class 之间来回切换，以应用不同的样式。</p>
<p>(1) v-enter-from: 定义进入过渡的开始状态，在元素被插入之前生效，在元素被插入之后的下一帧移除。</p>
<p>(2) v-enter-active: 定义进入过的生效时的状态，在整体进入过渡的阶段中应用。在元素被插入之前生效，在过渡/动画完成之后移除。<strong>这个类可以被定义进入过渡的过程时间、延迟和曲线函数等</strong></p>
<p>(3) v-enter-to: 定义进入过渡的结束状态，在元素被插入之后下一帧生效（与此同时 v-enter-from 被移除)),在过渡/动画完成之后移除。</p>
<p>(4) v-leave-from: 定义离开过渡的开始状态，在离开过渡被触发时立刻生效，下一帧被移除。</p>
<p>(5) v-leave-active: 定义离开过渡生效时的状态，在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。<strong>这个类可以被定义离开过渡的过程时间、延迟和曲线函数等</strong></p>
<p>(6) v-leave-to: 定义离开过渡的结束状态，在离开过渡被触发之后下一帧生效（与此同时 v-leave-from 被删除）,在过渡/动画完成之后移除。</p>
<p><strong>过渡动画的生命周期如下：</strong></p>
<img src="../imgs/136/01.png" />

<blockquote>
<p>需要注意的是：如果 <code>&lt;transition&gt; 组件的 name 属性未指定，则默认动画类名前缀为 v-</code></p>
</blockquote>
<h3>CSS 的 Animation 动画</h3>
<p>animation 属性也可以实现过渡动画效果</p>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;show = !show&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition name=&quot;why&quot;&gt;
      &lt;h4 v-if=&quot;show&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;
        你好，Vue3
      &lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        show: true,
      };
    },
  };
&lt;/script&gt;
&lt;style scoped&gt;
  .why-enter-active {
    animation: bounce 1s ease;
  }
  .why-leave-active {
    /* 离开的时候，反向执行动画，有一个缩小的效果 */
    animation: bounce 1s ease reverse;
  }
  @keyframes bounce {
    0% {
      transform: scale(0);
    }
    50% {
      transform: scale(1.2);
    }
    100% {
      transform: scale(1);
    }
  }
&lt;/style&gt;
</code></pre>
<h3>Transition 组件的常见属性</h3>
<ul>
<li><p>name: 过渡动画的名称，默认值为 v-</p>
</li>
<li><p>type: 指定过渡类型，可选值为 transition（默认） 或 animation</p>
</li>
<li><p>mode: 指定过渡模式，可选值为 in-out、out-in，默认为空</p>
</li>
<li><p>appear: 指定是否在初始渲染时应用过渡效果，默认为 false</p>
</li>
</ul>
<p><strong>1. type 属性：实现同时使用过渡和动画</strong></p>
<p>为了监听动画的完成，Vue3 内部会监听 transitionend 或 animationend 事件，最终监听哪一个事件取决于元素应用的 CSS 规则，</p>
<p>例如，如果仅使用了 transition 或 animation 中的某一个，Vue3 能够自动识别事件类型，并设置相应的监听器。</p>
<p>但是如果同时使用了 transition 和 animation，就需要在 <code>&lt;transition&gt;</code> 组件上设置 type 属性为 animation 或 transition，明确告诉 Vue3 监听事件的类型，如果未设置 type 属性，那么 Vue3 将自动检测持续时间较长的动画对应的事件类型。</p>
<p>例如，如果 transition 的持续时间比 animation 长，则自动监听 transitionend 事件，否则监听 animationend 事件。</p>
<pre><code class="language-html">&lt;!-- App.vue 同时演示使用 transition 和 animation --&gt;
&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition name=&quot;why&quot; type=&quot;transition&quot;&gt;
      &lt;h4 v-if=&quot;isShow&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;
        你好，Vue3
      &lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        isShow: true,
      };
    },
  };
&lt;/script&gt;
&lt;style scoped&gt;
  /* transition 动画 */
  .why-enter-from,
  .why-leave-to {
    opacity: 0;
  }
  .why-enter-active,
  .why-leave-active {
    transition: opacity 1s ease;
  }
  /* animation 动画 */
  .why-enter-active {
    animation: bounce 1s ease;
  }
  .why-leave-active {
    animation: bounce 1s ease reverse;
  }
&lt;/style&gt;
</code></pre>
<p>点击 “显示/隐藏” 按钮，<code>&lt;h4&gt;</code> 元素会发生透明度和缩放的变化。</p>
<p><strong>2. mode 属性：指定过渡模式</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition name=&quot;why&quot;&gt;
      &lt;h4 v-if=&quot;isShow&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;Hello&lt;/h4&gt;
      &lt;h4 v-else style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;World&lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        isShow: true,
      };
    },
  };
&lt;/script&gt;
&lt;style scoped&gt;
  .why-enter-from,
  .why-leave-to {
    opacity: 0;
  }
  .why-enter-active,
  .why-leave-active {
    transition: opacity 1s ease;
  }
&lt;/style&gt;
</code></pre>
<p>点击 “显示/隐藏” 按钮，当第一个 <code>&lt;h4&gt;</code> 元素在隐藏时，第二个 <code>&lt;h4&gt;</code> 元素会立即显示出来，没有过渡效果。</p>
<p>如果希望两个元素都有过渡效果，需要为 <code>&lt;transition&gt;</code> 组件添加 mode 属性，指定过渡模式</p>
<ul>
<li><p><code>mode=&quot;in-out&quot;</code>: 新元素先进行过渡，完成之后当前元素过渡离开。</p>
</li>
<li><p><code>mode=&quot;out-in&quot;</code>: 当前元素先进行过渡，完成之后新元素过渡进入。</p>
</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;!-- ... --&gt;
    &lt;transition name=&quot;why&quot; mode=&quot;out-in&quot;&gt;
      &lt;!-- ... --&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;!-- ... --&gt;
</code></pre>
<p>上述案例同样适用<strong>动态组件</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow =!isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;!-- 切换显示和隐藏动态组件 --&gt;
    &lt;transition name=&quot;why&quot; mode=&quot;out-in&quot;&gt;
      &lt;component :is=&quot;isShow ? &#39;home&#39; : &#39;about&#39;&quot;&gt;&lt;/component&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;!-- ... --&gt;
</code></pre>
<p><strong>3. appear 属性：指定初次渲染的过渡动画</strong></p>
<p>默认情况下，上述案例在首次渲染时均没有过渡动画效果，如果希望在首次渲染时也有过渡动画效果，可以为 <code>&lt;transition&gt;</code> 组件添加 appear 属性，指定是否在初始渲染时应用过渡效果。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;!-- ... --&gt;
    &lt;!-- appear 是 :appear=&quot;true&quot; 的缩写 --&gt;
    &lt;transition name=&quot;why&quot; mode=&quot;out-in&quot; appear&gt;
      &lt;component :is=&quot;isShow ? &#39;home&#39; : &#39;about&#39;&quot;&gt;&lt;/component&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;!-- ... --&gt;
</code></pre>
<h2>第三方库动画库</h2>
<h3>Animate.css 动画库</h3>
<p><strong>1. Animate.css 动画库的基本使用</strong></p>
<p>安装：</p>
<pre><code class="language-sh">npm i animate.css
</code></pre>
<p>main.js 中引入：</p>
<pre><code class="language-js">import &quot;animate.css&quot;;
createApp(App).mount(&quot;#app&quot;);
</code></pre>
<p>使用：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition name=&quot;why&quot; appear&gt;
      &lt;h4 v-if=&quot;isShow&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;
        Hello World
      &lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        isShow: true,
      };
    },
  };
&lt;/script&gt;
&lt;style scoped&gt;
  .why-enter-active {
    /* backInLeft 从左边进入的动画 */
    animation: backInLeft 1s ease-in;
  }
  .why-leave-active {
    /* backOutRight 从右边离开的动画 */
    animation: backOutRight 1s ease-in;
  }
&lt;/style&gt;
</code></pre>
<p>最终效果：在浏览器中首次渲染时就会有 backInLeft 动画效果。单击“显示/隐藏”按钮时,也会出现 backInLeft 和 backOutRight 的动画效果，</p>
<p><strong>2. 自定义过渡类名</strong></p>
<p>在 Vue3 中，可以使用 <code>&lt;transition&gt;</code> 组件的 name 属性指定动画类名的前缀，除此之外，还可以通过以下属性来自定义过渡类名：</p>
<ul>
<li><p><code>enter-from-class</code>: 自定义进入过渡的开始状态的类名</p>
</li>
<li><p><code>enter-active-class</code>: 自定义进入过渡生效时的状态的类名</p>
</li>
<li><p><code>enter-to-class</code>: 自定义进入过渡的结束状态的类名</p>
</li>
<li><p><code>leave-from-class</code>: 自定义离开过渡的开始状态的类名</p>
</li>
<li><p><code>leave-active-class</code>: 自定义离开过渡生效时的状态的类名</p>
</li>
<li><p><code>leave-to-class</code>: 自定义离开过渡的结束状态的类名</p>
</li>
</ul>
<p>它们的优先级高于普通的类名，这在 Vue3 的过渡系统和其他第三方 CSS 动画库结合使用时十分有用。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition
      enter-active-class=&quot;animate__animated animate__backInLeft&quot;
      leave-active-class=&quot;animate__animated animate__backOutRight&quot;
    &gt;
      &lt;h4 v-if=&quot;isShow&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;
        Hello World
      &lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        isShow: true,
      };
    },
  };
&lt;/script&gt;
&lt;style scoped&gt;
  /* 不需要再编写样式了 */
&lt;/style&gt;
</code></pre>
<h3>GSAP 动画库</h3>
<p>GSAP 是一个 JavaScript 动画库，它提供了一系列的动画效果，可以轻松地实现过渡动画效果</p>
<p>安装：</p>
<pre><code class="language-sh">npm i gsap
</code></pre>
<p><strong>1. <code>&lt;transition&gt;</code> 组件的事件和 JavaScript 钩子</strong></p>
<p>在使用 gasp 之前，需要先了解一下 <code>&lt;transition&gt;</code> 组件的事件和 JavaScript 钩子，</p>
<p>这些钩子可以帮助我们监听动画执行到什么阶段，从而在钩子函数中使用 gsap 实现动画效果。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow =!isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition
      :appear=&quot;true&quot;
      @before-enter=&quot;beforeEnter&quot;
      @enter=&quot;enter&quot;
      @after-enter=&quot;afterEnter&quot;
      @before-leave=&quot;beforeLeave&quot;
      @leave=&quot;leave&quot;
      @after-leave=&quot;afterLeave&quot;
    &gt;
      &lt;h4 v-if=&quot;isShow&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;
        Hello World
      &lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        isShow: true,
      };
    },
    methods: {
      beforeEnter(el) {
        // 1. 在元素被插入 DOM 之前被调用
        console.log(&quot;beforeEnter&quot;, el);
      },
      // el 表示当前 DOM 对象，done 表示动画结束的回调函数
      enter(el, done) {
        // 2. 在元素被插入 DOM 之后的下一帧被调用
        console.log(&quot;enter&quot;, el);
        done();
      },
      afterEnter(el) {
        //3. 当进入过渡完成时调用
        console.log(&quot;afterEnter&quot;, el);
      },
      beforeLeave(el) {
        // 4. 在 leave 钩子之前调用
        console.log(&quot;beforeLeave&quot;, el);
      },
      leave(el, done) {
        // 5. 在离开过渡开始时调用
        console.log(&quot;leave&quot;, el);
        done();
      },
      // 6. 在离开过渡完成，且元素已从 DOM 中移除时调用
      afterLeave(el) {
        console.log(&quot;afterLeave&quot;, el);
      },
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>2. gsap 动画库的使用</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow =!isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;!--
      :css=&quot;false&quot; 表示 Js 全权负责控制动画的过渡，在这种情况下，对 @enter 和 @leave 钩子来说，调用回调函数 done 就是必需的。
    --&gt;
    &lt;transition @enter=&quot;enter&quot; @leave=&quot;leave&quot; :css=&quot;false&quot;&gt;
      &lt;h4 v-if=&quot;isShow&quot; style=&quot;border: 1px solid #ddd; width: 100px&quot;&gt;
        Hello World
      &lt;/h4&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import gsap from &quot;gsap&quot;;
  export default {
    data() {
      return {
        isShow: true,
      };
    },
    methods: {
      enter(el, done) {
        gsap.from(el, {
          scale: 0,
          x: 200,
          onComplete: done, // 调用回调函数 done 表示过渡结束
        });
      },
      leave(el, done) {
        gsap.to(el, {
          scale: 0,
          x: 200,
          onComplete: done,
        });
      },
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>3. gsap 实现数字变化效果</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;input type=&quot;number&quot; v-model=&quot;counter&quot; /&gt;
    &lt;h2&gt;当前计数：{{ showNumber.toFixed(0) }}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import gsap from &quot;gsap&quot;;
  export default {
    data() {
      return {
        counter: 1,
        showNumber: 0,
      };
    },
    watch: {
      counter(newValue) {
        // this 为目标对象，这里是 Vue 实例
        gasp.to(this, {
          showNumber: newValue,
          duration: 1,
          ease: &quot;power1.out&quot;,
        });
      },
    },
  };
&lt;/script&gt;
</code></pre>
<h2>列表中的过渡动画</h2>
<p>如果我们需要为一个列表添加过渡动画，或者希望在该列表中添加、删除数据时也有动画，就需要使用内置组件 <code>&lt;transition-group&gt;</code>。</p>
<p>与 <code>&lt;transition&gt;</code> 基本相同，<code>&lt;transition-group&gt;</code> 也支持 props、Css 过渡类和 JavaScript 钩子监听器，但是二者有以下几点区别：</p>
<p>(1) 默认情况下，<code>&lt;transition-group&gt;</code> 不会渲染一个容器元素，但可通过传入 tag 属性指定一个元素作为容器元素进行渲染。</p>
<p>(2) 过渡模式在这里不可用，因为不再是在互斥的元素之间进行切换</p>
<p>(3) 列表中的每个元素都必须有一个唯一的 key 属性，用于标识每个元素的唯一性。</p>
<p>(4) CSS 过渡类会背应用到列表内的元素上，而不是容器元素上。</p>
<h3>TransitionGroup 的基本使用</h3>
<p>下面通过一个案例学习：</p>
<p>(1) 有两个按钮，“添加数字” 和 “删除数字”，还要显示一列数字</p>
<p>(2) 当单击 “添加数字” 按钮时，会在列表中添加一个数字，当单击 “删除数字” 按钮时，会删除列表中的某个数字</p>
<p>(3) 在添加和删除数字的过程中，为添加和删除的数字添加过渡效果</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addNum&quot;&gt;添加数字&lt;/button&gt;
    &lt;button @click=&quot;removeNum&quot;&gt;删除数字&lt;/button&gt;
    &lt;!-- tag=&quot;p&quot; 指定 p 元素作为容器元素来渲染  --&gt;
    &lt;!--
      所有的 span 元素都会被包裹在 p 元素中，
    --&gt;
    &lt;transition-group name=&quot;why&quot; tag=&quot;p&quot;&gt;
      &lt;span v-for=&quot;item in numbers&quot; :key=&quot;item&quot; :class=&quot;item&quot;&gt;{{item}}&lt;/span&gt;
    &lt;/transition-group&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        numberCounter: 10,
      };
    },
    methods: {
      addNum() {
        // 1. 在随机位置上添加一个数字
        this.numbers.splice(this.randomIndex(), 0, this.numberCounter++);
      },
      removeNum() {
        // 2. 在随机位置上删除一个数字
        this.numbers.splice(this.randomIndex(), 1);
      },
      randomIndex() {
        return Math.floor(Math.random() * this.numbers.length);
      },
    },
  };
&lt;/script&gt;
&lt;style scoped&gt;
  .item {
    margin-right: 10px;
  }
  .why-enter-from,
  .why-leave-to {
    opacity: 0;
    transform: translateY(30px);
  }
  .why-enter-active,
  .why-leave-active {
    transition: all 1s ease;
  }
&lt;/style&gt;
</code></pre>
<p>当点击 “添加数字” 按钮时，会在 <code>&lt;p&gt;</code> 元素中被插入一个新的 <code>&lt;span&gt;</code> 元素，同时会应用 <code>why-enter-from</code> 定义的动画，</p>
<p>当点击 “删除数字” 按钮时，会在 <code>&lt;p&gt;</code> 元素中被删除一个 <code>&lt;span&gt;</code> 元素，同时会应用 <code>why-leave-to</code> 定义的动画。</p>
<p>效果：</p>
<p>当点击 “添加数字” 和 “删除数字” 按钮时，<code>&lt;span&gt;</code> 元素会有透明度变化效果，但是使用 transform 移动 <code>&lt;span&gt;</code> 元素的动画并没有这种效果，因为 <code>&lt;span&gt;</code> 这种 inline 元素不支持 transform。如果要让 <code>&lt;span&gt;</code> 元素可以移动，可以将其修改为 inline-block 类型。</p>
<pre><code class="language-css">.item {
  margin-right: 10px;
  display: inline-block;
}
</code></pre>
<h3>列表元素过渡动画</h3>
<p>在上述案例中，尽管新增或删除的节点都具有动画效果，但其他需要左右移动的节点并没有动画效果。针对这种情况，我们可以使用新增的 v-move 类。当然，也可以像之前一样，使用 <code>name=&quot;xxx&quot;</code> 自定义前缀，例如 <code>xxx-move</code>。v-move 类会在<span>元素改变位置的过程中被应用，从而实现动画效果。</p>
<p>修改 App.wue 组件中的样式，添加 why-move 类和对应的过渡样式，代码如下所示:</p>
<pre><code class="language-html">&lt;style scoped&gt;
  /* .... */
  .why-move {
    /* 为需要移动的 span 元素添加过渡效果 */
    transition: transform 1s ease;
  }
&lt;/style&gt;
</code></pre>
<p>保存代码，在浏览器中单击 “添加数字” 按钮，其他需要向右移动的元素都会有过渡动画。</p>
<p>但是，当单击 “删除数字” 按钮时，其他需要向左移动的元素没有过渡动画。这是因为在删除 <code>&lt;span&gt;</code> 元素时,该元素在未移出列表时仍会占据宽度，导致其他 <code>&lt;span&gt;</code> 元素无法向左移动。如果想要为向左移动的元素添加动画，可以将被删除的 <code>&lt;span&gt;</code> 元素脱离标准文档流，这样它的宽度就不会占据列表位置。</p>
<p>修改 App.vue 组件中的样式,添加 why-leave-active 类和 position 属性，以使将要删除的 span 元素脱离标准文档流，代码如下所示:</p>
<pre><code class="language-html">&lt;style scoped&gt;
  .why-move {
    transition: transform 1s ease;
  }
  .why-leave-active {
    position: absolute;
  }
&lt;/style&gt;
</code></pre>
<p>保存代码，在浏览器中单击 “添加数字” 或 “删除数字” 按钮，可以发现其他需要向右或向左移动的节点都有过渡动画了。</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>
    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      const switchBtn = document.querySelector(".layout__main_left-switch");
      const left = document.querySelector(".layout__main_left");

      // li active 滚动到中间位置
      const liA = document.querySelector(".layout__main_left li.active");
      if (liA) {
        liA.scrollIntoView({
          behavior: "smooth", // 平滑滚动
          block: "center", // 垂直方向滚动到视口中间
        });
      }

      switchBtn.addEventListener("click", () => {
        left.classList.toggle("show");
      });

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }
    </script>
  </body>
</html>
