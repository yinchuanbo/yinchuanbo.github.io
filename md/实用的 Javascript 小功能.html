<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>实用的 Javascript 小功能</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link id="prismTheme" rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from { transform: translateY(-20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700B3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
</head>

<body class="fade-in">
    <button class="toggle-sidebar" id="toggleSidebar" aria-label="Toggle Sidebar">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
    
    <div class="app-container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <button class="toggle-sidebar" id="toggleSidebar">
                    <span></span>
                </button>
            </div>
            <div class="sidebar-content">
                <div class="nav-section">
                    <li class=""><a title="15个 JavaScript 代码规范" href="/md/15个 JavaScript 代码规范.html">60 15个 JavaScript 代码规范</a></li><li class=""><a title="8个 JavaScript 错误处理技巧 Bug 减少百分之 75" href="/md/8个 JavaScript 错误处理技巧 Bug 减少百分之 75.html">59 8个 JavaScript 错误处理技巧 Bug 减少百分之 75</a></li><li class=""><a title="WebWorker、SharedWorker 和 ServiceWorker 还在傻傻分不清" href="/md/WebWorker、SharedWorker 和 ServiceWorker 还在傻傻分不清.html">58 WebWorker、SharedWorker 和 ServiceWorker 还在傻傻分不清</a></li><li class=""><a title="用 JavaScript 实现 Live2D 虚拟人口型同步" href="/md/用 JavaScript 实现 Live2D 虚拟人口型同步.html">57 用 JavaScript 实现 Live2D 虚拟人口型同步</a></li><li class=""><a title="ES6 中引入的 new.target 你知道吗" href="/md/ES6 中引入的 new.target 你知道吗.html">56 ES6 中引入的 new.target 你知道吗</a></li><li class=""><a title="ES 新特性全解密" href="/md/ES 新特性全解密.html">55 ES 新特性全解密</a></li><li class=""><a title="前端 reduce 函数100 种使用方法整理" href="/md/前端 reduce 函数100 种使用方法整理.html">54 前端 reduce 函数100 种使用方法整理</a></li><li class=""><a title="proxy 和 Object.defineProperty()" href="/md/proxy 和 Object.defineProperty().html">53 proxy 和 Object.defineProperty()</a></li><li class=""><a title="为何说 AbortController 是前端一把利剑" href="/md/为何说 AbortController 是前端一把利剑.html">52 为何说 AbortController 是前端一把利剑</a></li><li class=""><a title="前端 Money 类" href="/md/前端 Money 类.html">51 前端 Money 类</a></li><li class=""><a title="理解JS里的WeakMap" href="/md/理解JS里的WeakMap.html">50 理解JS里的WeakMap</a></li><li class=""><a title="token无感刷新的基本实现" href="/md/token无感刷新的基本实现.html">49 token无感刷新的基本实现</a></li><li class=""><a title="前端中的 File 和 Blob两个对象到底有什么不同" href="/md/前端中的 File 和 Blob两个对象到底有什么不同.html">48 前端中的 File 和 Blob两个对象到底有什么不同</a></li><li class=""><a title="js 检测网页空闲状态(一定时间内无操作)" href="/md/js 检测网页空闲状态(一定时间内无操作).html">47 js 检测网页空闲状态(一定时间内无操作)</a></li><li class=""><a title="Javascirpt 时区" href="/md/Javascirpt 时区.html">46 Javascirpt 时区</a></li><li class="active"><a title="实用的 Javascript 小功能" href="/md/实用的 Javascript 小功能.html">45 实用的 Javascript 小功能</a></li><li class=""><a title="前端实现直接粘贴图片到 html 页面" href="/md/前端实现直接粘贴图片到 html 页面.html">44 前端实现直接粘贴图片到 html 页面</a></li><li class=""><a title="前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器" href="/md/前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器.html">43 前端如何静悄悄录制用户的操作过程，静悄悄上传到服务器</a></li><li class=""><a title="JS 中数组的 map 鲜为人知但绝妙的使用方法" href="/md/JS 中数组的 map 鲜为人知但绝妙的使用方法.html">42 JS 中数组的 map 鲜为人知但绝妙的使用方法</a></li><li class=""><a title="在 Web 中判断页面是不是刷新" href="/md/在 Web 中判断页面是不是刷新.html">41 在 Web 中判断页面是不是刷新</a></li><li class=""><a title="Js 小技巧" href="/md/Js 小技巧.html">40 Js 小技巧</a></li><li class=""><a title="split 方法我算是白学了" href="/md/split 方法我算是白学了.html">39 split 方法我算是白学了</a></li><li class=""><a title="拼接 URL" href="/md/拼接 URL.html">38 拼接 URL</a></li><li class=""><a title="ES14 中 5 个最具变革性的 JavaScript 特性" href="/md/ES14 中 5 个最具变革性的 JavaScript 特性.html">37 ES14 中 5 个最具变革性的 JavaScript 特性</a></li><li class=""><a title="JavaScript 中设置器和获取器" href="/md/JavaScript 中设置器和获取器.html">36 JavaScript 中设置器和获取器</a></li><li class=""><a title="非常强大的标准 JavaScript API - AbortController" href="/md/非常强大的标准 JavaScript API - AbortController.html">35 非常强大的标准 JavaScript API - AbortController</a></li><li class=""><a title="掌握 JavaScript 中的 Call 和 Apply" href="/md/掌握 JavaScript 中的 Call 和 Apply.html">34 掌握 JavaScript 中的 Call 和 Apply</a></li><li class=""><a title="一文整懂事件对象 event 的常用方法" href="/md/一文整懂事件对象 event 的常用方法.html">33 一文整懂事件对象 event 的常用方法</a></li><li class=""><a title="7 种开发人员都应该知道的高级 JavaScript 技术" href="/md/7 种开发人员都应该知道的高级 JavaScript 技术.html">32 7 种开发人员都应该知道的高级 JavaScript 技术</a></li><li class=""><a title="实现基于用户操作系统偏好的明暗主题切换" href="/md/实现基于用户操作系统偏好的明暗主题切换.html">31 实现基于用户操作系统偏好的明暗主题切换</a></li><li class=""><a title="JavaScript 原生实现图片复制与粘贴" href="/md/JavaScript 原生实现图片复制与粘贴.html">30 JavaScript 原生实现图片复制与粘贴</a></li><li class=""><a title="高精度实现定时器" href="/md/高精度实现定时器.html">29 高精度实现定时器</a></li><li class=""><a title="获取上传进度的几种方式" href="/md/获取上传进度的几种方式.html">28 获取上传进度的几种方式</a></li><li class=""><a title="聊聊禁止页面滚动的几种方法" href="/md/聊聊禁止页面滚动的几种方法.html">27 聊聊禁止页面滚动的几种方法</a></li><li class=""><a title="缓存 http 错误，避免多次报错提示" href="/md/缓存 http 错误，避免多次报错提示.html">26 缓存 http 错误，避免多次报错提示</a></li><li class=""><a title="文件操作" href="/md/文件操作.html">25 文件操作</a></li><li class=""><a title="数据类型判断方法" href="/md/数据类型判断方法.html">24 数据类型判断方法</a></li><li class=""><a title="宏任务和微任务" href="/md/宏任务和微任务.html">23 宏任务和微任务</a></li><li class=""><a title="十个超级好用的 Js 技巧" href="/md/十个超级好用的 Js 技巧.html">22 十个超级好用的 Js 技巧</a></li><li class=""><a title="前端的网络状态" href="/md/前端的网络状态.html">21 前端的网络状态</a></li><li class=""><a title="使用 JavaScript 加载字体" href="/md/使用 JavaScript 加载字体.html">20 使用 JavaScript 加载字体</a></li><li class=""><a title="你需要知道的 Symbols" href="/md/你需要知道的 Symbols.html">19 你需要知道的 Symbols</a></li><li class=""><a title="Set 和 WeakSet 的用法和区别" href="/md/Set 和 WeakSet 的用法和区别.html">18 Set 和 WeakSet 的用法和区别</a></li><li class=""><a title="sessionStorage 能在多个标签页之间共享数据吗" href="/md/sessionStorage 能在多个标签页之间共享数据吗.html">17 sessionStorage 能在多个标签页之间共享数据吗</a></li><li class=""><a title="scrollIntoview" href="/md/scrollIntoview.html">16 scrollIntoview</a></li><li class=""><a title="reduce 的高级用法" href="/md/reduce 的高级用法.html">15 reduce 的高级用法</a></li><li class=""><a title="js 小众且好用的技巧" href="/md/js 小众且好用的技巧.html">14 js 小众且好用的技巧</a></li><li class=""><a title="js 如何监听一个变量改变" href="/md/js 如何监听一个变量改变.html">13 js 如何监听一个变量改变</a></li><li class=""><a title="javascript 奇葩行为大赏" href="/md/javascript 奇葩行为大赏.html">12 javascript 奇葩行为大赏</a></li><li class=""><a title="FileReader" href="/md/FileReader.html">11 FileReader</a></li><li class=""><a title="EventSource" href="/md/EventSource.html">10 EventSource</a></li><li class=""><a title="document.referrer 拦截问题" href="/md/document.referrer 拦截问题.html">09 document.referrer 拦截问题</a></li><li class=""><a title="7 个 Promise 静态方法" href="/md/7 个 Promise 静态方法.html">08 7 个 Promise 静态方法</a></li><li class=""><a title="谈谈前端路由的实现原理 hash ＆ history" href="/md/谈谈前端路由的实现原理 hash ＆ history.html">07 谈谈前端路由的实现原理 hash ＆ history</a></li><li class=""><a title="属性的 getter 和 setter" href="/md/属性的 getter 和 setter.html">06 属性的 getter 和 setter</a></li><li class=""><a title="高效检查 JS 对象中的键是否存在" href="/md/高效检查 JS 对象中的键是否存在.html">05 高效检查 JS 对象中的键是否存在</a></li><li class=""><a title="实现鼠标滚轮缩放 SVG 内容" href="/md/实现鼠标滚轮缩放 SVG 内容.html">04 实现鼠标滚轮缩放 SVG 内容</a></li><li class=""><a title="使用 JS 向现有 SVG 中添加元素" href="/md/使用 JS 向现有 SVG 中添加元素.html">03 使用 JS 向现有 SVG 中添加元素</a></li><li class=""><a title="JS 单行代码集" href="/md/JS 单行代码集.html">02 JS 单行代码集</a></li><li class=""><a title="7 种位运算符的神奇用法" href="/md/7 种位运算符的神奇用法.html">01 7 种位运算符的神奇用法</a></li>
                </div>
            </div>
        </nav>

        <!-- Main Content Area -->
        <main class="main-content">
            <header class="content-header">
                <div class="header-left">
                    <h1 class="page-title">实用的 Javascript 小功能</h1>
                    <p class="time">HaoTian · 2024-11-16 08:06:27</p>
                </div>
                <div class="header-right">
                    <div class="tag-container">
                        <span class="tag">JavaScript</span>
                    </div>
                    <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                    </button>
                </div>
            </header>

            <!-- Article Content -->
            <article class="content-body md md ">
                <h2>在复制的文本添加自定义内容</h2>
<img src="../imgs/102/01.awebp">

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;在复制的文本添加自定义内容&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;content&quot;&gt;随便整点内容就行........&lt;/div&gt;
    &lt;script&gt;
      document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
        const contentElement = document.getElementById(&quot;content&quot;);
        // 监听 copy 事件
        contentElement.addEventListener(&quot;copy&quot;, (e) =&gt; {
          // 获取复制的内容
          const originalText = window.getSelection().toString();
          // 没有选中文本
          if (!originalText) return;
          // 阻止copy事件的默认行为，防止没加上自定义信息，就将原始文本复制到剪贴板上
          e.preventDefault();
          const clipboardData = e.clipboardData;
          // 将内容塞进剪贴板中
          clipboardData.setData(
            &quot;text/plain&quot;,
            `${originalText}\n\n你小子？又来复制什么？？？\n作者：橙某人\n链接：https://juejin.cn/user/1908407919184670/posts`
          );
        });
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2>input 随着输入内容自动增长宽度</h2>
<img src="../imgs/102/02.awebp">

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;input随着输入内容自动增长-宽度&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;input
      id=&quot;input&quot;
      type=&quot;text&quot;
      style=&quot;border: 1px solid #cbd5e0; min-width: 80px; padding: 10px;&quot;
    /&gt;
    &lt;script&gt;
      document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
        // 创建一个div元素
        const fakeElement = document.createElement(&quot;div&quot;);
        // 给它设置样式，用户不可见的
        fakeElement.style.position = &quot;absolute&quot;;
        fakeElement.style.top = &quot;0&quot;;
        fakeElement.style.left = &quot;-9999px&quot;;
        fakeElement.style.overflow = &quot;hidden&quot;;
        fakeElement.style.visibility = &quot;hidden&quot;;
        fakeElement.style.whiteSpace = &quot;nowrap&quot;;
        fakeElement.style.height = &quot;0&quot;;
        // 获取input元素
        const inputElement = document.getElementById(&quot;input&quot;);
        // 获取input元素的样式
        const styles = window.getComputedStyle(inputElement);
        // 将input的样式同步到div中
        // 字体相关的
        fakeElement.style.fontFamily = styles.fontFamily;
        fakeElement.style.fontSize = styles.fontSize;
        fakeElement.style.fontStyle = styles.fontStyle;
        fakeElement.style.fontWeight = styles.fontWeight;
        fakeElement.style.letterSpacing = styles.letterSpacing;
        fakeElement.style.textTransform = styles.textTransform;
        // 边框与内边距
        fakeElement.style.borderLeftWidth = styles.borderLeftWidth;
        fakeElement.style.borderRightWidth = styles.borderRightWidth;
        fakeElement.style.paddingLeft = styles.paddingLeft;
        fakeElement.style.paddingRight = styles.paddingRight;

        document.body.appendChild(fakeElement);
        // 先执行一次，保持div与input相同的初始宽度
        setWidth();
        // 监听input的输入
        inputElement.addEventListener(&quot;input&quot;, (e) =&gt; {
          setWidth(
            inputElement.value || inputElement.getAttribute(&quot;placeholder&quot;)
          );
        });
        // 计算div宽度并同步给input上
        function setWidth(text = &quot;&quot;) {
          fakeElement.innerHTML = text.replace(/\s/g, &quot;&amp;&quot; + &quot;nbsp;&quot;);
          const fakeElementStyles = window.getComputedStyle(fakeElement);
          inputElement.style.width = fakeElementStyles.width;
        }
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>整个过程原理大致是，将 <code>input</code> 实时输入的内容同步给一个容器，计算容器的宽度，再将容器宽度同步回 <code>input</code> 就能完成如上的效果啦。😁</p>
<p>这个小功能关键点是检测内容的宽度，而在 <code>JS</code> 中检测内容宽度一般用两种方式，其一，使用假元素，也就是我们上面使用的形式；另一种就是使用 <code>canvas</code> 的 <code>measureText</code> 方法。</p>
<p>大致过程如下：</p>
<pre><code class="language-js">function measureWidth(text, font) {
  const canvas = document.createElement(&quot;canvas&quot;);
  const context = canvas.getContext(&quot;2d&quot;);
  context.font = font;
  const metrics = context.measureText(text);
  return metrics.width;
}
</code></pre>
<h2>textarea 随着输入内容自动增长高度</h2>
<img src="../imgs/102/03.awebp">

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;textarea随着输入内容自动增长-高度&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;textarea
      id=&quot;textarea&quot;
      style=&quot;width: 16rem;border: 1px solid rgb(203 213 225);&quot;
    &gt;&lt;/textarea&gt;
    &lt;script&gt;
      document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
        const textareaEle = document.getElementById(&quot;textarea&quot;);
        textareaEle.addEventListener(&quot;input&quot;, () =&gt; {
          textareaEle.style.height = &quot;auto&quot;;
          textareaEle.style.height = `${textareaEle.scrollHeight}px`;
        });
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>呃......两行代码就能完成 😲，完全没难度，一个小技巧。</p>
<p>先将文本域的高度重置成 <code>auto</code>，这样我们就能使用 <code>scrollHeight</code> 获取内容的实际高度，然后，将文本域的高度设置成 <code>scrollHeight</code> 的值，这就能让文本域自动扩展适配内容了。</p>
<img src="../imgs/102/04.awebp">

<h2>同步两个元素之间的滚动</h2>
<p>这个案例源于小编提交 <code>Git</code> 代码时，查看相关代码的前后情况，那时编辑器的同步滚动引起了我的注意，就想着写个 DEMO 玩玩看。😗</p>
<p>同步滚动的应用情况还是非常常见的，如小编此时正在用的掘金 Markdown 编辑器、处理并排翻译项目时等等吧，总之，同步滚动可以给我们提供更便捷的工作效率。</p>
<p>下面咱们来一步一步实现这个小功能案例，先整上布局：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;同步两个元素之间的滚动&lt;/title&gt;
    &lt;style&gt;
      #container {
        display: flex;
        border: 1px solid rgb(203, 213, 225);
        height: 520px;
      }
      #left,
      #right {
        flex: 1;
        overflow-y: auto;
      }
      .child {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 50px;
      }
      .child:not(:last-child) {
        border-bottom: 1px solid rgb(203, 213, 225);
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;
      &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;
      &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const container = document.getElementById(&quot;container&quot;);
      const left = document.getElementById(&quot;left&quot;);
      const right = document.getElementById(&quot;right&quot;);

      createChildElement(left);
      createChildElement(right);

      // 在给定范围内随机生成一个数字
      function randomInteger(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      // 生成子元素
      function createChildElement(parent) {
        // 要生成多少个子元素
        const childNum = randomInteger(50, 80);
        console.log(&quot;子元素有多少个：&quot;, childNum);
        // 批量创建子元素
        Array(childNum)
          .fill(0)
          .forEach((_, index) =&gt; {
            const div = document.createElement(&quot;div&quot;);
            div.classList.add(&quot;child&quot;);
            div.innerHTML = `${index + 1}`;
            parent.appendChild(div);
          });
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Em...😐 没啥难，就是通过 <code>JS</code> 动态随机生成了一些子元素，方便我们后续的测试，大概整出来的效果如下：</p>
<img src="../imgs/102/05.awebp">

<p>现在左右两边各自滚自己的，互不干扰。</p>
<p>而我们要如何来同步两边的滚动呢？很简单！咱们只要给两边加上监听器（<code>scroll</code>），当用户滚动其中一边，咱们更新另一边就可以。</p>
<p>具体实现过程：</p>
<pre><code class="language-js">left.addEventListener(&quot;scroll&quot;, (e) =&gt; {
  syncScroll(left, right);
});
right.addEventListener(&quot;scroll&quot;, (e) =&gt; {
  syncScroll(right, left);
});
// 同步滚动, scrolledElement为滚动的元素, element为需要同步滚动的元素
function syncScroll(scrolledElement, element) {
  const top = scrolledElement.scrollTop;
  const left = scrolledElement.scrollLeft;
  element.scrollTo({
    behavior: &quot;instant&quot;,
    top,
    left,
  });
}
</code></pre>
<img src="../imgs/102/06.awebp">

<p>我们用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTo">Element.scrollTo</a> API 来进行滚动操作，看起来是不是还不错？😉</p>
<p>不过，这还没完，这里还存在两个问题 🔉：</p>
<ul>
<li>可能造成无限滚动循环：因为我们左右两边都监听了 <code>scroll</code> 事件，如果用户滚动了左边，我们去通过 <code>Element.scrollTo</code> API 滚动右边，这里其实右边也会触发 <code>scroll</code> 事件，那么它又会去同步滚动左边，这就会造成一个死循环的无限滚动了。而为什么动态图中看起来很正常呢？这是因为咱们在 <code>behavior</code> 参数上使用了 <code>instant</code> 值，如果你换成 <code>smooth</code> 值，这个问题就比较容易复现出来。</li>
</ul>
<img src="../imgs/102/07.awebp">

<ul>
<li>总高度滚动不同步：仔细瞧动图，你会发现左边还没滚动到底的时候，右边就已经到底了，这可不符合我们同步滚动的需求呀 ❗ 造成这个原因是两边的总高度不一致，虽然现在子元素高度都是一样的，但是子元素个数是随机的，未来也可能是子元素高度不一样高，反正就是两边的总高度可能会不一样高，那么滚动就不可能完全同步。</li>
</ul>
<p>对于这两个问题，咱们来逐一击破 💣。</p>
<p>要解决无限滚动循环问题，我们可以先暂时将未滚动元素的事件监听器给先移除了，等滚动结束后再加回来，Em...说着...很简单 😑，但...具体要如何做呢？</p>
<p>且看：</p>
<pre><code class="language-js">const boxs = [left, right];
boxs.forEach((item) =&gt; {
  item.addEventListener(&quot;scroll&quot;, handleScroll);
});

function handleScroll(e) {
  const scrolledElement = e.target;
  boxs
    .filter((item) =&gt; item !== scrolledElement)
    .forEach((noScrolledElement) =&gt; {
      // 移除未滚动元素的事件监听器
      noScrolledElement.removeEventListener(&quot;scroll&quot;, handleScroll);
      // 执行同步滚动
      syncScroll(scrolledElement, noScrolledElement);
      // 在下次重绘之前加回监听事件
      window.requestAnimationFrame(() =&gt; {
        noScrolledElement.addEventListener(&quot;scroll&quot;, handleScroll);
      });
    });
}

function syncScroll(scrolledElement, element) {
  // ...
}
</code></pre>
<p>这里用到了一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a> API 来判断再次添加回事件监听器的时机，按它的 API 介绍&quot;要求浏览器在下次重绘之前调用&quot;，也就是它会在下一次<strong>重绘</strong>之前被调用。</p>
<p>而滚动操作咱们使用了  <code>Element.scrollTo</code> API，它通常情况下，仅会引起重绘，因为滚动并不改变元素的布局。但是，如果滚动导致某些依赖于滚动位置的计算（如计算动态加载的内容或响应滚动事件而改变样式的元素）发生，那么它也可能间接引起回流，这时可能就要考虑加一个&quot;宏任务&quot;（<code>setTimeout</code>）来判断时机了。</p>
<p>那么，无限滚动循环问题咱们就如此解决掉了 😎，其实关键点是滚动结束时机的把控，这会涉及重绘、回流、事件循环等 <code>JS</code> 的知识点。</p>
<p>而另一个总高度滚动不同步问题呢 ❓ 改动不大，先直接贴上代码：</p>
<pre><code class="language-js">function syncScroll(scrolledElement, element) {
  // 计算 滚动距离 占 总可滚动距离 的滚动比例
  const scrolledPercent =
    scrolledElement.scrollTop /
    (scrolledElement.scrollHeight - scrolledElement.clientHeight);
  // 通过 滚动比例 与 总可滚动距离 就能推出实际滚动距离
  const top = scrolledPercent * (element.scrollHeight - element.clientHeight);
  // top能懂，left就能明白
  const scrolledWidthPercent =
    scrolledElement.scrollLeft /
    (scrolledElement.scrollWidth - scrolledElement.clientWidth);
  const left =
    scrolledWidthPercent * (element.scrollWidth - element.clientWidth);
  element.scrollTo({
    behavior: &quot;instant&quot;,
    top,
    left,
  });
}
</code></pre>
<p>开始咱们是直接将滚动距离 <code>scrolledElement.scrollTop</code> 同步到另一个未滚动元素上。</p>
<p>但是当元素具有不同的高度时，滚动位置可能会变得不同步。要解决这个问题，咱们只能计算出<strong>滚动比例</strong>再去推导出不同元素的实际需要滚动的距离。</p>
<img src="../imgs/102/08.awebp">

<p>好了，通过这些修改，我们的同步滚动功能现在可以处理具有不同数量块的多个可滚动元素，同时保持其滚动位置完美同步，完美收工。🥳</p>
<h2>打印图片</h2>
<p>图片打印听起来好像挺高大上 😲，其实不然。</p>
<p>在浏览器中，提供了打印的方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/print">window.print()</a>，这个方法不需要任何参数，直接调用即可。</p>
<p>不过，它是将整个网页进行打印，这倒是与我们只想打印图片的需求有点差异，不过问题不大，咱们可以利用一个 <code>iframe</code> 来解决，<code>iframe</code> 里面就放一张图片就行嘛，这也是当前浏览器上打印局部内容的主流方案。</p>
<p>就不卖关子了 😄，直接上代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;打印图片&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div
      style=&quot;display: flex; flex-direction: column; justify-content: center;align-items: center;&quot;
    &gt;
      &lt;img
        id=&quot;image&quot;
        style=&quot;width: 300px;margin-bottom: 10px;&quot;
        src=&quot;https://p9-passport.byteacctimg.com/img/user-avatar/958fa7d9d487975fe84bc62298b8bc47~120x120.awebp&quot;
      /&gt;
      &lt;button id=&quot;print&quot;&gt;打印图片&lt;/button&gt;
    &lt;/div&gt;
    &lt;script&gt;
      document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
        const printBtn = document.getElementById(&quot;print&quot;);
        printBtn.addEventListener(&quot;click&quot;, function () {
          const image = document.getElementById(&quot;image&quot;);
          print(image);
        });

        function print(image) {
          // 创建一个iframe
          const iframe = document.createElement(&quot;iframe&quot;);
          // 设置样式
          iframe.style.height = 0;
          iframe.style.visibility = &quot;hidden&quot;;
          iframe.style.width = 0;
          // 等同于src属性，只是src是路径，srcdoc是HTML代码
          iframe.setAttribute(&quot;srcdoc&quot;, &quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
          // 插入iframe
          document.body.appendChild(iframe);
          // iframe加载完
          iframe.addEventListener(&quot;load&quot;, () =&gt; {
            // 克隆图片元素，防止相互干扰
            const imageClone = image.cloneNode();
            imageClone.style.maxWidth = &quot;100%&quot;;
            // 访问iframe的body
            const body = iframe.contentDocument.body;
            body.style.textAlign = &quot;center&quot;;
            body.appendChild(imageClone);
            // 等待图片加载完
            imageClone.addEventListener(&quot;load&quot;, () =&gt; {
              // 打印，等同window.print()
              iframe.contentWindow.print();
            });
          });
          // iframe.contentWindow返回iframe的window对象
          iframe.contentWindow.addEventListener(&quot;afterprint&quot;, () =&gt; {
            // 在关联的文档开始打印或关闭打印预览后，将触发 afterprint 事件。
            iframe.parentNode.removeChild(iframe);
          });
        }
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>就一个方法，标有详细的注解，这里就不多说啦，看就完事。👻</p>
<p>贴两张图瞅瞅叭。</p>
<p>整个网页打印：</p>
<img src="../imgs/102/09.awebp">

<p>只打印图片：</p>
<img src="../imgs/102/10.awebp">

<h2>可调整大小的视图</h2>
<img src="../imgs/102/11.awebp">

<p>看这个案例的具体实现之前，小编建议你先稍微瞅瞅另一篇文章 <a href="https://juejin.cn/post/7356326955930107904">拖动 ❓ 元素拖动、列表拖动、表格拖动(列与行)🍊🍊🍊</a> ，看完之后，这个案例对你来说就是手到擒来的事情，没吹 🙅，真是这样。</p>
<p>结构与样式：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;可调整大小的视图&lt;/title&gt;
    &lt;style&gt;
      .container {
        width: 100%;
        height: 500px;
        border: 1px solid #cbd5e0;
        display: flex;
      }
      .line[data-direction=&quot;horizontal&quot;] {
        width: 2px;
        height: 100%;
        background-color: #cbd5e0;
        cursor: ew-resize;
      }
      .line[data-direction=&quot;vertical&quot;] {
        height: 2px;
        width: 100%;
        background-color: #cbd5e0;
        cursor: ns-resize;
      }
      .left {
        width: 25%;
        align-items: center;
        display: flex;
        justify-content: center;
      }
      .right {
        flex: 1;
        align-items: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      .top {
        width: 100%;
        height: 200px;
        align-items: center;
        display: flex;
        justify-content: center;
      }
      .bottom {
        width: 100%;
        flex: 1;
        align-items: center;
        display: flex;
        justify-content: center;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;left&quot;&gt;左边菜单&lt;/div&gt;
      &lt;div class=&quot;line&quot; data-direction=&quot;horizontal&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;right&quot;&gt;
        &lt;div class=&quot;top&quot;&gt;上面内容&lt;/div&gt;
        &lt;div class=&quot;line&quot; data-direction=&quot;vertical&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;bottom&quot;&gt;下面内容&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>HTML+CSS</code> 就没什么好说的了，主要咱们是来看看逻辑方面是如何做的。😀</p>
<pre><code class="language-js">document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
  // 给 拖动元素(line) 批量添加监听事件
  document.querySelectorAll(&quot;.line&quot;).forEach((line) =&gt; {
    resizable(line);
  });

  function resizable(line) {
    // 容器信息
    const containerRect = line.parentNode.getBoundingClientRect();
    // 获取拖动方向
    const direction = line.getAttribute(&quot;data-direction&quot;) || &quot;horizontal&quot;;
    // 获取相邻元素
    const prevSibling = line.previousElementSibling;
    const nextSibling = line.nextElementSibling;
    // 相关位置信息
    let x = 0;
    let y = 0;
    let prevSiblingHeight = 0;
    let prevSiblingWidth = 0;
    // 拖动元素添加鼠标按下事件
    line.addEventListener(&quot;mousedown&quot;, mouseDownHandler);

    function mouseDownHandler(e) {
      // 获取鼠标当前位置
      x = e.clientX;
      y = e.clientY;
      // 获取拖动元素的上个元素的宽高
      const rect = prevSibling.getBoundingClientRect();
      prevSiblingHeight = rect.height;
      prevSiblingWidth = rect.width;
      // 监听鼠标的移动与释放事件
      document.addEventListener(&quot;mousemove&quot;, mouseMoveHandler);
      document.addEventListener(&quot;mouseup&quot;, mouseUpHandler);
    }
    function mouseMoveHandler(e) {
      // 获取拖动距离
      const dx = e.clientX - x;
      const dy = e.clientY - y;
      switch (direction) {
        case &quot;vertical&quot;:
          // 垂直拖动时，top元素宽度 = (原高度 + 拖动距离) * 100 / 容器总高度
          const h = ((prevSiblingHeight + dy) * 100) / containerRect.height;
          prevSibling.style.height = h + &quot;%&quot;;
          break;
        case &quot;horizontal&quot;:
        default:
          // 水平拖动时，left元素宽度 = (原宽度 + 拖动距离) * 100 / 容器总宽度
          const w = ((prevSiblingWidth + dx) * 100) / containerRect.width;
          prevSibling.style.width = w + &quot;%&quot;;
          break;
      }
      // 更改相关样式
      const cursor = direction === &quot;horizontal&quot; ? &quot;col-resize&quot; : &quot;row-resize&quot;;
      line.style.cursor = cursor;
      document.body.style.cursor = cursor;
      prevSibling.style.userSelect = &quot;none&quot;;
      prevSibling.style.pointerEvents = &quot;none&quot;;
      nextSibling.style.userSelect = &quot;none&quot;;
      nextSibling.style.pointerEvents = &quot;none&quot;;
    }
    function mouseUpHandler() {
      // 相关样式、事件重置回来
      line.style.removeProperty(&quot;cursor&quot;);
      document.body.style.removeProperty(&quot;cursor&quot;);
      prevSibling.style.removeProperty(&quot;user-select&quot;);
      prevSibling.style.removeProperty(&quot;pointer-events&quot;);
      nextSibling.style.removeProperty(&quot;user-select&quot;);
      nextSibling.style.removeProperty(&quot;pointer-events&quot;);
      document.removeEventListener(&quot;mousemove&quot;, mouseMoveHandler);
      document.removeEventListener(&quot;mouseup&quot;, mouseUpHandler);
    }
  }
});
</code></pre>

            </article>
        </main>

        <!-- Table of Contents Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-header">
                <h3>Table of Contents</h3>
            </div>
            <div class="toc-content" id="tocContent">
                <!-- TOC will be generated dynamically -->
            </div>
        </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 19V5M5 12l7-7 7 7"/>
        </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(135deg, var(--accent), rgba(59, 130, 246, 0.8));
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
        // Sidebar Toggle
        const toggleBtn = document.getElementById('toggleSidebar');
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');
        
        function toggleSidebar() {
            sidebar.classList.toggle('hidden');
            // Store sidebar state in localStorage
            localStorage.setItem('sidebarHidden', sidebar.classList.contains('hidden'));
        }
        
        toggleBtn.addEventListener('click', toggleSidebar);

        // Keyboard shortcut (Ctrl + B)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'b') {
                e.preventDefault(); // Prevent browser's default behavior
                toggleSidebar();
            }
        });

        // Restore sidebar state from localStorage
        document.addEventListener('DOMContentLoaded', () => {
            const sidebarHidden = localStorage.getItem('sidebarHidden') === 'true';
            if (sidebarHidden) {
                sidebar.classList.add('hidden');
            }
        });

        // Generate Table of Contents
        function generateTOC() {
            const article = document.querySelector('.content-body');
            const headings = article.querySelectorAll('h1, h2, h3, h4');
            const tocContent = document.getElementById('tocContent');
            const toc = document.createElement('ul');

            headings.forEach((heading, index) => {
                const id = `heading-${index}`;
                heading.id = id;
                
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${id}`;
                a.textContent = heading.textContent;
                a.className = `toc-level-${heading.tagName.toLowerCase()}`;
                
                li.appendChild(a);
                toc.appendChild(li);
            });

            tocContent.appendChild(toc);
        }

        // Initialize TOC
        document.addEventListener('DOMContentLoaded', generateTOC);

        // Image zoom with FLIP animation
        const overlay = document.querySelector(".zoom-overlay");
        let activeImage = null;

        document.querySelectorAll("img").forEach((img) => {
            if (img.closest("a")) return; // Skip images that are inside links
            img.style.cursor = "zoom-in";
            img.addEventListener("click", handleImageClick);
        });

        function handleImageClick(event) {
            const img = event.target;

            if (activeImage) {
                // If an image is already zoomed, unzoom it
                unzoomImage();
                return;
            }

            // Get the initial position and size
            const rect = img.getBoundingClientRect();
            const first = {
                x: rect.left,
                y: rect.top,
                width: rect.width,
                height: rect.height,
            };

            // Create a clone of the image
            const clone = img.cloneNode();
            clone.classList.add("zoomed-image");
            document.body.appendChild(clone);

            // Position the clone exactly over the original
            clone.style.position = "fixed";
            clone.style.left = `${first.x}px`;
            clone.style.top = `${first.y}px`;
            clone.style.width = `${first.width}px`;
            clone.style.height = `${first.height}px`;
            clone.style.margin = "0";
            clone.style.transformOrigin = "top left";

            // Show the overlay
            overlay.style.display = "block";

            // Calculate the final position and scale
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
            const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
            const scaleX = targetWidth / first.width;
            const scaleY = targetHeight / first.height;
            const scale = Math.min(scaleX, scaleY);

            const last = {
                width: first.width * scale,
                height: first.height * scale,
            };
            last.x = (viewportWidth - last.width) / 2;
            last.y = (viewportHeight - last.height) / 2;

            // Calculate and apply the transform
            const dx = last.x - first.x;
            const dy = last.y - first.y;

            requestAnimationFrame(() => {
                clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
                clone.style.transition = "transform 0.3s ease-out";
            });

            activeImage = { original: img, clone: clone };

            // Add click handlers for closing
            clone.addEventListener("click", unzoomImage);
            overlay.addEventListener("click", unzoomImage);
        }

        function unzoomImage() {
            if (!activeImage) return;

            const { original, clone } = activeImage;
            const rect = original.getBoundingClientRect();

            // Animate back to the original position
            clone.style.transform = `translate(0, 0) scale(1)`;

            // Clean up after the animation
            clone.addEventListener(
                "transitionend",
                () => {
                    clone.remove();
                    overlay.style.display = "none";
                },
                { once: true }
            );

            activeImage = null;
        }

        // 监听 ctrl + b
        window.addEventListener("keydown", (e) => {
            const leftDom = document.querySelector(".sidebar");
            if (e.ctrlKey && e.key === "b") {
                leftDom.classList.toggle("hidden");
            }
        });

        // Modal
        // const modal = document.getElementById("myModal");
        // const modalContent = modal.querySelector(".modal-content");
        // const openModal = document.getElementById("openModal");
        // const close = modal.querySelector(".close");

        // openModal.addEventListener("click", () => {
        //     modal.style.display = "block";
        // });

        // close.addEventListener("click", () => {
        //     modal.style.display = "none";
        // });

        // window.addEventListener("click", (e) => {
        //     if (e.target === modal) {
        //         modal.style.display = "none";
        //     }
        // });

        // Back to top button
        const backToTop = document.getElementById('backToTop');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 200) {
                backToTop.style.display = 'block';
            } else {
                backToTop.style.display = 'none';
            }
        });

        backToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Theme toggle
        document.addEventListener('DOMContentLoaded', () => {
            const themeToggle = document.getElementById('themeToggle');
            const html = document.documentElement;
            const prismTheme = document.getElementById('prismTheme');
            
            // Function to update theme and stylesheet
            function updateTheme(theme) {
              html.className = theme;
              prismTheme.href = `../css/prism${theme === 'dark' ? '2' : ''}.css`;
              localStorage.setItem('theme', theme);
            }
            
            // Check for saved theme preference
            const savedTheme = localStorage.getItem('theme') || 'light';
            updateTheme(savedTheme);

            themeToggle.addEventListener('click', () => {
              const currentTheme = html.className;
              const newTheme = currentTheme === 'light' ? 'dark' : 'light';
              updateTheme(newTheme);
            });
        });
    </script>
</body>
</html>
