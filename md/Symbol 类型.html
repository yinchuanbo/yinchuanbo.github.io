<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Symbol 类型</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>
  <body class="line-numbers">
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left">
          <ul>
            <li class="active"><a title="Symbol 类型" href="/md/Symbol 类型.html">01 Symbol 类型</a></li>
          </ul>
        </div>
        <div
          class="layout__main_right md "
        >
          <h1>Symbol 类型</h1>
          <p>Symbol（符号） 是原始值，且符号实例是唯一的、不可改变的。</p>
<p>符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p>
<h2>1. 符号的基本用法</h2>
<pre><code class="language-js">let sym = Symbol();
console.log(typeof sym); // &quot;symbol&quot;
</code></pre>
<p>调用 <code>Symbol()</code> 函数时，也可以传入一个字符串参数作为符号的描述。将来可以通过这个字符串来调试代码，但是，这个字符串参数与符号定义或标识完全无关。</p>
<pre><code class="language-js">let genercSymbol = Symbol();
let otherGenercSymbol = Symbol();

let fooSymbol = Symbol(&quot;foo&quot;);
let otherFooSymbol = Symbol(&quot;foo&quot;);

console.log(genercSymbol == otherGenercSymbol); // false
console.log(fooSymbol == otherFooSymbol); // false
</code></pre>
<p><code>Symbol()</code> 函数不能作为构造函数，与 new 关键字一起使用。</p>
<pre><code class="language-js">let myBoolean = new Boolean();
console.log(typeof myBoolean); // &quot;object&quot;

let myString = new String();
console.log(typeof myString); // &quot;object&quot;

let myNumber = new Number();
console.log(typeof myNumber); // &quot;object&quot;

let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
</code></pre>
<p>如果你确定想使用符号包装对象，可以借用 <code>Object()</code> 函数：</p>
<pre><code class="language-js">let mySymbol = Symbol();
let myWrappedSymbol = Object(mySymbol);
console.log(typeof myWrappedSymbol); // &quot;object&quot;
</code></pre>
<h2>2. 使用全局符合注册表</h2>
<p>如果运行时的不同部分需要共享和重用符合实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。</p>
<p>为此，需要使用 <code>Symbol.for()</code> 方法</p>
<pre><code class="language-js">let fooGlobalSymbol = Symbol.for(&quot;foo&quot;);
console.log(typeof fooGlobalSymbol); // symbol
</code></pre>
<p><code>Symbol.for()</code> 对每个字符串键都执行幂等操作，第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。</p>
<p>后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该字符串实例。</p>
<pre><code class="language-js">let fooGlobalSymbol = Symbol.for(&quot;foo&quot;);
let otherFooGlobalSymbol = Symbol.for(&quot;foo&quot;);
console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
</code></pre>
<p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用 <code>Symbol()</code> 定义的符号也并不等同：</p>
<pre><code class="language-js">let localSymbol = Symbol(&quot;foo&quot;);
let globalSymbol = Symbol.for(&quot;foo&quot;);
console.log(localSymbol === globalSymbol); // false
</code></pre>
<p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 <code>Symbol.for()</code> 的任何值都会被转换为字符串，此外，注册表中使用的键同时也会被用作符号描述。</p>
<pre><code class="language-js">let emptyGlobalSymbol = Symbol.for();
console.log(emptyGlobalSymbol); // Symbol(undefined)
</code></pre>
<p>还可以是 <code>Symbol.keyFor()</code> 来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回 undefined。</p>
<pre><code class="language-js">// 创建全局符号
let s = Symbol.for(&quot;foo&quot;);
console.log(Symbol,.keyFor(s)); // foo

// 创建普通符号
let s2 = Symbol(&#39;bar&#39;);
console.log(Symbol.keyFor(s2)); // undefined
</code></pre>
<p>如果传给 <code>Symbol.keyFor()</code> 的不是符号，则方法会报错 <code>TypeError</code>。</p>
<pre><code class="language-js">Symbol.keyFor(123); // TypeError: 123 is not a symbol
</code></pre>
<h2>3. 使用符号作为属性</h2>
<p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。</p>
<p>这就包括了对象字面量属性和 <code>Object.defineProperty()</code>、<code>Object.definedProperties()</code> 定义的属性。</p>
<pre><code class="language-js">let s1 = Symbol(&quot;foo&quot;),
  Symbol(&quot;bar&quot;),
  Symbol(&quot;baz&quot;),
  Symbol(&quot;qux&quot;);

let o = {
  [s1]: &quot;foo val&quot;
};

// 这样也可以：o[s1] = &quot;foo val&quot;
console.log(o); // { Symbol(foo): &quot;foo val&quot; }

Object.defineProperty(o, s2, { value: &quot;bar val&quot; });
console.log(o); // { Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot; }

Object.definedProperties(o, {
  [s3]: { value: &quot;baz val&quot; },
  [s4]: { value: &quot;qux val&quot; }
})
console.log(o);
/*
  {
    Symbol(foo): &quot;foo val&quot;,
    Symbol(bar): &quot;bar val&quot;,
    Symbol(baz): &quot;baz val&quot;,
    Symbol(qux): &quot;qux val&quot;
  }
*/
</code></pre>
<p>类似于 <code>Object.getOwnPropertyNames()</code> 返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbol()</code> 返回对象实例的符号属性数组。</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // const leftBorder = document.querySelector(".left__border");
      // const resizer = document.querySelector(".layout__main_left");
      // const resizable = document.querySelector(".layout__main_right");
      // leftBorder.addEventListener("mousedown", initResize);
      // function initResize(e) {
      //   e.preventDefault();
      //   document.addEventListener("mousemove", startResizing);
      //   document.addEventListener("mouseup", stopResizing);
      // }
      // function startResizing(e) {
      //   const resizerRect = resizer.getBoundingClientRect();
      //   const resizableRect = resizable.getBoundingClientRect();
      //   let newWidth = e.clientX - resizerRect.left;
      //   if (newWidth < 300) {
      //     newWidth = 300;
      //   } else if (newWidth > 850) {
      //     newWidth = 850;
      //   }
      //   resizer.style.width = `${newWidth}px`;
      // }
      // function stopResizing() {
      //   document.removeEventListener("mousemove", startResizing);
      //   document.removeEventListener("mouseup", stopResizing);
      // }
      const liActive = document.querySelector(".layout__main_left li.active");
      liActive.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest",
      });
    </script>
  </body>
</html>
