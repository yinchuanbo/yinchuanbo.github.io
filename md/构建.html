<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>构建</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link id="prismTheme" rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700b3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
  </head>

  <body class="fade-in">
    <button
      class="toggle-sidebar"
      id="toggleSidebar"
      aria-label="Toggle Sidebar"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <div class="app-container">
      <!-- Sidebar Navigation -->
      <nav class="sidebar">
        <div class="sidebar-header">
          <button class="toggle-sidebar" id="toggleSidebar">
            <span></span>
          </button>
        </div>
        <div class="sidebar-content">
          <div class="nav-section"><li class=""><a title="维护" href="/md/维护.html">04 维护</a></li><li class=""><a title="开源" href="/md/开源.html">03 开源</a></li><li class=""><a title="测试" href="/md/测试.html">02 测试</a></li><li class="active"><a title="构建" href="/md/构建.html">01 构建</a></li></div>
        </div>
      </nav>

      <!-- Main Content Area -->
      <main class="main-content">
        <header class="content-header">
          <div class="header-left">
            <h1 class="page-title">构建</h1>
            <p class="time">HaoTian · 2025-01-26 10:06:36</p>
          </div>
          <div class="header-right">
            <div class="tag-container">
              <span class="tag">现代 JavaScript 库开发</span>
            </div>
            <button
              id="themeToggle"
              class="theme-toggle"
              aria-label="Toggle theme"
            >
              <svg
                class="sun-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
              <svg
                class="moon-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
            </button>
            <button
              class="theme-toggle"
              aria-label="Toggle theme"
              style="width: 36px; height: 36px"
              onclick="window.location.href='/md';"
            >
              <svg
                t="1737442501710"
                class="icon"
                viewBox="0 0 1024 1024"
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
                p-id="5258"
                width="20"
                height="20"
              >
                <path
                  d="M883.773793 626.047476c-17.308201 0-31.408337 14.029528-31.408337 31.304983l0 207.437469c0 17.204847-14.098089 31.302937-31.406291 31.302937L203.040834 896.092865c-17.340947 0-31.408337-14.098089-31.408337-31.302937L171.632497 657.352459c0-17.275455-14.099113-31.304983-31.408337-31.304983-17.380856 0-31.444153 14.029528-31.444153 31.304983l0 207.437469c0 51.773154 42.261523 93.91188 94.260827 93.91188l617.918331 0c52.031027 0 94.259804-42.139749 94.259804-93.91188L915.21897 657.352459C915.21897 640.077004 901.152603 626.047476 883.773793 626.047476L883.773793 626.047476zM230.262826 614.286618c55.523571 0 104.556311-27.674293 134.394896-69.762877 32.487925 46.451962 86.303598 77.0744 147.343813 77.0744 61.036122 0 114.846678-30.623461 147.306974-77.0744 29.943986 42.018999 78.902024 69.762877 134.426619 69.762877 90.948385 0 164.968216-73.77526 164.968216-164.371628 0-11.062963-2.342348-22.859637-5.130857-35.178197-0.209778-1.134847 0.031722-2.26867-0.277316-3.38612l-0.629333-2.267647c-0.24764-0.924045-0.140193-1.535983-0.352017-2.547009-0.138146-0.505513-0.521886-0.87288-0.695848-1.39579l-85.364203-316.671313c-3.699252-13.645788-16.051581-23.172769-30.293957-23.172769L187.965487 65.296145c-14.238282 0-26.665313 9.526981-30.360472 23.24133L72.309374 405.1566c-0.103354 0.50756-0.48607 0.820692-0.62524 1.309832-0.210801 0.942465-0.107447 1.639337-0.349971 2.511193l-0.62524 2.373047c-0.318248 1.11745 0 2.25025-0.210801 3.38612-2.863211 12.31856-5.201465 24.115234-5.201465 35.178197C65.295634 540.511357 139.315464 614.286618 230.262826 614.286618L230.262826 614.286618z"
                  fill="currentColor"
                  p-id="5259"
                ></path>
              </svg>
            </button>
          </div>
        </header>

        <!-- Article Content -->
        <article
          class="content-body md md "
        >
          <h2>模块化解析</h2>
<p>ECMAScript 2015 带来了原生的模块规范，而在此之前，JavaScript 并没有统一的模块规范。对于大型项目来说，模块是必不可少的，于是 JavaScript 社区进行了很多探索，其中有一些影响力较大的模块规范(如 AMD 和 CommonJS)，目前还在被广泛使用。</p>
<h3>什么是模块</h3>
<p>随着程序规模的扩大，以及引入各种第三方库，共享全局作用域会带来很多问题。首先是命名冲突问题，为了解决命名冲突问题，主流编程语言都提供了语言层面的方案，举例如下:</p>
<ul>
<li><p>C 语言中的宏编译</p>
</li>
<li><p>C++语言中的命名空间</p>
</li>
<li><p>Python 语言中的模块</p>
</li>
<li><p>Java 语言中的包</p>
</li>
<li><p>PHP 语言中的命名空间</p>
</li>
</ul>
<p>JavaScript 社区则选择了模块方案。一个合格的模块方案需要满足以下特性:</p>
<ul>
<li><p>独立性 - 能够独立完成某个功能，隔绝外部环境的影响。</p>
</li>
<li><p>完整性 - 能够完成某个特定功能。</p>
</li>
<li><p>可依赖 - 可以依赖其他模块。</p>
</li>
<li><p>被依赖 - 可以被其他模块依赖。</p>
</li>
</ul>
<blockquote>
<p>简而言之，模块就是一个独立的空间，能引用其他模块，也能被其他模块引用。</p>
</blockquote>
<h3>原始模块</h3>
<p>如果仅从定义层面来看，一个函数即可称为一个模块，而我们早就开始使用这种模块了。</p>
<pre><code class="language-js">function add(a, b) {
  return a + b;
}
</code></pre>
<p>在 ECMAScript 2015 之前，只有函数能够创建作用域。</p>
<p>下面是 JavaScript 社区中原始模块的定义代码:</p>
<pre><code class="language-js">(function (mod, $) {
  function clone(source) {
    // 此处省略
  }
})((window.clone = window.clone || {}), jQuery);
</code></pre>
<p>上面的 mod 模块不会被重复定义，依赖通过函数参数注入。这种实现其实并不完美，仍然需要手动维护依赖的顺序，典型的场景就是其中的 jQuery 必须先于代码被引用，否则会报告引用错误。随着模块数量的增加，这种问题很快会变得不可维护，这显然不是我们想要的。</p>
<p>一般的库都会提供对这种模块的支持，因为这种模块可以直接通过 script 标签引入，使用 script 标签引入库的方式依然存在使用场景，如古老的前端系统、简单的活动页面、简单的测试页面等。</p>
<h3>AMD</h3>
<p>AMD 是一种异步模块加载规范，专为浏览器端设计，其全称是 AsynchronousModule Definition，中文名称是异步模块定义。</p>
<p>AMD 规范中定义模块的方式如下:</p>
<pre><code class="language-js">define(id?, dependencies?, factory);
</code></pre>
<p>浏览器并不支持 AMD 模块，在浏览器端，需要借助 RequireJS 才能加载 AMD 模块。</p>
<p>RequireJS 是使用最广泛的 AMD 模块加载器，但目前的新系统基本不再使用 RequireJS，因为大部分库都会提供对 AMD 模块的支持</p>
<p>给深拷贝库添加对 AMD 模块的支持:</p>
<pre><code class="language-js">define(function () {
  function clone(source) {
    // 此处省略
  }
  return clone;
});
</code></pre>
<p>上面的代码定义了一个匿名 AMD 模块，假设代码位于 clone.js 文件中，那么在 index.js 文件中可以像下面代码这样使用上面代码定义的模块:</p>
<pre><code class="language-js">define([&quot;clone&quot;], function (clone) {
  const a = { a: 1 };
  const b = clone(a);
});
</code></pre>
<h3>CommonJS</h3>
<p>CommonJs 是一种同步模块加载规范，目前主要用于 Node.js 环境中。CommonJs 规范中定义模块的方式如下：</p>
<pre><code class="language-js">define(function (require, exports, module) {
  //...
});
</code></pre>
<p>在 Node.js 中，外面的 define 包裹函数是系统自动生成的，不需要开发者自己书写。下面是深拷贝库支持 CommonJS 模块的示例代码:</p>
<pre><code class="language-js">function clone(source) {
  // 此处省略
}
module.exports = clone;
</code></pre>
<p>在 Nodejs 环境下，假设上面的代码位于 clone.js 文件中，那么在 index.js 文件中可以像下面代码这样使用上面代码定义的模块:</p>
<pre><code class="language-js">const clone = require(&quot;./clone&quot;);
const a = { a: 1 };
const b = clone(a);
</code></pre>
<h3>UMD</h3>
<p>UMD 是一种通用模块加载规范，其全称是 Universal Module Definition，中文名称是通用模块定义。</p>
<p>UMD 想要解决的问题和其名称所传递的意思是一致的，它并不是一种新的规范，而是对前面介绍的 3 种模块规范 (原始模块、AMD、CommonJS)的一种整合。支持 UMD 规范的库可以在任何模块环境中工作。</p>
<pre><code class="language-js">(function (root, factory) {
  var clone = factory(root);
  if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
    // AMD
    define(&quot;clone&quot;, function () {
      return clone;
    });
  } else if (typeof exports === &quot;object&quot;) {
    // CommonJS
    module.exports = clone;
  } else {
    // 原始模块
    var _clone = root.clone;
    clone.noConflict = function () {
      if (root.clone === clone) {
        root.clone = _clone;
      }
      return clone;
    };
    root.clone = clone;
  }
})(this, function (root) {
  function clone(source) {
    // 此处省略
  }
  return clone;
});
</code></pre>
<p>由上述代码可以看到，UMD 规范只是对不同模块规范的简单整合，稍微不同的是，代码中给原始模块增加了 noConfict 方法，使用 noConfict 方法可以解决全局名称冲突的问题。</p>
<h3>ES Module</h3>
<p>ECMAScript 2015 带来了原生的模块系统 ES Module。目前，部分浏览器已经支持直接使用 ES Module，而不兼容的浏览器则可以通过构建工具来使用。</p>
<pre><code class="language-js">export function clone(source) {
  // 此处省略
}
</code></pre>
<p>假设上面的代码位于 clone.js 文件中，那么在 index.js 文件中可以像下面代码这样引用 clone.js 文件中的 clone 函数:</p>
<pre><code class="language-js">import { clone } from &quot;./clone&quot;;
const a = { a: 1 };
const b = clone(a);
</code></pre>
<p>介绍了多种前端模块，对于开源库来说，为了满足各种模块使用者的需求，需要对每种模块提供支持。开源库可以提供两个入口文件,</p>
<table>
<thead>
<tr>
<th>入口文件</th>
<th>支持的模块</th>
</tr>
</thead>
<tbody><tr>
<td>index.js</td>
<td>原始模块、AMD 模块、CommonJS 模块、UMD 模块</td>
</tr>
<tr>
<td>index.esm.js</td>
<td>ES Module</td>
</tr>
</tbody></table>
<h2>技术体系解析</h2>
<p>在开始之前先来看一个场景：深拷贝库中有一个 type 函数，用来获取数据的类型，现在假设还有一个库也要用到这个函数，所以我们决定将其单独抽象为一个库，现在就有了两个库，其中 clone 库会依赖 type 库</p>
<p>一般一个 JavaScript 库都会依赖另外一些库，真实的 JavaScript 库的依赖关系会更复杂</p>
<h3>传统体系</h3>
<p>在传统体系中，一般通过在 HTML 文件中使用 script 标签来引入 JavaScript 文件，这种体系下的每个库都需要提供一个 js 格式的文件。</p>
<p>在传统体系下，如果想使用一个库，就必须在使用之前手动引入要用到的库及其依赖的库。例如，如果想使用 clone 库，就必须在引入 clone 库之前先引入 type 库否则就会报错</p>
<p>随着库规模的扩大，将依赖关系交给库的使用者手动维护，对库的使用者非常不友好，因为要提供包含全部代码的入口文件，所以在这种体系下，大部分库都不会依赖很多其他的库。</p>
<p>兼容传统体系的库，需要将所有代码及其依赖的库的代码合并成一个文件。但也存在例外情况，例如，jQuery 插件必须依赖 jQuery 才能运行，React 插件必须依赖 React 才能运行，这种情况下可以将 jQuery 或 React 的引入交给插件的使用者来实现。</p>
<h3>Node.js 体系</h3>
<p>Nodejs 的模块系统遵守前面提到的 CommonJS 规范,Nodejs 有内置的依赖解析系统，如果要依赖一个模块，则可以像下面代码这样使用 require 系统函数直接引用文件:</p>
<pre><code class="language-js">const clone = require(&quot;./clone&quot;);
</code></pre>
<p>在使用 require 函数引用文件时，被引用文件的路径需遵循一套复杂的规则，引用支持相对路径、绝对路径和第三方包，如果忽略后缀，则会被当作 Nodejs 的模块去解析。</p>
<p>Node.js 模块目录下需要有一个 package.json 文件，用于定义模块的一些属性。如果想要新建模块，则可以使用 Nodejs 提供的 npm 工具快速初始化。通过下面的命令可以在 lib 目录下新建并初始化 clone 模块:</p>
<pre><code class="language-sh">mkdir clone
cd clone
npm init
</code></pre>
<p>npm 会提示填写模块的信息，这里不做修改，一直保持默认设置即可，执行后会生成一个 packagejson 文件，该文件包含的字段如下:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;clone&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
<p>这里主要关注 main 字段，其定义的是当前模块对应的逻辑入口文件，当该模块被其他模块引用时，Nodejs 会找到 main 字段对应的文件。</p>
<p>通过同样的操作完成对 type 模块的初始化。此时，项目的目录结构如下:</p>
<pre><code class="language-sh">|- index.js
|- lib
  |- clone
    |- index.js
    |- package.json
  |- type
    |- index.js
    |- package.json
</code></pre>
<p>通过以下代码可以在 index.js 文件中直接引入 clone 模块，Node.js 会自动完成模块解析，并</p>
<pre><code class="language-js">const clone = require(&quot;./lib/clone&quot;);
</code></pre>
<p>在 Node.js 体系下，库只需要提供对 CommonJS 模块或 UMD 模块的支持即可，对依赖的库不需要进行特殊处理。</p>
<h3>工具化体系</h3>
<p>随着前端工程化的发展，前端构建工具目前已经成为中大型项目的标配。构建工具的典型代表是 webpack，webpack 支持 CommonJs 规范。</p>
<p>如果想要使用 webpack，则需要先安装 webpack，安装命令如下:</p>
<pre><code class="language-sh">npm i webpack webpack-cli -D
</code></pre>
<p>在项目的根目录下添加 webpack.config.js 文件，并在该文件中添加如下配置代码，其含义是将当前目录下的 index.js 文件打包输出为 <code>dist/index.js</code> 文件。</p>
<pre><code class="language-js">const path = require(&quot;path&quot;);
module.exports = {
  entry: &quot;./index.js&quot;,
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;index.js&quot;,
  },
};
</code></pre>
<p>然后执行命令：</p>
<pre><code class="language-sh">npx webpack
</code></pre>
<p>接下来，添加一个 index.html 文件，引用打包输出的 dist/index.js 文件即可。</p>
<p>最开始，构建工具仅支持 CommonJS 规范，随着 ECMAScript 2015 的发布，rollup.js 最先支持 ES Module，现在主流的构建工具均已支持 ES Module。</p>
<p>打包工具在加载一个库时，需要知道这个库是支持 CommonJS 模块的还是支持 ES Module 的，构建工具给的方案是扩展一个新的入口字段，开源库可以通过设定这个字段来标识自己是否支持 ES Module。</p>
<p>由于历史原因，这个字段有两个命名，分别 module 和 jsnext，目前比较主流的是 module 字段，也可以两个都设置，只需要在库的 package.json 文件中增加字段名 module 和 jsnext，并设置为 ES Module 文件的路径即。</p>
<pre><code class="language-json">{
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;module&quot;: &quot;index.esm.js&quot;,
  &quot;jsnext&quot;: &quot;index.esm.js&quot;
}
</code></pre>
<p>在 webpack 中，可以通过配置 mainFields 来支持优先使用 module 字段，只需要在 webpack.confg.js 文件中添加如下的配置代码即可:</p>
<pre><code class="language-js">module.exports = {
  // 其他配置
  resolve: {
    mainFields: [&quot;module&quot;],
  },
};
</code></pre>
<p>index.js 文件提供对 CommonJS 模块的支持，</p>
<pre><code class="language-js">function clone(source) {
  // 此处省略
}
module.exports = clone;
</code></pre>
<p>index.esm.js 文件提供对 ES Module 的支持，可以看到，支持 ES Module 的写法更加简洁。</p>
<pre><code class="language-js">export function clone(source) {
  // 此处省略
}
</code></pre>
<p>对于库的使用者来说，不用关心 ES Module 规范和 CommonJS 规范之间的区别，只需要像下面代码这样引用即可：</p>
<pre><code class="language-js">const clone = require(&quot;clone&quot;);
</code></pre>
<p>打包工具会优先查看依赖的库是否支持 ES Module，如果不支持，则会遵循 CommonJS 规范。</p>
<p>综上所述，在这种体系下，开源库需要同时提供对 ES Module 和 CommonJS 模块的支持，对其依赖的库不需要进行特殊处理。</p>
<h2>打包方案</h2>
<p>前面介绍了在不同的模块规范和不同的前端技术体系下，库的适配原理。这部分内容细致又琐碎，使用手动适配的方式会相当麻烦，那么有没有更好的办法呢?</p>
<p>目前，比较好的办法就是使用打包工具自动完成打包工作。</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">浏览器（script/AMD/CMD）</th>
<th align="right">打包工具（webpack/rollup.js）</th>
<th align="right">Node.js</th>
</tr>
</thead>
<tbody><tr>
<td>入口文件</td>
<td align="center">index.aio.js</td>
<td align="right">index.esm.js</td>
<td align="right">index.js</td>
</tr>
<tr>
<td>模块规范</td>
<td align="center">UMD</td>
<td align="right">ES Module</td>
<td align="right">CommonJS</td>
</tr>
<tr>
<td>自身依赖</td>
<td align="center">打包</td>
<td align="right">打包</td>
<td align="right">打包</td>
</tr>
<tr>
<td>第三方依赖</td>
<td align="center">打包</td>
<td align="right">不打包</td>
<td align="right">不打包</td>
</tr>
</tbody></table>
<h3>选择打包工具</h3>
<p>既然已经确定了目标，那么接下来就需要选择一款合适的打包工具。社区大多选择 webpack 和 rollup.js 作为库的打包工具,</p>
<p>webpack 是现在非常流行打包工具，而 rollup.js 则被称作下一代打包工具，推荐使用 rollup.js 作为库的打包工具</p>
<p>为什么不使用我们更熟悉的 webpack 呢？我们通过具体示例来对比 webpack 和 rollup.js。假设有两个文件: index.is 和 bar.js。</p>
<p>bar.js 文件对外暴露一个 bar 函数，代码如下:</p>
<pre><code class="language-js">export defualt function bar() {
  console.log(&quot;bar&quot;);
}
</code></pre>
<p>index.js 文件引用 bar.js 文件</p>
<pre><code class="language-js">import bar from &quot;./bar&quot;;
bar();
</code></pre>
<p>下面的代码是 webpack 打包输出的内容，index.js 和 bar.js 文件的内容在打包内容的最下面，起始处省略的 100 行代码其实是 webpack 生成的简易模块系统代码。webpack 方案的问题在于会生成很多冗余代码，这对于业务代码来说问题不大，但是对于库来说就不太友好了。</p>
<p>下面的代码是 rollup.js 打包输出的内容，可以看到模块完全消失了。那么 rollup.js 如何解决模块之间的依赖问题呢？对于打包的代码，rollup.js 巧妙地通过将被依赖的模块放在依赖模块前面的方法来解决模块依赖问题。对比 webpack 打包后的代码，rollup.js 的打包方案对于库的开发者来说是接近完美的方案。</p>
<h3>打包步骤</h3>
<p>首先安装 rollup.js，命令如下:</p>
<pre><code class="language-sh">npm i --save-dev rollup@0.57.1
</code></pre>
<p>由于只在开发时才会用到 rollup.js，因此我们通过上面的参数 <code>--save-dev</code> 将其安装为开发时依赖，这样会将依赖添加到 package.json 文件的 devDependencies 字段中代码如下:</p>
<p>rollup.js 的使用方式和 webpack 的使用方式类似，需要通过配置文件告诉 rollup 如何打包。</p>
<table>
<thead>
<tr>
<th>打包输出文件</th>
<th align="center">配置文件</th>
<th align="right">技术体系</th>
<th align="right">模块规范</th>
</tr>
</thead>
<tbody><tr>
<td>dist/index.js</td>
<td align="center">rollup.config.js</td>
<td align="right">Node.js</td>
<td align="right">CommonJS</td>
</tr>
<tr>
<td>dist/index.esm.js</td>
<td align="center">rollup.config.esm.js</td>
<td align="right">webpack</td>
<td align="right">ES Module</td>
</tr>
<tr>
<td>dist/index.aio.js</td>
<td align="center">rollup.config.aio.js</td>
<td align="right">浏览器</td>
<td align="right">UMD</td>
</tr>
</tbody></table>
<p>接下来，先实现第 1 个配置文件 confg/rollup.confg.js</p>
<pre><code class="language-js">module.exports = {
  input: &quot;src/index.js&quot;,
  output: {
    file: &quot;dist/index.js&quot;,
    format: &quot;cjs&quot;,
  },
};
</code></pre>
<p>input 配置和 output 配置表示将 src/index.js 文件打包输出为 dist/index.js 文件，format 配置表明可以选择的模块方案，其值 cjs 的含义是输出模块遵循 CommonJS 规范。</p>
<p>接下来，运行下面的命令即可实现打包:</p>
<pre><code class="language-sh">npx rollup -c config/rollup.config.js
</code></pre>
<p>打包成功后，打开 dist/index.js 文件，该文件中的内容如下:</p>
<pre><code class="language-js">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true,
});

function clone(source) {
  // 此处省略
}

exports.clone = clone;
</code></pre>
<p>接着实现第 2 个配置文件 config/rollup.confg.esm.js，示例代码如下。</p>
<p>其与实现第 1 个配置文件的代码基本类似，不同点是 format 配置的值，此处为 es，表示输出模块遵循 ES Module 规范。</p>
<pre><code class="language-js">module.exports = {
  input: &quot;src/index.js&quot;,
  output: {
    file: &quot;dist/index.esm.js&quot;,
    format: &quot;es&quot;,
  },
};
</code></pre>
<p>打包成功后，打开 dis/index.esm.js 文件，该文件中的内容如下:</p>
<pre><code class="language-js">function clone(source) {
  // 此处省略
}

export { clone };
</code></pre>
<p>最后实现第 3 个配置文件 <code>config/rollup.confg.aio.js</code>，为了将依赖的库也打包进来，需要使用 <code>rollup-plugin-node-resolve</code> 插件，通过如下命令安装该插件:</p>
<pre><code class="language-sh">npm i rollup-plugin-node-resolve -D
</code></pre>
<p>实现 <code>config/rollup.config.aio.js</code> 文件的完整代码如下，format 配置的值为 umd，表示输出模块遵循 UMD 规范，name 配置的值作为全局变量和 AMD 规范的模块名，plugins 配置使用 rollup-plugin-node-resolve 插件。</p>
<blockquote>
<p>aio 是 all in one 的缩写，表示将全部模块规范和依赖都集成在一起。</p>
</blockquote>
<pre><code class="language-js">var nodeResolve = require(&quot;rollup-plugin-node-resolve&quot;);

module.exports = {
  input: &quot;src/index.js&quot;,
  output: {
    file: &quot;dist/index.aio.js&quot;,
    format: &quot;umd&quot;,
    name: &quot;clone&quot;,
  },
  plugins: [
    nodeResolve({
      main: true,
      extensions: [&quot;.js&quot;],
    }),
  ],
};
</code></pre>
<p>打包成功后，打开 dist/index.aio.js 文件，该文件中的内容如下:</p>
<pre><code class="language-js">(function (global, factory) {
  typeof exports === &quot;object&quot; &amp;&amp; typeof module !== &quot;undefined&quot;
    ? factory(exports)
    : typeof define === &quot;function&quot; &amp;&amp; defined.amd
    ? define([&quot;exports&quot;], factory)
    : factory((global.clone = {}));
})(this, function (exports) {
  &quot;use strict&quot;;
  function type(data) {
    // 此处省略
  }
  function clone(source) {
    // 此处省略
  }
  exports.clone = clone;
  Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
});
</code></pre>
<p>每次都执行 <code>rollup -c config/rollup.confg.js</code> 命令有些烦琐，为了简化构建命令，同时收敛统一构建命令，可以使用 npm 提供的自定义 scripts 功能。在 package.json 文件中添加下面的代码:</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build:self&quot;: &quot;rollup -c config/rollup.config.js&quot;,
    &quot;build:esm&quot;: &quot;rollup -c config/rollup.config.esm.js&quot;,
    &quot;build:aio&quot;: &quot;rollup -c config/rollup.config.aio.js&quot;,
    &quot;build&quot;: &quot;npm run build:self &amp;&amp; npm run build:esm &amp;&amp; npm run build:aio&quot;
  }
}
</code></pre>
<p>直接运行下面的命令就可以完成对所有方案的打包:</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>由于现在入口文件位于 dist 目录下，因此需要修改 package.json 文件中相应的字段，指向 dist 目录下的构建文件。改动后的内容如下:</p>
<pre><code class="language-json">{
  &quot;main&quot;: &quot;dist/index.js&quot;,
  &quot;jsnext:main&quot;: &quot;dist/index.esm.js&quot;,
  &quot;module&quot;: &quot;dist/index.esm.js&quot;
}
</code></pre>
<h3>添加 banner</h3>
<p>一般开源库文件的顶部都会提供一些关于库的说明，如协议信息等，如</p>
<pre><code class="language-js">/**
 * clone: 1.0.0
 * License: MIT
 */
</code></pre>
<p>下面给我们的库添加统一的说明。现在用户使用的文件是自动构建出来的，无法手动添加，其实 rollup.js 支持添加统一的 banner 信息，</p>
<p>由于不同的配置文件需要同样的 banner，因此可以将 banner 信息统一放到 rollup.js 文件中</p>
<pre><code class="language-js">var pkg = require(&quot;./package.json&quot;);
var version = pkg.version;

var banner = `
/*!
 * ${pkg.name} ${version}
 * @license under MIT
 */
`;

exports.banner = banner;
</code></pre>
<p>然后修改配置文件，添加 banner 配置。以 rollup.config.esm.js 文件为例，修改后的代码如下:</p>
<pre><code class="language-js">var { banner } = require(&quot;./rollup.config&quot;);
module.exports = {
  input: &quot;src/index.js&quot;,
  output: {
    file: &quot;dist/index.esm.js&quot;,
    format: &quot;es&quot;,
    banner,
  },
};
</code></pre>
<h3>按需加载</h3>
<p>很多时候，在使用一个库时可能只会用到其中的一小部分功能，但是却要加载整个库的内容，这对于 Node.js 来说问题不大，但对于浏览器端应用来说是不能接受的，好在 rollup.js 支持按需加载。</p>
<p>按需加载分为两种情况:</p>
<p><strong>第一种情况是</strong>，我们的库要用到另一个库的功能，但只用到其中一小部分功能如果将其全部打包过来，则会让打包体积变大，此时通过 rollup.js 提供的 treeshaking 功能可以自动屏蔽未被使用的功能。</p>
<p>例如，假设 index.js 文件只使用了第三方包 is.js 中的一个 isString 函数，当不使用 treeshaking 功能时，会将 is.js 中的函数全部引用进来</p>
<p>而在使用了 treeshaking 功能后，则可以屏蔽 is.js 中的其他函数，仅引用 isString 函数</p>
<p><strong>第二种情况是</strong>，要让使用库的项目能够按需加载。一个库如果不进行任何配置，那么现代打包工具是不会使用 treeshaking 功能对其进行优化的，因为打包工具无法知道一个库是否有副作用。假如我们的库中有如下代码，如果引用了该库，就会向 window 下写入一个变量，打包工具如果把这段代码屏蔽，则可能产生 Bug。</p>
<pre><code class="language-js">window.aaa = 1;
</code></pre>
<p>如果我们的库没有副作用，则可以向 package.json 文件中添加 sideEffects 字段，这样打包工具就能够使用 treeshaking 功能进行优化了。</p>
<pre><code class="language-json">{
  &quot;sideEffects&quot;: false
}
</code></pre>
<p>至此，库打包的全部工作就完成了。</p>
<h2>兼容方案</h2>
<p>当我们的库被用到生产环境时，由于真实用户的浏览器环境不可控，因此会在库用到一些新的语言特性时产生报错。</p>
<p>例如，库代码中使用了 ECMAScript 2015 中新的变量声明关键字 const，此时如果用户使用正 IE9 浏览器，则会产生一个语法错误。</p>
<p>由于 JavaScript 的错误是中断式的。因此会导致整个页面失去响应，这显然是不能接受的。</p>
<h3>确定兼容环境</h3>
<p>想要解决上述问题，需要库的开发者给出关于库的兼容性的明确说明，这样库的使用者可以根据自己的需求挑选适合的库。对于 JavaScript 库来说，兼容性越好，其使用范围就越广泛，同时意味着付出的成本会越高。所以，库的开发者需要权衡利弊，做一个折中的选择。</p>
<p>那么，都有哪些环境需要兼容呢？目前，需要兼容的环境主要包括浏览器和 Node.js，<code>statcounter</code> 是一款统计全球浏览器市场份额的工具，提供了详细的数据，可以帮助库的开发者确定要兼容的环境。对于国内浏览器市场份额数据，可以查看<code>百度流量研究院发布</code>的数据。</p>
<blockquote>
<p>需要兼容的自主内核浏览器主要包括 Chrome、Firefox、IE、Edge 和 Safari。移动端浏览器的情况会更加复杂，但是兼容性和桌面端相比已经非常好了。对于 JavaScript 来说，以桌面端浏览器的兼容性为标准即可。</p>
</blockquote>
<p>Node.js 的兼容性情况会好很多，可以参考官方提供的 metrics 数据，包括不同版本的下载数据，</p>
<p>不同的库可以选择更宽泛或更严格的兼容性要求，但请进行严格测试，并明确告知库的使用者。如果是为某些特殊场景服务的库，比如与 Canvas 相关的库，那么其兼容性与 Canvas 对齐即可。</p>
<h3>ECMAScript 5 兼容方案</h3>
<p>如何知道自己编写的代码是否存在兼容性问题呢？原来解决此类问题都是依靠开发者的经验，掌握前端常用的特性在不同浏览器上的兼容性情况，是评判一个前端开发者的经验是否丰富的指标之一，如是否知道 IE8 浏览器上缺少 Anray.prototype.indexOf 方法。</p>
<p>当遇到不熟悉的语法或方法时，可以在 MDN 网站上查看语法或方法的详细兼容性信息。</p>
<p>除了 MDN，还可以通过 caniuse 网站查询更详细的兼容性信息。</p>
<p>下面我们来系统分析目前 JavaScript 语言不同特性的兼容性情况。大体来说，JavaScript 语言可以分为 ECMAScript 5 之前的版本、ECMAScript 5 和 ECMAScript 5 之后的版本，ECMAScript 5 之前的特性是非常安全的。</p>
<p>使用 ECMAScript 5 及之后的版本可能存在兼容性问题，<strong>compat-table</strong> 网站记录了 JavaScript 语言不同版本的兼容性情况。可以看到，只有 IE8 浏览器上存在兼容性问题。</p>
<h3>ECMAScript 2015 兼容方案</h3>
<p>目前，ECMAScript 2015 及后续版本的兼容性情况还不容乐观，不过每一个 ECMAScript 2015 的特性都可以用 ECMAScript 5 实现，最简单的方法就是直接使用 ECMAScript5 来实现库代码。</p>
<p>但是这种依赖于经验的手动方式效率低下，为此，JavaScript 社区提供了更好的方案，即通过转换器将 ECMAScript 2015 代码自动编译为 ECMAScript 5 代码。</p>
<p>常用的 ECMAScript 2015 转换工具是 Babel，下面给我们的库添加 Babel。首先需要安装 Babel，由于已经使用了 rollup.js，因此还需要安装对应的 rollup.js 插件。</p>
<pre><code class="language-sh">npm i --save-dev rollup-plugin-babel @babel/core @babel/preset-env
</code></pre>
<p>Babel 为每个 ECMAScript 2015 的特性都提供了一个插件，这样可以让开发者自己选择要转换哪些属性。手动维护需要转换的特性是比较烦琐的，这里推荐使用 Babel 的 preset-env 插件，使用 preset-env 插件，只要简单配置需要兼容的环境即可。</p>
<p>preset-env 插件会自动帮助开发者选择相应的插件。在 rollup.js 中使用 Babel 需要配置 plugins，由于 3 个文件都需要配置，因此将其提取到 rollup.js 文件中，</p>
<pre><code class="language-js">// rollup.js
function getCompiler(opt) {
  return babel({
    babelrc: false,
    presets: [
      {
        &quot;@babel/preset-env&quot;,
        {
          targets: {
            browsers:
              &quot;last 2 versions, &gt; 1%, ie &gt;= 8, Chrome &gt;= 45, safari &gt;= 10&quot;,
          },
          node: &quot;0.12&quot;
        },
        modeuls: false,
        loose: true // 松散模式
      }
    ],
    exclude: &quot;node_modules/**&quot;
  });
}
exports.getCompiler = getCompiler;
</code></pre>
<p>这里不使用独立的 Babel 配置文件，所以将 babelrc 和 modules 都设置为 false; loose 代表松散模式，将 loose 设置为 true 能够更好地兼容 IE 8 浏览器。</p>
<p>使用下面的命令可以查看 targets 配置对应的浏览器列表:</p>
<pre><code class="language-sh">npx browserslist &quot;last 2 versions, &gt; 1%, ie &gt;= 8, Chrome &gt;= 45, safari &gt;= 10&quot;
</code></pre>
<p>如下：</p>
<pre><code class="language-sh">chrome 132
# ...
edge 130
firefox 134
firefox 133
ie 11
ie 10
ie 9
ie 8
ie_mob 11
ie_mob 10
ios_saf 18.2
ios_saf 18.1
ios_saf 17.6-17.7
kaios 3.0-3.1
kaios 2.5
op_mini all
op_mob 80
opera 114
opera 113
safari 18.2
safari 18.1
safari 18.0
#...
samsung 27
samsung 26
</code></pre>
<p>接下来，分别在 3 个配置文件中添加如下的配置代码:</p>
<pre><code class="language-js">var common = require(&quot;./rollup.js&quot;);

module.exports = {
  plugins: [common.getCompiler()],
};
</code></pre>
<p>现在我们已经解决了 ECMAScript 2015 新语法的兼容性问题，但是如果用到了 ECMAScript 2015 的 API，还是会存在兼容性问题，平时我们在自己的项目中可以引入全局的 polyfill 解决这个问题，但对于库来说这种方法并不友好，会污染全局环境这对于库来说是难以接受的。</p>
<p>core-js 是一个 ECMAScript2015+ 的 polyfill 库，提供了不污染全局环境的使用方式。首先需要安装 core-js，安装命令如下:</p>
<pre><code class="language-sh">npm i core-js --save
</code></pre>
<p>如果想使用 ECMAScript 2015 的 Array.from 功能，可以通过下面的示例代码引入一个本地函数 from，这样不会污染全局环境中的 Array.from 函数。</p>
<pre><code class="language-js">import from from &quot;core-js-pure/features/array/from&quot;;
from(&quot;abc&quot;); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>如果还想使用其他的 API，则只需要分别引入即可，不过这种方式虽然能够解决问题，但是需要手动引入依赖。而 Babel 集成了 core-js，可以通过编译自动将我们用到的 API 转换为上面的 core-js 方式。要使用这个功能，首先需要安装两个插件。</p>
<pre><code class="language-sh">npm i @babel/plugin-transform-runtime --save-dev
npm i @babel/runtime-corejs2 --save
</code></pre>
<p>然后修改 rollup.js 文件中的 Babel 配置，</p>
<pre><code class="language-js">{
  plugins: [
    [
      &quot;@babel/plugin-transform-runtime&quot;,
      {
        corejs: 2,
      },
    ],
  ];
}
</code></pre>
<p>现在直接在源代码中使用 Array.from 函数，</p>
<pre><code class="language-js">Array.from(&quot;abc&quot;); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>重新构建，编译完成后的代码如下，可以看到 Array.from 函数被替换了，编译结果和上面手动使用 core-js 的结果一样。</p>
<pre><code class="language-js">import _Array$from from &quot;@babel/runtime-corejs2/core-js/array/from&quot;;
_Array$from(&quot;abc&quot;); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>至此，我们就可以使用 ECMAScript 2015+ 的新语法和 API 了，通过编译将 ECMAScript 2015+ 代码转换为 ECMAScript5 代码,</p>
<img src="../imgs/139/04.png" />
        </article>
      </main>

      <!-- Table of Contents Sidebar -->
      <aside class="toc-sidebar">
        <div class="toc-header">
          <h3>Table of Contents</h3>
        </div>
        <div class="toc-content" id="tocContent">
          <!-- TOC will be generated dynamically -->
        </div>
      </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M12 19V5M5 12l7-7 7 7" />
      </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(
          135deg,
          var(--accent),
          rgba(59, 130, 246, 0.8)
        );
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
      @media screen and (max-width: 768px) {
        .back-to-top {
          right: 15px;
          bottom: 15px;
          width: 36px;
          height: 36px;
        }
      }

      @media screen and (max-width: 480px) {
        .back-to-top {
          right: 12px;
          bottom: 12px;
          width: 32px;
          height: 32px;
        }
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // Sidebar Toggle
      const toggleBtn = document.getElementById("toggleSidebar");
      const sidebar = document.querySelector(".sidebar");
      const mainContent = document.querySelector(".main-content");

      function toggleSidebar() {
        sidebar.classList.toggle("hidden");
        // Store sidebar state in localStorage
        localStorage.setItem(
          "sidebarHidden",
          sidebar.classList.contains("hidden")
        );
      }

      toggleBtn.addEventListener("click", toggleSidebar);

      // Keyboard shortcut (Ctrl + B)
      window.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "b") {
          e.preventDefault(); // Prevent browser's default behavior
          toggleSidebar();
        }
      });

      // Restore sidebar state from localStorage
      document.addEventListener("DOMContentLoaded", () => {
        const sidebarHidden = localStorage.getItem("sidebarHidden") === "true";
        if (sidebarHidden) {
          sidebar.classList.add("hidden");
        }
      });

      // Generate Table of Contents
      function generateTOC() {
        const article = document.querySelector(".content-body");
        const headings = article.querySelectorAll("h1, h2, h3, h4");
        const tocContent = document.getElementById("tocContent");
        const toc = document.createElement("ul");

        headings.forEach((heading, index) => {
          const id = `heading-${index}`;
          heading.id = id;

          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = `#${id}`;
          a.textContent = heading.textContent;
          a.className = `toc-level-${heading.tagName.toLowerCase()}`;

          li.appendChild(a);
          toc.appendChild(li);
        });

        tocContent.appendChild(toc);
      }

      // Initialize TOC
      document.addEventListener("DOMContentLoaded", generateTOC);

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }

      // 监听 ctrl + b
      window.addEventListener("keydown", (e) => {
        const leftDom = document.querySelector(".sidebar");
        if (e.ctrlKey && e.key === "b") {
          leftDom.classList.toggle("hidden");
        }
      });

      // Modal
      // const modal = document.getElementById("myModal");
      // const modalContent = modal.querySelector(".modal-content");
      // const openModal = document.getElementById("openModal");
      // const close = modal.querySelector(".close");

      // openModal.addEventListener("click", () => {
      //     modal.style.display = "block";
      // });

      // close.addEventListener("click", () => {
      //     modal.style.display = "none";
      // });

      // window.addEventListener("click", (e) => {
      //     if (e.target === modal) {
      //         modal.style.display = "none";
      //     }
      // });

      // Back to top button
      const backToTop = document.getElementById("backToTop");
      window.addEventListener("scroll", () => {
        if (window.scrollY > 200) {
          backToTop.style.display = "block";
        } else {
          backToTop.style.display = "none";
        }
      });

      backToTop.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      // Theme toggle
      document.addEventListener("DOMContentLoaded", () => {
        const themeToggle = document.getElementById("themeToggle");
        const html = document.documentElement;
        const prismTheme = document.getElementById("prismTheme");

        // Function to update theme and stylesheet
        function updateTheme(theme) {
          html.className = theme;
          prismTheme.href = `../css/prism${theme === "dark" ? "2" : ""}.css`;
          localStorage.setItem("theme", theme);
        }

        // Check for saved theme preference
        const savedTheme = localStorage.getItem("theme") || "light";
        updateTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const currentTheme = html.className;
          const newTheme = currentTheme === "light" ? "dark" : "light";
          updateTheme(newTheme);
        });
      });
    </script>
  </body>
</html>
