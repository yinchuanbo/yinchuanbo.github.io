<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>Vue Router</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link id="prismTheme" rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
    <style>
      /* Animation Styles */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .slide-in {
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .button {
        transition: background-color 0.3s, transform 0.3s;
      }

      .button:hover {
        background-color: #3700b3;
        transform: scale(1.05);
      }

      /* Tooltip Styles */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 5px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -60px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>
  </head>

  <body class="fade-in">
    <button
      class="toggle-sidebar"
      id="toggleSidebar"
      aria-label="Toggle Sidebar"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <div class="app-container">
      <!-- Sidebar Navigation -->
      <nav class="sidebar">
        <div class="sidebar-content">
          <div class="nav-section"><li class=""><a title="TypeScript 的进阶详解" href="/md/TypeScript 的进阶详解.html">22 TypeScript 的进阶详解</a></li><li class=""><a title="Vuex 状态管理" href="/md/Vuex 状态管理.html">21 Vuex 状态管理</a></li><li class="active"><a title="Vue Router" href="/md/Vue Router.html">20 Vue Router</a></li><li class=""><a title="Vue 3 异常处理终极秘籍" href="/md/Vue 3 异常处理终极秘籍.html">19 Vue 3 异常处理终极秘籍</a></li><li class=""><a title="组件化高级详解" href="/md/组件化高级详解.html">18 组件化高级详解</a></li><li class=""><a title="你还不会调试线上 vue 组件" href="/md/你还不会调试线上 vue 组件.html">17 你还不会调试线上 vue 组件</a></li><li class=""><a title="如何构建高效的 Vue 3 前端项目结构" href="/md/如何构建高效的 Vue 3 前端项目结构.html">16 如何构建高效的 Vue 3 前端项目结构</a></li><li class=""><a title="vue3 vite 使用 代理转发" href="/md/vue3 vite 使用 代理转发.html">15 vue3 vite 使用 代理转发</a></li><li class=""><a title="分享一些 Vue 实用且常用的开发工具库" href="/md/分享一些 Vue 实用且常用的开发工具库.html">14 分享一些 Vue 实用且常用的开发工具库</a></li><li class=""><a title="Motion Vue 尤雨溪力荐的 Vue 动画库" href="/md/Motion Vue 尤雨溪力荐的 Vue 动画库.html">13 Motion Vue 尤雨溪力荐的 Vue 动画库</a></li><li class=""><a title="Composition API 详解" href="/md/Composition API 详解.html">12 Composition API 详解</a></li><li class=""><a title="实现过渡动画" href="/md/实现过渡动画.html">11 实现过渡动画</a></li><li class=""><a title="组件化进阶详解" href="/md/组件化进阶详解.html">10 组件化进阶详解</a></li><li class=""><a title="组件化基础详解" href="/md/组件化基础详解.html">09 组件化基础详解</a></li><li class=""><a title="组件化开发" href="/md/组件化开发.html">08 组件化开发</a></li><li class=""><a title="v-model和表单输入" href="/md/v-model和表单输入.html">07 v-model和表单输入</a></li><li class=""><a title="vue3 的 Options API" href="/md/vue3 的 Options API.html">06 vue3 的 Options API</a></li><li class=""><a title="模板语法和内置命令" href="/md/模板语法和内置命令.html">05 模板语法和内置命令</a></li><li class=""><a title="前端 vue 项目使用 ffmpeg 处理视频" href="/md/前端 vue 项目使用 ffmpeg 处理视频.html">04 前端 vue 项目使用 ffmpeg 处理视频</a></li><li class=""><a title="Vue Router 4 的 scrollBehavior 方法" href="/md/Vue Router 4 的 scrollBehavior 方法.html">03 Vue Router 4 的 scrollBehavior 方法</a></li><li class=""><a title="浅浅聊一下 vue 中的 nextTick 的实现原理" href="/md/浅浅聊一下 vue 中的 nextTick 的实现原理.html">02 浅浅聊一下 vue 中的 nextTick 的实现原理</a></li><li class=""><a title="Vue3.x 生态最能打的组合" href="/md/Vue3.x 生态最能打的组合.html">01 Vue3.x 生态最能打的组合</a></li></div>
        </div>
      </nav>

      <!-- Main Content Area -->
      <main class="main-content">
        <header class="content-header">
          <div class="header-left">
            <h1 class="page-title">Vue Router</h1>
            <p class="time">HaoTian · 2025-01-22 09:08:46</p>
          </div>
          <div class="header-right">
            <div class="tag-container">
              <span class="tag">Vue</span>
            </div>
            <button
              id="themeToggle"
              class="theme-toggle"
              aria-label="Toggle theme"
            >
              <svg
                class="sun-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
              <svg
                class="moon-icon"
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
            </button>
            <button
              class="theme-toggle"
              aria-label="Toggle theme"
              style="width: 36px; height: 36px"
              onclick="window.location.href='/md';"
            >
              <svg
                t="1737442501710"
                class="icon"
                viewBox="0 0 1024 1024"
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
                p-id="5258"
                width="20"
                height="20"
              >
                <path
                  d="M883.773793 626.047476c-17.308201 0-31.408337 14.029528-31.408337 31.304983l0 207.437469c0 17.204847-14.098089 31.302937-31.406291 31.302937L203.040834 896.092865c-17.340947 0-31.408337-14.098089-31.408337-31.302937L171.632497 657.352459c0-17.275455-14.099113-31.304983-31.408337-31.304983-17.380856 0-31.444153 14.029528-31.444153 31.304983l0 207.437469c0 51.773154 42.261523 93.91188 94.260827 93.91188l617.918331 0c52.031027 0 94.259804-42.139749 94.259804-93.91188L915.21897 657.352459C915.21897 640.077004 901.152603 626.047476 883.773793 626.047476L883.773793 626.047476zM230.262826 614.286618c55.523571 0 104.556311-27.674293 134.394896-69.762877 32.487925 46.451962 86.303598 77.0744 147.343813 77.0744 61.036122 0 114.846678-30.623461 147.306974-77.0744 29.943986 42.018999 78.902024 69.762877 134.426619 69.762877 90.948385 0 164.968216-73.77526 164.968216-164.371628 0-11.062963-2.342348-22.859637-5.130857-35.178197-0.209778-1.134847 0.031722-2.26867-0.277316-3.38612l-0.629333-2.267647c-0.24764-0.924045-0.140193-1.535983-0.352017-2.547009-0.138146-0.505513-0.521886-0.87288-0.695848-1.39579l-85.364203-316.671313c-3.699252-13.645788-16.051581-23.172769-30.293957-23.172769L187.965487 65.296145c-14.238282 0-26.665313 9.526981-30.360472 23.24133L72.309374 405.1566c-0.103354 0.50756-0.48607 0.820692-0.62524 1.309832-0.210801 0.942465-0.107447 1.639337-0.349971 2.511193l-0.62524 2.373047c-0.318248 1.11745 0 2.25025-0.210801 3.38612-2.863211 12.31856-5.201465 24.115234-5.201465 35.178197C65.295634 540.511357 139.315464 614.286618 230.262826 614.286618L230.262826 614.286618z"
                  fill="currentColor"
                  p-id="5259"
                ></path>
              </svg>
            </button>
          </div>
        </header>

        <!-- Article Content -->
        <article
          class="content-body md md "
        >
          <h2>Vue Router 的基本使用</h2>
<p>使用 Vue Router 可以分为以下 6 个步骤:</p>
<ol>
<li><p>在项目根目录执行 <code>npm install vue-router@4</code>，安装 Vue Router 插件</p>
</li>
<li><p>创建路由组件，也可以理解为创建页面组件</p>
</li>
<li><p>配置路由映射，在 routes 数组中配置路由组件和路径之间的映射关系。</p>
</li>
<li><p>通过 createRouter 创建路由对象，并传入 routes 和 history 模式(或 hash 模式)</p>
</li>
<li><p>使用 app.use 函数将路由插件安装到 Vue3 框架中</p>
</li>
<li><p>通过 Vue Router 内置的<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>组件使用路由。</p>
</li>
</ol>
<h3>路由的基本使用</h3>
<p><strong>第一步:安装 Vue Router</strong></p>
<pre><code class="language-sh">npm install vue-router@4.0.14
</code></pre>
<p><strong>第二步:创建路由组件</strong></p>
<pre><code class="language-sh">|-- src
   |-- pages
      |- Home.vue
      |- About.vue
</code></pre>
<pre><code class="language-html">&lt;!-- Home.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;Home Page&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- About.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;About Page&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><strong>第三步和第四步: 配置路由映射和创建路由对象</strong></p>
<pre><code class="language-sh">|-- src
   |-- router
      |- index.js
</code></pre>
<pre><code class="language-js">// src/router/index.js
import { createRouter, createWebHistory } from &quot;vue-router&quot;;
import Home from &quot;../pages/Home.vue&quot;;
import About from &quot;../pages/About.vue&quot;;

const routes = [
  { path: &quot;/home&quot;, component: Home },
  { path: &quot;/about&quot;, component: About },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;
</code></pre>
<p><strong>第五步: 将路由插件安装到 Vue3 框架中</strong></p>
<p>src/main.js</p>
<pre><code class="language-js">import { createApp } from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
import router from &quot;./router&quot;;
const app = createApp(App);
app.use(router); // 安装路由插件
app.mount(&quot;#app&quot;);
</code></pre>
<p><strong>第六步: 通过 router-link 和 router-view 使用路由</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;nav&quot;&gt;
    &lt;!-- 切换路由，即切换页面 --&gt;
    &lt;router-link class=&quot;tab&quot; to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;
    &lt;router-link class=&quot;tab&quot; to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;
  &lt;/div&gt;
  &lt;!-- 路由组件的占位 --&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/template&gt;
</code></pre>
<p>需要注意的是，如果在浏览器中直接输入 <code>http://locahost:8080/</code>，并按 Enter 键，会发现页面中的 <code>&lt;router-view&gt;</code> 组件处并没有显示任何内容。此时，如果按 F12 键打开调试工具查看控台，提示未匹配到路由的默认路径。为了解决这个问题,下介绍路由配置的细节。</p>
<h3>路由配置的细节</h3>
<p><strong>1. 路由的默认路径</strong></p>
<p>默认情况下，当进入网站首页时，我们希望 <code>&lt;router-view&gt;</code> 组件处默认渲染首页 (Home.vue) 的内容。然而，在上述案例中，默认情况下并没有显示首页组件，而是需要单击 “首页” 按才显示。</p>
<p>为了让访问根路径时默认跳转到首页，我们需要在路由配置中设置默认路径 (/)，</p>
<pre><code class="language-js">// src/router/index.js
// ...
const routes = [
  { path: &quot;/&quot;, redirect: &quot;/home&quot; },
  { path: &quot;/home&quot;, component: Home },
  { path: &quot;/about&quot;, component: About },
];
// ...
</code></pre>
<p><strong>2. 路由的 history 模式</strong></p>
<p><strong>3. 路由的 router-link 组件</strong></p>
<p><code>&lt;router-link&gt;</code> 是 Vue Router 的内置组件，我们可以使用它来创建链接并切换 URL，从而使 Vue Router 可以在不重新加载页面的情况下更改 URL。该组件还可以对以下属性进行配置。</p>
<p>(1) to 属性</p>
<p>表示目标路由的链接。当 <code>&lt;router-link&gt;</code> 组件被单击后，内部会立刻把 to 的值传给 <code>router.push() API</code>，以实现页面跳转，因此这个值可以是一个字符串或一个对象，代码如下所示:</p>
<pre><code class="language-html">&lt;router-link class=&quot;tab&quot; to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;
&lt;router-link class=&quot;tab&quot; :to=&quot;{ path: &#39;/home&#39; }&quot;&gt;首页&lt;/router-link&gt;
</code></pre>
<p>(2) replace 属性</p>
<p>设置 replace 属性后，当 <code>&lt;router-link&gt;</code> 组件被单击后，会调用 <code>router.replace() API</code> 实现页面跳转。</p>
<p>这次页面跳转是直接替换当前页面，页面不会被压入浏览器的历史栈中。因此，页面跳转后，浏览器无法使用返回功能，代码如下所示:</p>
<pre><code class="language-html">&lt;router-link class=&quot;tab&quot; to=&quot;/home&quot; replace&gt;首页&lt;/router-link&gt;
&lt;router-link class=&quot;tab&quot; to=&quot;/about&quot; replace&gt;关于&lt;/router-link&gt;
</code></pre>
<p>(3) active-class 属性</p>
<p>设置 <code>&lt;a&gt;</code> 元素激活后应用的 class，默认的 class 是 <code>router-link-active</code></p>
<p>更改 class 的默认值：</p>
<pre><code class="language-html">&lt;router-link :to=&quot;{ path: &#39;/home&#39; }&quot; active-class=&quot;why&quot;&gt;首页&lt;/router-link&gt;
</code></pre>
<p>(4) exact-active-class 属性</p>
<p>链接精准激活（即 URL 和 to 上配置的路径需完全一样），用于设置 <code>&lt;a&gt;</code> 元素被激活的 class，默认是 router-link-exact-active。该属性的用法和 active-class 属性类似，</p>
<pre><code class="language-html">&lt;router-link :to=&quot;{ path: &#39;/home&#39; }&quot; exact-active-class=&quot;coderwhy&quot;
  &gt;首页&lt;/router-link
&gt;
</code></pre>
<p><strong>4. 路由的懒加载</strong></p>
<p>在真实开发过程中，一个项目可能会包含大量页面组件。如果这些组件都没有使用异步加载，那么在打包构建生产项目时，JavaScript 包会变得非常大，从而影响页面的首屏加载速度</p>
<p>为了解决这个问题，可以将不同路由对应的组件分割成不同的代码块，然后在访问路由时才加载对应的组件。这种做法不仅更加高效，还可以提高首屏加载速度。实际上，Vue Router 默认就支持异步加载组件，也就是所谓的路由懒加载。</p>
<ul>
<li>修改 src/router/index.js</li>
</ul>
<pre><code class="language-js">// src/router/index.js
import { createRouter, createWebHistory } from &quot;vue-router&quot;;
// import Home from &quot;../pages/Home.vue&quot;;
// import About from &quot;../pages/About.vue&quot;;

const routes = [
  { path: &quot;/&quot;, redirect: &quot;/home&quot; },
  { path: &quot;/home&quot;, component: () =&gt; import(&quot;../pages/Home.vue&quot;) },
  { path: &quot;/about&quot;, component: () =&gt; import(&quot;../pages/About.vue&quot;) },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;
</code></pre>
<blockquote>
<p>需要注意的是: component 属性既可以接收一个组件，也可以接收一个函数。当接收函数时，该函数需返回 Promise 对象。</p>
</blockquote>
<p>可以发现，配置了路由懒加载会进行分包，但分出来的包的名称都是随机生成的。实际上，自 webpack3.x 起，就支持对分包进行命名(chunk name)。在 import 函数的参数中添加魔法注释，例如 <code>/* webpackChunkName: &quot;自定义分包名&quot; */</code>，即可对分包进行命名、</p>
<pre><code class="language-js">const routes = [
  { path: &quot;/&quot;, redirect: &quot;/home&quot; },
  {
    path: &quot;/home&quot;,
    component: () =&gt;
      import(/* webpackChunkName: &quot;home-chunk&quot; */ &quot;../pages/Home.vue&quot;),
  },
  {
    path: &quot;/about&quot;,
    component: () =&gt;
      import(/* webpackChunkName: &quot;about-chunk&quot; */ &quot;../pages/About.vue&quot;),
  },
];
</code></pre>
<p><strong>5. 路由的其他属性</strong></p>
<p>在配置路由映射时，除了可以配置 path 和 component 属性，实际上路由还支持配置其他属性，举例如下:</p>
<p>(1) name 属性: 为路由添加一个独一无二的名称</p>
<p>(2) meta 属性: 为路由附加自定义数据</p>
<pre><code class="language-js">const routes = [
  {
    path: &quot;/about&quot;,
    name: &quot;about&quot;,
    component: () =&gt;
      import(/* webpackChunkName: &quot;about-chunk&quot; */ &quot;../pages/About.vue&quot;),
    meta: {
      name: &quot;why&quot;,
      age: 18,
    },
  },
];
</code></pre>
<p>接下来，可以在 About.vue 页面的 setup 函数中调用 useRoute 函数，以获取对应的路由配置信息，</p>
<pre><code class="language-js">import { useRoute } from &quot;vue-router&quot;;
export default {
  setup() {
    const route = useRoute();
    console.log(route.name); // about
    console.log(route.meta); // { name: &#39;why&#39;, age: 18 }
  },
};
</code></pre>
<h2>Vue Router 进阶知识</h2>
<h3>动态路由的匹配</h3>
<p>通常，我们需要将符合特定匹配规则的路由映射到同一个组件中，例如，我们有一个 User.vue 页面，它应该对所有用户进行渲染</p>
<ul>
<li><p>当访问 <a href="http://localhost:8080/user/why">http://localhost:8080/user/why</a> 时，应该渲染 why 用户的信息</p>
</li>
<li><p>当访问 <a href="http://localhost:8080/user/kobe">http://localhost:8080/user/kobe</a> 时，应该渲染 kobe 用户的信息</p>
</li>
</ul>
<p>为了实现该功能，可以使用 VueRouter 的动态路由，即在路径中使用一个动态路径参数，也称路径参数或路由参数。</p>
<p><strong>第一步: 基本匹配规则</strong></p>
<pre><code class="language-sh">|-- src
   |-- pages
      |- User.vue
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;user&quot;&gt;User Page&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>接着，在 <code>src/router/index.js</code> 文件中添加 User.vue 页面的路由配置</p>
<pre><code class="language-js">const routes = [
  //...
  {
    path: &quot;/user/:username&quot;,
    component: () =&gt; import(&quot;../pages/User.vue&quot;),
  },
];
</code></pre>
<p>然后，在 <code>src/app.vue</code> 中添加一个切换到用户页面的按钮链接</p>
<pre><code class="language-html">&lt;router-link class=&quot;tab&quot; to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;
&lt;router-link class=&quot;tab&quot; to=&quot;/user/why&quot;&gt;用户&lt;/router-link&gt;
</code></pre>
<p>路径参数使用冒号标记，比如 <code>:userame</code>。当匹配到一个路由时，路径参数值会被设置到 <code>this.$route.params</code> 中。因此，我们可以通过以下方法在 User.vue 组件中获取该路径参数值。</p>
<p>(1) 在 template 中直接通过 <code>$route.params</code> 获取值</p>
<p>(2) 在 created 等生命周期中通过 <code>this.$route.params</code> 获取值</p>
<p>(3) 在 setup 中使用 vue-router 提供的 useRoute 函数，该函数会返回一个存放当前路由信息的 Route 对象</p>
<ul>
<li>修改 User.vue 组件</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;user&quot;&gt;User Page: {{ $route.params.username }}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    created() {
      console.log(this.$route.params.username);
    },
    setup() {
      const route = useRoute();
      console.log(route.params.username);
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>第二步: 匹配多个参数值</strong></p>
<p>动态路由支持匹配多个参数，因此可以在路径中配置两个动态路径参数。例如，首先在 User.vue 页面的路由配置信息的 path 属性上，添加一个新的动态路径参数:id，</p>
<pre><code class="language-js">const routes = [
  //...
  // 定义 :username 和 :id 两个动态路径参数
  {
    path: &quot;/user/:username/id/:id&quot;,
    component: () =&gt; import(&quot;../pages/User.vue&quot;),
  },
];
</code></pre>
<p>接着，将 <code>src/app.vue</code> 中 <code>&lt;router-link&gt;</code> 组件 to 属性的值改为 <code>/user/why/id/0001</code></p>
<pre><code class="language-html">&lt;router-link class=&quot;tab&quot; to=&quot;/user/why/id/0001&quot;&gt;用户&lt;/router-link&gt;
</code></pre>
<ul>
<li>修改 User.vue 组件</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;user&quot;&gt;
    User Page: {{ $route.params.username }} - {{ $route.params.id }}
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    created() {
      console.log(this.$route.params.username, this.$route.params.id);
    },
    setup() {
      const route = useRoute();
      console.log(route.params.username, route.params.id);
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>第三步: 跳转到 NotFound 页面</strong></p>
<p>对于未匹配到的路由，我们通常会让其跳转到一个固定的页面，比如 NotFound (404) 页面、为了实现 404 页面，我们可以编写一个专门用于匹配所有页面的路由，将其指向 404 页面</p>
<pre><code class="language-js">// src/router/index.js
const routes = [
  //...
  {
    // 使用通配符 * 来匹配任意路径，通配符路由应放在最后
    path: &quot;/:pathMatch(.*)&quot;,
    component: () =&gt; import(&quot;../pages/NotFound.vue&quot;),
  },
];
</code></pre>
<pre><code class="language-html">&lt;!-- NotFound.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;not-found&quot;&gt;404 Not Found&lt;/div&gt;
  &lt;!-- 获取路径参数值 --&gt;
  &lt;h4&gt;{{ $route.params.pathMatch }}&lt;/h4&gt;
&lt;/template&gt;
</code></pre>
<p>匹配所有页面的规则还有另一种写法，</p>
<pre><code class="language-js">// src/router/index.js
const routes = [
  //...
  {
    path: &quot;/:pathMatch(.*)*&quot;,
    component: () =&gt; import(&quot;../pages/NotFound.vue&quot;),
  },
];
</code></pre>
<p>如果省略了最后的 <code>*</code>，那么在解析或跳转时，参数中的 / 字符将被编码。</p>
<p>如果打算直接使用未匹配的路径名称导航到该路径，那么这个 <code>*</code> 是必需的。</p>
<p>如果多加了一个 <code>*</code>，那么路由参数会被解析为数组格式。</p>
<h3>嵌套路由的使用</h3>
<p>目前我们匹配的 Home.vue、About.vue 和 User.vue 页面等都属于底层路由(即一级路由)，可以在它们之间任意切换。</p>
<p>大部分情况下，像 Home.vue 页面本身也会存在多个组件来回切换例如，Home.vue 页面中又包括 Product.vue 和 Message.vue 页面，它们可以在 Home.vue 页面内部来回切换。</p>
<p>为了实现该功能，需要用到<strong>嵌套路由</strong>，我们可以在 Home.vue 页面中也使用 <code>&lt;router-view&gt;</code> 组件对需要渲染的组件进行占位。下面演示嵌套路由使用。</p>
<pre><code class="language-sh">|-- src
   |-- pages
      |- Home.vue
      |- HomeMessage.vue
      |- HomeShops.vue
</code></pre>
<pre><code class="language-html">&lt;!-- HomeMessage.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;home-message&quot;&gt;
    &lt;h4&gt;Home Message 组件&lt;/h4&gt;
    &lt;div&gt;消息通知...&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- HomeShops.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;home-shops&quot;&gt;
    &lt;h4&gt;Home Shops 组件&lt;/h4&gt;
    &lt;div&gt;商品信息...&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>路由配置：</p>
<pre><code class="language-js">// src/router/index.js
const routes = [
  //...
  {
    path: &quot;/home&quot;,
    component: () =&gt; import(&quot;../pages/Home.vue&quot;),
    children: [
      // 在 Home 页面下注册二级路由
      {
        // 二级路由 path 不支持 /message 或 /home/message，直接填 message 即可
        path: &quot;message&quot;,
        component: () =&gt; import(&quot;../pages/HomeMessage.vue&quot;),
      },
      {
        path: &quot;shops&quot;,
        component: () =&gt; import(&quot;../pages/HomeShops.vue&quot;),
      },
    ],
  },
];
</code></pre>
<p>修改 sre/pages/Home.vue 页面</p>
<pre><code class="language-html">&lt;!-- Home.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    &lt;router-link to=&quot;/home/message&quot;&gt;消息&lt;/router-link&gt;
    &lt;router-link to=&quot;/home/shops&quot;&gt;商品&lt;/router-link&gt;
    &lt;!-- 路由占位 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>下面进一步完善该案例，例如，当用户单击 “首页” 按钮时，默认显示消息页面的内容。实际上，只需要在刚才 Home.vue 页面的路由配置的 children 属性中添加路由重定向的配置，即可实现该功能</p>
<pre><code class="language-js">// src/router/index.js
const routes = [
  //...
  {
    path: &quot;/home&quot;,
    component: () =&gt; import(&quot;../pages/Home.vue&quot;),
    children: [
      // 在 Home 页面下注册二级路由
      {
        // 路由重定向
        path: &quot;&quot;,
        redirect: &quot;/home/message&quot;,
      },
      {
        // 二级路由 path 不支持 /message 或 /home/message，直接填 message 即可
        path: &quot;message&quot;,
        component: () =&gt; import(&quot;../pages/HomeMessage.vue&quot;),
      },
      {
        path: &quot;shops&quot;,
        component: () =&gt; import(&quot;../pages/HomeShops.vue&quot;),
      },
    ],
  },
];
</code></pre>
<h3>编程式导航的使用</h3>
<p>除了使用<code>&lt;router-link&gt;</code> 组件实现页面导航，Vue Router 的实例还提供一些与导航相关的方比如 <code>router.push</code> 方法。我们可以通过调用方法实现页面导航，这种方式称为<strong>编程式导航</strong>。</p>
<p><strong>1. 代码实现页面跳转</strong></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;jumpToAbout&quot;&gt;关于&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useRouter } from &quot;vue-router&quot;;
  export default {
    setup() {
      const router = useRouter();
      const jumpToAbout = () =&gt; {
        router.push(&quot;/about&quot;); // 跳转到 “关于” 页面
      };
      return {
        jumpToAbout,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>push 方法不仅可以接收一个字符串类型的参数，还支持接收一个对象类型的参数</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;jumpToAbout&quot;&gt;关于&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useRouter } from &quot;vue-router&quot;;
  export default {
    setup() {
      const router = useRouter();
      const jumpToAbout = () =&gt; {
        router.push({
          path: &quot;/about&quot;,
        }); // 跳转到 “关于” 页面
      };
      return {
        jumpToAbout,
      };
    },
  };
&lt;/script&gt;
</code></pre>
<p>最后，再看一下 OptionsAPI 的实现（更推荐 setup 语法）</p>
<pre><code class="language-html">&lt;template&gt;&lt;/template&gt;
&lt;script&gt;
  export default {
    methods: {
      jumpToAbout() {
        // this.$router.push(&quot;/about&quot;);
        this.$router.push({
          path: &quot;/about&quot;,
        });
      },
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>2. query 参数</strong></p>
<p>当单击 “关于” 按钮跳转到 “关于” 页面时，实际上可以通过查询字符串 (query) 的方式向目标页面传递参数。</p>
<p>以下是使用 setup 和 OptionsAPI 两种方式，通过 query 参数向目标页面传递参数的示例。</p>
<p>(1) setup 方式(推荐)</p>
<pre><code class="language-js">import { useRouter } from &quot;vue-router&quot;;
export default {
  setup() {
    const router = useRouter();
    const jumpToAbout = () =&gt; {
      // route.push(&quot;/about?name=coder&amp;age=20&quot;);
      router.push({
        path: &quot;/about&quot;,
        query: {
          name: &quot;coder&quot;,
          age: 20,
        },
      });
    };
    return {
      jumpToAbout,
    };
  },
};
</code></pre>
<p>(2) OptionsAPI 方式</p>
<pre><code class="language-js">export default {
  methods: {
    jumpToAbout() {
      // this.$router.push(&quot;/about?name=coder&amp;age=20&quot;);
      this.$router.push({
        path: &quot;/about&quot;,
        query: {
          name: &quot;coder&quot;,
          age: 20,
        },
      });
    },
  },
};
</code></pre>
<p>接着，我们可以在 “关于” 页面使用 route 对象获取 query 参数。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;
    &lt;p&gt;{{ $route.query.name }} - {{ $route.query.age }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  import { useRoute } from &quot;vue-router&quot;;
  export default {
    name: &quot;About&quot;,
    setup() {
      const route = useRoute();
      console.log(route.query.name, route.query.age);
    },
  };
&lt;/script&gt;
</code></pre>
<p><strong>3. 替换当前的位置</strong></p>
<p>使用 push 方法进行页面跳转时，默认会进行压栈操作。当用户单击页面上的返回箭头时，可以回退到上一个页面。但是，如果希望在当前页面进行替换操作，不具备回退功能，可以使用 router 对象的 replace 方法。</p>
<pre><code class="language-js">const jumpToAbout = () =&gt; {
  router.replace(&quot;/about&quot;); // 替换当前的位置
};
</code></pre>
<p><strong>4. 页面的前进和后退</strong></p>
<p>若要实现页面的前进和后退功能，可以使用 <code>router.go</code> 方法</p>
<pre><code class="language-js">router.go(1); // 前进一页，与 router.forward 相同
router.go(-1); // 后退一页，与 router.back 相同

// 或者
router.go(3); // 前进3条记录(记录可理解为页面，即前进3个页面)

// 如果没有那么多条记录，则默认失败
router.go(-100);
router.go(100);
</code></pre>
<p>另外，router 对象还提供了 back 和 forward 方法。</p>
<ul>
<li>back 方法: 通过调用 history.back 方法回溯历史，相当于 <code>router.go(-1)</code>。</li>
<li>forward 方法: 通过调用 history.forward 方法前进历史，相当于 <code>router.go(1)</code>。</li>
</ul>
<h3>路由内置组件的插槽</h3>
<p><strong>1. router-link 组件的作用域插槽</strong></p>
<p><code>&lt;router-link&gt;</code> 组件通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 API，主要面向库作者，也可以为开发者提供便利。在 vue-router 3.x 中，<code>&lt;router-link&gt;</code> 有一个 tag 属性，可以决定 <code>&lt;router-link&gt;</code> 到底渲染什么元素。但是从 vue-router 4.x 开始，该属性被移除了，却提供了更具灵活性的 <code>v-slot</code> 的方式，用于定制渲染的内容</p>
<p>v-slot 的使用主要分为两个步骤：</p>
<p>(1) 添加 custom 属性，表示整个元素要自定义。如果不添加该属性，那么自定义的内容会被包裹在一个 <code>&lt;a&gt;</code> 元素中。</p>
<p>(2) 使用 v-slot 作用域插槽获取内部传递的值，具体如下:</p>
<ul>
<li><p>href: 解析后的 URL</p>
</li>
<li><p>route: 解析后规范化的 route 对象</p>
</li>
<li><p>navigate: 触发导航的函数</p>
</li>
<li><p>isActive: 匹配状态</p>
</li>
<li><p>isExactActive: 精准匹配状态</p>
</li>
</ul>
<pre><code class="language-html">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;nav&quot;&gt;
    &lt;!--
      custom: 表示要自定义
    --&gt;
    &lt;router-link class=&quot;tab&quot; to=&quot;/home&quot; custom v-slot=&quot;props&quot;&gt;
      &lt;strong @click=&quot;props.navigate&quot;&gt;首页&lt;/strong&gt;
      &lt;span&gt;{{ props.href }}&lt;/span&gt;
      &lt;span&gt;{{ props.isActive }}&lt;/span&gt;
      &lt;!-- todo: 处理以上的元素，还支持插入自定义的组件 --&gt;
    &lt;/router-link&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><strong>2. router-view 组件的 v-slot</strong></p>
<p><code>&lt;router-view&gt;</code> 组件也提供了一个 v-slot，可以使用 <code>&lt;transition&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 组件包裹路由组件。</p>
<p>下面使用 <code>&lt;router-view&gt;</code> 作用域插槽为页面添加过渡动画和缓存的功能。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;nav&quot;&gt;...&lt;/div&gt;
  &lt;router-view v-slot=&quot;props&quot;&gt;
    &lt;transition name=&quot;why&quot;&gt;
      &lt;component :is=&quot;props.Component&quot; /&gt;
    &lt;/transition&gt;
  &lt;/router-view&gt;
&lt;/template&gt;
</code></pre>
<ol>
<li><p>在 <code>&lt;router-view&gt;</code> 组件上添加 v-slot 指令，通过 props 接收内部提供的插槽参数</p>
</li>
<li><p>在 <code>&lt;router-view&gt;</code> 组件的默认插槽中插入 <code>&lt;transition&gt;</code> 组件。<code>&lt;transition&gt;</code> 组件用于为页面组件添加过渡动画，指定的过渡动画类名为 why，并在 style 标签中编写相应的动面样式，着，将插槽提供的 <code>props.Component</code> 属性动态绑定到 <code>&lt;component&gt;</code> 组件的 is 属性上。</p>
</li>
</ol>
<p>在浏览器中运行后，再次切换页面就会有过渡效果。</p>
<p>除了添加过渡效果，还可以使用 <code>&lt;keep-alive&gt;</code> 组件为页面添加缓存功能，</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;router-view v-slot=&quot;props&quot;&gt;
    &lt;keep-alive&gt;
      &lt;component :is=&quot;props.Component&quot; /&gt;
    &lt;/keep-alive&gt;
  &lt;/router-view&gt;
&lt;/template&gt;
</code></pre>
<h3>动态添加路由</h3>
<p>前面都是在 routes 选项中提前配置好路由，但是在某些情况下，我们需要在应用程序运行后再动态添加或删除路由。例如，根据登录用户的权限，动态注册不同的路由。这时可以使用 <code>addRoute</code> 方法。</p>
<p><strong>1. addRoute</strong></p>
<p>addRoute 方法可以动态添加一条新的路由规则。如果该路由规则有 name 属性，并且己经存在一个与之相同的名字，则会覆盖原有的规则。</p>
<ul>
<li>修改 <code>src/router/index.is</code> 文件，</li>
</ul>
<pre><code class="language-js">// ...
const categoryRoute = {
  path: &quot;/category&quot;,
  component: () =&gt; import(&quot;../pages/Category.vue&quot;),
};

// 动态添加顶级路由对象
router.addRoute(categoryRoute);
//...
export default router;
// ...
</code></pre>
<p>addRoute 方法不仅可以添加顶级路由，还支持添加二级路由</p>
<pre><code class="language-js">const routes = [
  {
    path: &quot;/home&quot;,
    name: &quot;home&quot;,
  },
  // ...
];
// ...
router.addRoute(&quot;home&quot;, {
  path: &quot;comment&quot;,
  component: () =&gt; import(&quot;../pages/HomeComment.vue&quot;),
});
//...
export default router;
// ...
</code></pre>
<blockquote>
<p>注意: router.addRoute 方法在接收一个参数时添加的是一级路由，在接收两个参数时添加的是二级路由。</p>
</blockquote>
<p><strong>2. 动态路由补充</strong></p>
<p>Vue Router 还提供了三种动态删除路由的方式</p>
<p>(1) 方式一: 添加一个相同名字 (name) 的路由，会覆盖之前同一名字的路由。</p>
<pre><code class="language-js">router.addRoute({
  path: &quot;/about&quot;,
  name: &quot;about&quot;,
  component: About,
});
</code></pre>
<p>(2) 方式二: 使用 removeRoute 方法，传入路由的名称</p>
<pre><code class="language-js">router.removeRoute(&quot;about&quot;);
</code></pre>
<p>(3) 调用 router.addRoute 返回的回调函数</p>
<pre><code class="language-js">const removeAbout = router.addRoute({
  path: &quot;/about&quot;,
  name: &quot;about&quot;,
  component: About,
});
removeAbout(); // 删除添加的路由
</code></pre>
<p>除此之外，Vue Router 的实例还提供很多常用的方法，列举如下:</p>
<ul>
<li><p>router.hasRoute: 检查路由是否存在</p>
</li>
<li><p>router.getRoutes: 获取一个包含所有路由记录的数组</p>
</li>
</ul>
<h3>路由守卫</h3>
<p>在某些情况下，我们希望能拦截路由导航。比如在进入某个路由之前，先判断用户是否已登录，如登录则放行，否则导航到登录页面。</p>
<p>其实，Vue Router 已经为我们提供了该功能，并将拦截路由称为 “导航守卫” (也称为“路由守卫”)。导航守卫，顾名思义就是专门用于守卫导航，可以灵活控制路由的跳转或取消等。导航守卫通常有三种实现方式：全局路由守卫、单个路由独享的守卫、组件内的守卫。在开发中用得最多的是全局路由守卫中的全局前置守卫。</p>
<p><strong>1. 全局前置守卫</strong></p>
<p>我们可以用 <code>router.beforeEach</code> 方法注册一个路由的全局前置守卫</p>
<pre><code class="language-js">// src/router/index.js
import { createRouter, createWebHistory } from &quot;vue-router&quot;;
import Home from &quot;../pages/Home.vue&quot;;
const routes = [
  { path: &quot;/&quot;, redirect: &quot;/home&quot; },
  { path: &quot;/home&quot;, component: Home },
];
const router = createRouter({
  history: createWebHistory(),
  routes,
});

router.beforeEach((to, from, next) =&gt; {
  console.log(&quot;全局前置守卫&quot;);
  next();
});

export default router;
</code></pre>
<p>可以看到，beforeEach 函数需要接收一个回调函数，该回调函数有两个参数:</p>
<ul>
<li><p>to: 将进入的路由 Route 对象</p>
</li>
<li><p>from: 将离开的路由 Route 对象</p>
</li>
</ul>
<p>另外，beforeEach 回调函数支持返回值的类型如下:</p>
<ul>
<li><p>false: 取消当前导航</p>
</li>
<li><p>undefined 或不返回: 进行默认导航</p>
</li>
<li><p>字符串:一个路由路径，如&quot;/about&quot;</p>
</li>
<li><p>对象: 如 <code>{ path: &quot;/login&quot;, query: {}, params: {} }</code> 对象</p>
</li>
</ul>
<pre><code class="language-js">// src/router/index.js
//...
router.beforeEach((to, from, next) =&gt; {
  if (to.path !== &quot;/login&quot;) {
    const token = window.sessionStorage.getItem(&quot;token&quot;);
    if (!token) {
      next(&quot;/login&quot;);
    }
  }
});
//...
</code></pre>

        </article>
      </main>

      <!-- Table of Contents Sidebar -->
      <aside class="toc-sidebar">
        <div class="toc-header">
          <h3>Table of Contents</h3>
        </div>
        <div class="toc-content" id="tocContent">
          <!-- TOC will be generated dynamically -->
        </div>
      </aside>
    </div>

    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>

    <button id="backToTop" class="back-to-top" aria-label="Back to top">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M12 19V5M5 12l7-7 7 7" />
      </svg>
    </button>

    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        border-radius: 100%;
        background-color: #07a;
        border: none;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: fixed !important;
        top: 30px;
        right: 30px;
        z-index: 10;
        display: none;
      }
      .back-button svg {
        width: 50%;
        height: 50%;
      }
      .back-button:hover {
        opacity: 0.8;
      }
      .layout {
        position: relative;
        z-index: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 2rem;
        right: 340px;
        background: linear-gradient(
          135deg,
          var(--accent),
          rgba(59, 130, 246, 0.8)
        );
        color: white;
        border: none;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      .back-to-top svg {
        width: 1.5rem;
        height: 1.5rem;
        stroke: currentColor;
        transition: transform 0.3s ease;
      }

      .back-to-top:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        background: linear-gradient(135deg, var(--accent), #2563eb);
      }

      .back-to-top:hover svg {
        transform: translateY(-2px);
      }

      .dark .back-to-top {
        background: linear-gradient(135deg, #4b5563, #1f2937);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .dark .back-to-top:hover {
        background: linear-gradient(135deg, #4b5563, #111827);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }
      @media screen and (max-width: 768px) {
        .back-to-top {
          right: 15px;
          bottom: 15px;
          width: 36px;
          height: 36px;
        }
      }

      @media screen and (max-width: 480px) {
        .back-to-top {
          right: 12px;
          bottom: 12px;
          width: 32px;
          height: 32px;
        }
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // Sidebar Toggle
      const toggleBtn = document.getElementById("toggleSidebar");
      const sidebar = document.querySelector(".sidebar");
      const mainContent = document.querySelector(".main-content");

      function toggleSidebar() {
        sidebar.classList.toggle("hidden");
        // Store sidebar state in localStorage
        localStorage.setItem(
          "sidebarHidden",
          sidebar.classList.contains("hidden")
        );
      }

      toggleBtn.addEventListener("click", toggleSidebar);

      // Keyboard shortcut (Ctrl + B)
      window.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "b") {
          e.preventDefault(); // Prevent browser's default behavior
          toggleSidebar();
        }
      });

      // Restore sidebar state from localStorage
      document.addEventListener("DOMContentLoaded", () => {
        const sidebarHidden = localStorage.getItem("sidebarHidden") === "true";
        if (sidebarHidden) {
          sidebar.classList.add("hidden");
        }
      });

      // Generate Table of Contents
      function generateTOC() {
        const article = document.querySelector(".content-body");
        const headings = article.querySelectorAll("h1, h2, h3, h4");
        const tocContent = document.getElementById("tocContent");
        const toc = document.createElement("ul");

        headings.forEach((heading, index) => {
          const id = `heading-${index}`;
          heading.id = id;

          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = `#${id}`;
          a.textContent = heading.textContent;
          a.className = `toc-level-${heading.tagName.toLowerCase()}`;

          li.appendChild(a);
          toc.appendChild(li);
        });

        tocContent.appendChild(toc);
      }

      // Initialize TOC
      document.addEventListener("DOMContentLoaded", generateTOC);

      // Image zoom with FLIP animation
      const overlay = document.querySelector(".zoom-overlay");
      let activeImage = null;

      document.querySelectorAll("img").forEach((img) => {
        if (img.closest("a")) return; // Skip images that are inside links
        img.style.cursor = "zoom-in";
        img.addEventListener("click", handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;

        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height,
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add("zoomed-image");
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = "fixed";
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = "0";
        clone.style.transformOrigin = "top left";

        // Show the overlay
        overlay.style.display = "block";

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale,
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;

        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = "transform 0.3s ease-out";
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener("click", unzoomImage);
        overlay.addEventListener("click", unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;

        // Clean up after the animation
        clone.addEventListener(
          "transitionend",
          () => {
            clone.remove();
            overlay.style.display = "none";
          },
          { once: true }
        );

        activeImage = null;
      }

      // 监听 ctrl + b
      window.addEventListener("keydown", (e) => {
        const leftDom = document.querySelector(".sidebar");
        if (e.ctrlKey && e.key === "b") {
          leftDom.classList.toggle("hidden");
        }
      });

      // Modal
      // const modal = document.getElementById("myModal");
      // const modalContent = modal.querySelector(".modal-content");
      // const openModal = document.getElementById("openModal");
      // const close = modal.querySelector(".close");

      // openModal.addEventListener("click", () => {
      //     modal.style.display = "block";
      // });

      // close.addEventListener("click", () => {
      //     modal.style.display = "none";
      // });

      // window.addEventListener("click", (e) => {
      //     if (e.target === modal) {
      //         modal.style.display = "none";
      //     }
      // });

      // Back to top button
      const backToTop = document.getElementById("backToTop");
      window.addEventListener("scroll", () => {
        if (window.scrollY > 200) {
          backToTop.style.display = "block";
        } else {
          backToTop.style.display = "none";
        }
      });

      backToTop.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      // Theme toggle
      document.addEventListener("DOMContentLoaded", () => {
        const themeToggle = document.getElementById("themeToggle");
        const html = document.documentElement;
        const prismTheme = document.getElementById("prismTheme");

        // Function to update theme and stylesheet
        function updateTheme(theme) {
          html.className = theme;
          prismTheme.href = `../css/prism${theme === "dark" ? "2" : ""}.css`;
          localStorage.setItem("theme", theme);
        }

        // Check for saved theme preference
        const savedTheme = localStorage.getItem("theme") || "light";
        updateTheme(savedTheme);

        themeToggle.addEventListener("click", () => {
          const currentTheme = html.className;
          const newTheme = currentTheme === "light" ? "dark" : "light";
          updateTheme(newTheme);
        });
      });
    </script>
  </body>
</html>
