<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>7 种开发人员都应该知道的高级 JavaScript 技术</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>
  <body class="line-numbers">
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 1;">
          <ul>
            <li class=""><a title="高精度实现定时器" href="/md/高精度实现定时器.html">37 高精度实现定时器</a></li><li class=""><a title="高效检查 JS 对象中的键是否存在" href="/md/高效检查 JS 对象中的键是否存在.html">36 高效检查 JS 对象中的键是否存在</a></li><li class=""><a title="非常强大的标准 JavaScript API - AbortController" href="/md/非常强大的标准 JavaScript API - AbortController.html">35 非常强大的标准 JavaScript API - AbortController</a></li><li class=""><a title="谈谈前端路由的实现原理 hash ＆ history" href="/md/谈谈前端路由的实现原理 hash ＆ history.html">34 谈谈前端路由的实现原理 hash ＆ history</a></li><li class=""><a title="获取上传进度的几种方式" href="/md/获取上传进度的几种方式.html">33 获取上传进度的几种方式</a></li><li class=""><a title="聊聊禁止页面滚动的几种方法" href="/md/聊聊禁止页面滚动的几种方法.html">32 聊聊禁止页面滚动的几种方法</a></li><li class=""><a title="缓存 http 错误，避免多次报错提示" href="/md/缓存 http 错误，避免多次报错提示.html">31 缓存 http 错误，避免多次报错提示</a></li><li class=""><a title="文件操作" href="/md/文件操作.html">30 文件操作</a></li><li class=""><a title="数据类型判断方法" href="/md/数据类型判断方法.html">29 数据类型判断方法</a></li><li class=""><a title="掌握 JavaScript 中的 Call 和 Apply" href="/md/掌握 JavaScript 中的 Call 和 Apply.html">28 掌握 JavaScript 中的 Call 和 Apply</a></li><li class=""><a title="属性的 getter 和 setter" href="/md/属性的 getter 和 setter.html">27 属性的 getter 和 setter</a></li><li class=""><a title="实现鼠标滚轮缩放 SVG 内容" href="/md/实现鼠标滚轮缩放 SVG 内容.html">26 实现鼠标滚轮缩放 SVG 内容</a></li><li class=""><a title="实现基于用户操作系统偏好的明暗主题切换" href="/md/实现基于用户操作系统偏好的明暗主题切换.html">25 实现基于用户操作系统偏好的明暗主题切换</a></li><li class=""><a title="宏任务和微任务" href="/md/宏任务和微任务.html">24 宏任务和微任务</a></li><li class=""><a title="十个超级好用的 Js 技巧" href="/md/十个超级好用的 Js 技巧.html">23 十个超级好用的 Js 技巧</a></li><li class=""><a title="前端的网络状态" href="/md/前端的网络状态.html">22 前端的网络状态</a></li><li class=""><a title="使用 JS 向现有 SVG 中添加元素" href="/md/使用 JS 向现有 SVG 中添加元素.html">21 使用 JS 向现有 SVG 中添加元素</a></li><li class=""><a title="使用 JavaScript 加载字体" href="/md/使用 JavaScript 加载字体.html">20 使用 JavaScript 加载字体</a></li><li class=""><a title="你需要知道的 Symbols" href="/md/你需要知道的 Symbols.html">19 你需要知道的 Symbols</a></li><li class=""><a title="一文整懂事件对象 event 的常用方法" href="/md/一文整懂事件对象 event 的常用方法.html">18 一文整懂事件对象 event 的常用方法</a></li><li class=""><a title="sessionStorage 能在多个标签页之间共享数据吗" href="/md/sessionStorage 能在多个标签页之间共享数据吗.html">17 sessionStorage 能在多个标签页之间共享数据吗</a></li><li class=""><a title="scrollIntoview" href="/md/scrollIntoview.html">16 scrollIntoview</a></li><li class=""><a title="reduce 的高级用法" href="/md/reduce 的高级用法.html">15 reduce 的高级用法</a></li><li class=""><a title="js 小众且好用的技巧" href="/md/js 小众且好用的技巧.html">14 js 小众且好用的技巧</a></li><li class=""><a title="js 如何监听一个变量改变" href="/md/js 如何监听一个变量改变.html">13 js 如何监听一个变量改变</a></li><li class=""><a title="javascript 奇葩行为大赏" href="/md/javascript 奇葩行为大赏.html">12 javascript 奇葩行为大赏</a></li><li class=""><a title="document.referrer 拦截问题" href="/md/document.referrer 拦截问题.html">11 document.referrer 拦截问题</a></li><li class=""><a title="Set 和 WeakSet 的用法和区别" href="/md/Set 和 WeakSet 的用法和区别.html">10 Set 和 WeakSet 的用法和区别</a></li><li class=""><a title="JavaScript 原生实现图片复制与粘贴" href="/md/JavaScript 原生实现图片复制与粘贴.html">09 JavaScript 原生实现图片复制与粘贴</a></li><li class=""><a title="JS 单行代码集" href="/md/JS 单行代码集.html">08 JS 单行代码集</a></li><li class=""><a title="JavaScript 中设置器和获取器" href="/md/JavaScript 中设置器和获取器.html">07 JavaScript 中设置器和获取器</a></li><li class=""><a title="FileReader" href="/md/FileReader.html">06 FileReader</a></li><li class=""><a title="EventSource" href="/md/EventSource.html">05 EventSource</a></li><li class=""><a title="ES14 中 5 个最具变革性的 JavaScript 特性" href="/md/ES14 中 5 个最具变革性的 JavaScript 特性.html">04 ES14 中 5 个最具变革性的 JavaScript 特性</a></li><li class="active"><a title="7 种开发人员都应该知道的高级 JavaScript 技术" href="/md/7 种开发人员都应该知道的高级 JavaScript 技术.html">03 7 种开发人员都应该知道的高级 JavaScript 技术</a></li><li class=""><a title="7 种位运算符的神奇用法" href="/md/7 种位运算符的神奇用法.html">02 7 种位运算符的神奇用法</a></li><li class=""><a title="7 个 Promise 静态方法" href="/md/7 个 Promise 静态方法.html">01 7 个 Promise 静态方法</a></li>
          </ul>
        </div>
        <div
          class="layout__main_right md "
          style="order: 0;"
        >
          <h1>7 种开发人员都应该知道的高级 JavaScript 技术</h1>
          <h2>1. 掌握闭包，让代码更简洁</h2>
<p>闭包是 JavaScript 中最强大且经常被误解的功能之一。它们允许你使用私有变量创建函数，从而使你的代码更加模块化和更安全。</p>
<p>什么是闭包？当函数记住其词法范围时，即使函数执行完毕，也会创建闭包。这对于在不使用全局变量的情况下维护函数中的状态非常有用。</p>
<pre><code class="language-js">// Example of a closure
function createCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
</code></pre>
<p>用例：闭包非常适合在事件处理程序中维护状态、创建私有变量或开发高阶函数等场景。</p>
<h2>2. 解构让代码更简洁</h2>
<p>解构是 ES6 的一项功能，它允许你从数组或对象中提取值并以更简洁的方式将它们分配给变量。它简化了代码，使其更易于阅读和维护。</p>
<pre><code class="language-js">// Object destructuring
const person = { name: &quot;Alice&quot;, age: 30 };
const { name, age } = person;

console.log(name); // &#39;Alice&#39;
console.log(age); // 30

// Array destructuring
const numbers = [1, 2, 3];
const [first, second] = numbers;

console.log(first); // 1
console.log(second); // 2
</code></pre>
<p>用例：解构在处理 API 或复杂对象时特别有用，它允许你仅提取所需的数据。</p>
<h2>3. 去抖动和节流以实现性能优化</h2>
<p>处理用户事件（如滚动或调整大小）时，每次发生用户操作时触发事件会显著影响性能。去抖动和节流是两种用于控制函数执行速率的技术。</p>
<p>去抖动：确保函数仅在一定时间不活动后执行。</p>
<p>节流：确保函数在指定时间内最多执行一次。</p>
<pre><code class="language-js">// Debounce function
function debounce(func, delay) {
  let timeout;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() =&gt; func.apply(this, args), delay);
  };
}

// Throttle function
function throttle(func, limit) {
  let inThrottle;
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() =&gt; (inThrottle = false), limit);
    }
  };
}
</code></pre>
<p>用例：使用防抖和节流来优化搜索输入、滚动事件监听器和调整大小事件等情况下的性能。</p>
<h2>4. 柯里化函数以提高可重用性</h2>
<p>柯里化将接受多个参数的函数转换为每个接受单个参数的函数序列。此技术使函数更具可重用性并允许部分应用。</p>
<pre><code class="language-js">// Basic curry function
function curry(fn) {
  return function curried(...args) {
    if (args.length &gt;= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// Usage
const add = (a, b, c) =&gt; a + b + c;
const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
</code></pre>
<p>用例：在构建可与部分数据一起重用的复杂函数时，柯里化特别有用，例如，在函数式编程或 React 组件中。</p>
<h2>5. 使用代理拦截对象行为</h2>
<p>代理对象允许你拦截和重新定义对象的基本操作，例如属性访问、赋值和函数调用。这对于验证、日志记录或构建反应式框架非常有用。</p>
<pre><code class="language-js">const person = {
  name: &quot;John&quot;,
  age: 25,
};

const handler = {
  get: function (target, property) {
    console.log(`Getting property ${property}`);
    return property in target ? target[property] : &quot;Property not found&quot;;
  },
  set: function (target, property, value) {
    if (property === &quot;age&quot; &amp;&amp; value &lt; 0) {
      console.error(&quot;Age cannot be negative&quot;);
    } else {
      target[property] = value;
    }
  },
};

const proxyPerson = new Proxy(person, handler);
console.log(proxyPerson.name); // Logs &quot;Getting property name&quot; and outputs &quot;John&quot;
proxyPerson.age = -5; // Logs &quot;Age cannot be negative&quot;
</code></pre>
<p>用例：代理通常用于数据验证、Vue.js 等反应式框架以及记录对敏感数据的访问。</p>
<h2>6. 了解事件循环和异步 JavaScript</h2>
<p>JavaScript 是单线程的，这意味着它一次只能执行一个任务。但是，它的事件循环允许异步操作高效进行，而不会阻塞主线程。</p>
<p>了解事件循环对于编写高效的异步代码至关重要，尤其是在处理 setTimeout、Promises 和 async/await 时。</p>
<pre><code class="language-js">console.log(&quot;Start&quot;);

setTimeout(() =&gt; {
  console.log(&quot;Inside setTimeout&quot;);
}, 0);

Promise.resolve().then(() =&gt; {
  console.log(&quot;Inside Promise&quot;);
});

console.log(&quot;End&quot;);
// Output:
// Start
// End
// Inside Promise
// Inside setTimeout
</code></pre>
<p>用例：在构建实时应用程序、处理 API 请求或管理异步任务时，了解事件循环的工作原理至关重要。</p>
<h2>7. 记忆化以提高性能</h2>
<p>记忆化是一种用于缓存昂贵函数调用结果并在相同输入再次出现时返回缓存结果的技术。这可以显著提高使用相同输入频繁调用的函数的性能。</p>
<pre><code class="language-js">function memoize(fn) {
  const cache = new Map();
  return function (...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// Usage
const slowFunction = (num) =&gt; {
  console.log(&quot;Long computation...&quot;);
  return num * 2;
};

const memoizedFunction = memoize(slowFunction);
console.log(memoizedFunction(5)); // Long computation... 10
console.log(memoizedFunction(5)); // 10 (from cache)
</code></pre>
<p>用例：记忆化对于优化数据密集型应用程序中的昂贵计算非常有用，例如对大型数据集进行排序或执行复杂的数学运算。</p>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <script defer src="../js/prism.min.js"></script>
    <script>
      // const leftBorder = document.querySelector(".left__border");
      // const resizer = document.querySelector(".layout__main_left");
      // const resizable = document.querySelector(".layout__main_right");
      // leftBorder.addEventListener("mousedown", initResize);
      // function initResize(e) {
      //   e.preventDefault();
      //   document.addEventListener("mousemove", startResizing);
      //   document.addEventListener("mouseup", stopResizing);
      // }
      // function startResizing(e) {
      //   const resizerRect = resizer.getBoundingClientRect();
      //   const resizableRect = resizable.getBoundingClientRect();
      //   let newWidth = e.clientX - resizerRect.left;
      //   if (newWidth < 300) {
      //     newWidth = 300;
      //   } else if (newWidth > 850) {
      //     newWidth = 850;
      //   }
      //   resizer.style.width = `${newWidth}px`;
      // }
      // function stopResizing() {
      //   document.removeEventListener("mousemove", startResizing);
      //   document.removeEventListener("mouseup", stopResizing);
      // }
      // const liActive = document.querySelector(".layout__main_left li.active");
      // liActive.scrollIntoView({
      //   behavior: "smooth",
      //   block: "center",
      //   inline: "nearest",
      // });
    </script>
  </body>
</html>
