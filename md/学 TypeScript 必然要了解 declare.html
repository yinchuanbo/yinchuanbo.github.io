<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <title>学 TypeScript 必然要了解 declare</title>
    <link rel="shortcut icon" href="../code.svg" type="image/x-icon" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=fallback"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/prism.css" />
    <link rel="stylesheet" href="../css/edit.css" />
    
  </head>
  
  <body>
    <div class="layout">
      <div class="layout__main">
        <div class="layout__main_left" style="order: 0">
          <div class="layout__main_left-switch"></div>
          <ul>
            <li class=""><a title="TS常用工具类型" href="/md/TS常用工具类型.html">08 TS常用工具类型</a></li><li class=""><a title="解锁TypeScript的力量，现代Web开发的关键概念" href="/md/解锁TypeScript的力量，现代Web开发的关键概念.html">07 解锁TypeScript的力量，现代Web开发的关键概念</a></li><li class=""><a title="用 TypeScript 进行性能优化" href="/md/用 TypeScript 进行性能优化.html">06 用 TypeScript 进行性能优化</a></li><li class=""><a title="类型声明文件" href="/md/类型声明文件.html">05 类型声明文件</a></li><li class="active"><a title="学 TypeScript 必然要了解 declare" href="/md/学 TypeScript 必然要了解 declare.html">04 学 TypeScript 必然要了解 declare</a></li><li class=""><a title="TypeScript 的 5 个好用技巧" href="/md/TypeScript 的 5 个好用技巧.html">03 TypeScript 的 5 个好用技巧</a></li><li class=""><a title="重新学习 TypeScript 类型系统" href="/md/重新学习 TypeScript 类型系统.html">02 重新学习 TypeScript 类型系统</a></li><li class=""><a title="前端进阶必须会的 Zod" href="/md/前端进阶必须会的 Zod.html">01 前端进阶必须会的 Zod</a></li>
          </ul>
        </div>
        <div
          style="order: 1"
          class="layout__main_right md "
        >
          <div class="page-header">
            
            <a href="/md/" class="back-button">Back to MD</a>
            
            <h1>学 TypeScript 必然要了解 declare</h1>
            <p class="time">HaoTian · 2024-11-18 13:14:15</p>
          </div>
          <h2>背景</h2>
<p>declare 关键字是为了服务 TypeScript 的。TypeScript 是什么在这里就不多介绍了，但是我们要知道 ts 文件是需要 TypeScript 编译器转换为 js 文件才可以执行，并且在编译阶段就会进行类型检查。但是在 TypeScript 中并不支持 js 可识别的所有类型，例如我们使用第三方库 JQuery，我们通过一下方法获取一个 id 为‘foo’的标签元素。</p>
<pre><code class="language-js">$(&quot;#foo&quot;);
// or
jQuery(&quot;#foo&quot;);
</code></pre>
<p>然而在 ts 文件中，使用语法，语法，语法，底下就会爆出一条红线提示到：<code>Cannot find name &#39;$&#39;</code></p>
<img src="../imgs/103/21.webp" />

<p>因此，需要 declare 来声明，告诉 TypeScript 编译器该标识符已存在，通过编译时的检查并在开发时提供类型提示。</p>
<h2>定义</h2>
<p>在 TypeScript 中，declare 关键字告诉编译器存在一个对象（并且可以在代码中引用）。它向 TypeScript 编译器声明该对象。简而言之，它允许开发人员使用在其他地方声明的对象。</p>
<p>注：编译器不会将 declare 语句编译为 JavaScript。对比下面两段代码：</p>
<pre><code class="language-ts">// declare声明了一个名为 myGlobal 的全局变量，并指定其类型为 any。
// 该声明并不会生成真正的 JavaScript 代码，而只是告诉 TypeScript 编译器该变量存在。
declare var myGlobal: any;

// 给 myGlobal 赋值为 42。
myGlobal = 42;
console.log(myGlobal); // 42
</code></pre>
<pre><code class="language-ts">// 直接声明了一个名为 myGlobal 的全局变量，并指定其类型为 any。这会生成真正的 JavaScript 代码。
var myGlobal: any;

// 给 myGlobal 赋值为 42。
myGlobal = 42;
console.log(myGlobal); // 42
</code></pre>
<h2>使用</h2>
<ul>
<li>declare var 声明全局变量</li>
<li>declare function 声明全局方法</li>
<li>declare class 声明全局类</li>
<li>declare enum 声明全局枚举类型</li>
<li>declare namespace 声明（含有子属性的）全局对象</li>
<li>declare global 扩展全局变量</li>
<li>declare module 扩展模块</li>
</ul>
<h2>声明文件</h2>
<p>通常，在使用第三方库或模块时，有两种方式引入声明文件：</p>
<ul>
<li><p>全局声明：如果第三方库或模块是全局可访问的，你可以在整个项目的任何地方直接使用它们，而无需显式导入。此时，你只需要确保在 TypeScript 项目中正确引入了相应的声明文件。一般情况下，TypeScript 会自动查找并加载全局声明文件。如果没有自动加载，你可以使用 <code>///</code> 的方式在具体的源文件中将声明文件引入。</p>
</li>
<li><p>模块导入：如果第三方库或模块是通过模块化方式提供的，你需要使用 import 语句将其导入到你的代码中，同时也需要确保相应的声明文件被正确引入。在这种情况下，你可以使用 import 或 require 来引入库，并且不需要显式地引入声明文件，因为 TypeScript 编译器会根据模块的导入语句自动查找和加载相应的声明文件。</p>
</li>
</ul>
<p>有很多第三方库提供了声明文件，可以在 packages.json 文件中查看。types 表示类型声明文件是哪一个。</p>
<img src="../imgs/103/22.webp" />

<p>可以使用 @types 统一管理第三方库的声明文件。@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p>
<pre><code class="language-sh">npm install @types/jquery --save-dev
</code></pre>

        </div>
      </div>
    </div>
    <div class="body_bg"></div>
    <div class="zoom-overlay"></div>
    <style>
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        z-index: 1000;
        cursor: zoom-out;
      }
      .zoomed-image {
        position: fixed;
        z-index: 1001;
        will-change: transform;
        cursor: zoom-out;
        max-width: 90vw;
        max-height: 90vh;
        object-fit: contain;
      }
      .back-button {
        display: inline-flex;
        align-items: center;
        padding: 8px 16px;
        background: #f0f0f0;
        border: none;
        border-radius: 4px;
        color: #333;
        text-decoration: none;
        font-size: 14px;
        margin-bottom: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .back-button:hover {
        background: #e0e0e0;
      }
      .back-button::before {
        content: "←";
        margin-right: 8px;
      }
    </style>
    <script defer src="../js/prism.min.js"></script>
    <script>
      const switchBtn = document.querySelector(".layout__main_left-switch");
      const left = document.querySelector(".layout__main_left");
      switchBtn.addEventListener("click", () => {
        left.classList.toggle("show");
      });

      // Image zoom with FLIP animation
      const overlay = document.querySelector('.zoom-overlay');
      let activeImage = null;

      document.querySelectorAll('img').forEach(img => {
        if (img.closest('a')) return; // Skip images that are inside links
        img.style.cursor = 'zoom-in';
        img.addEventListener('click', handleImageClick);
      });

      function handleImageClick(event) {
        const img = event.target;
        
        if (activeImage) {
          // If an image is already zoomed, unzoom it
          unzoomImage();
          return;
        }

        // Get the initial position and size
        const rect = img.getBoundingClientRect();
        const first = {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height
        };

        // Create a clone of the image
        const clone = img.cloneNode();
        clone.classList.add('zoomed-image');
        document.body.appendChild(clone);

        // Position the clone exactly over the original
        clone.style.position = 'fixed';
        clone.style.left = `${first.x}px`;
        clone.style.top = `${first.y}px`;
        clone.style.width = `${first.width}px`;
        clone.style.height = `${first.height}px`;
        clone.style.margin = '0';
        clone.style.transformOrigin = 'top left';

        // Show the overlay
        overlay.style.display = 'block';

        // Calculate the final position and scale
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const targetWidth = Math.min(img.naturalWidth, viewportWidth * 0.9);
        const targetHeight = Math.min(img.naturalHeight, viewportHeight * 0.9);
        const scaleX = targetWidth / first.width;
        const scaleY = targetHeight / first.height;
        const scale = Math.min(scaleX, scaleY);

        const last = {
          width: first.width * scale,
          height: first.height * scale
        };
        last.x = (viewportWidth - last.width) / 2;
        last.y = (viewportHeight - last.height) / 2;

        // Calculate and apply the transform
        const dx = last.x - first.x;
        const dy = last.y - first.y;
        
        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scale})`;
          clone.style.transition = 'transform 0.3s ease-out';
        });

        activeImage = { original: img, clone: clone };

        // Add click handlers for closing
        clone.addEventListener('click', unzoomImage);
        overlay.addEventListener('click', unzoomImage);
      }

      function unzoomImage() {
        if (!activeImage) return;

        const { original, clone } = activeImage;
        const rect = original.getBoundingClientRect();

        // Animate back to the original position
        clone.style.transform = `translate(0, 0) scale(1)`;
        
        // Clean up after the animation
        clone.addEventListener('transitionend', () => {
          clone.remove();
          overlay.style.display = 'none';
        }, { once: true });

        activeImage = null;
      }
    </script>
  </body>
</html>
