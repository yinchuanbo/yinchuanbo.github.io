<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>110 在场景中使用多个桃心构建球体</title>
    <style>
      body {
        overflow: hidden;
        margin: 0;
      }
      #info {
        position: fixed;
        top: 10px;
        width: 100%;
        text-align: center;
        color: #333;
        font-family: Arial, sans-serif;
        pointer-events: none;
        z-index: 100;
      }
    </style>
  </head>

  <body>
    <div id="info">由多个桃心构建的彩虹球体 - 使用鼠标拖动来旋转视角</div>
    <div id="container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // 场景初始化
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // 相机设置
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        1,
        1000
      );
      camera.position.set(0, 0, 400);

      // 渲染器设置
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance",
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById("container").appendChild(renderer.domElement);

      // 控制器设置
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 200;
      controls.maxDistance = 800;

      // 光照设置
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0xffffff, 0.5);
      pointLight.position.copy(camera.position);
      scene.add(pointLight);

      // 创建桃心形状
      function createHeartShape() {
        const shape = new THREE.Shape();
        shape.moveTo(25, 25);
        shape.bezierCurveTo(25, 25, 20, 0, 0, 0);
        shape.bezierCurveTo(-30, 0, -30, 35, -30, 35);
        shape.bezierCurveTo(-30, 55, -10, 77, 25, 95);
        shape.bezierCurveTo(60, 77, 80, 55, 80, 35);
        shape.bezierCurveTo(80, 35, 80, 0, 50, 0);
        shape.bezierCurveTo(35, 0, 25, 25, 25, 25);
        return shape;
      }

      // 创建单个桃心几何体
      function createHeartGeometry() {
        const shape = createHeartShape();
        const geometry = new THREE.ExtrudeGeometry(shape, {
          depth: 20,
          bevelEnabled: false,
        });
        geometry.rotateX(Math.PI);
        geometry.scale(0.4, 0.4, 0.4);
        return geometry;
      }

      // 创建球面分布的顶点
      function createSpherePoints(count) {
        const points = [];
        for (let i = 1; i <= count; i++) {
          const phi = Math.acos(-1 + (2 * i) / count);
          const theta = Math.sqrt(count * Math.PI) * phi;
          const vector = new THREE.Vector3();
          vector.setFromSphericalCoords(125, phi, theta);
          points.push(vector);
        }
        return points;
      }

      // 创建彩虹色球体
      function createRainbowSphere() {
        const heartGeometry = createHeartGeometry();
        const positions = [];
        const normals = [];
        const colors = [];
        const color = new THREE.Color();
        const spherePoints = createSpherePoints(80);

        spherePoints.forEach((point, index) => {
          // 克隆并变换几何体
          const geometry = heartGeometry.clone();
          geometry.lookAt(point);
          geometry.translate(point.x, point.y, point.z);

          // 设置HSL颜色
          color.setHSL(index / spherePoints.length, 1.0, 0.7);

          // 获取几何体的位置和法线数据
          const positionAttribute = geometry.getAttribute("position");
          const normalAttribute = geometry.getAttribute("normal");

          // 添加顶点数据
          for (let i = 0; i < positionAttribute.count; i++) {
            positions.push(
              positionAttribute.getX(i),
              positionAttribute.getY(i),
              positionAttribute.getZ(i)
            );
            normals.push(
              normalAttribute.getX(i),
              normalAttribute.getY(i),
              normalAttribute.getZ(i)
            );
            colors.push(color.r, color.g, color.b);
          }

          geometry.dispose();
        });

        // 创建最终的BufferGeometry
        const bufferGeometry = new THREE.BufferGeometry();
        bufferGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        bufferGeometry.setAttribute(
          "normal",
          new THREE.Float32BufferAttribute(normals, 3)
        );
        bufferGeometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );

        return bufferGeometry;
      }

      // 创建材质
      const material = new THREE.MeshPhongMaterial({
        shininess: 80,
        vertexColors: true,
        side: THREE.DoubleSide,
      });

      // 创建最终的网格
      const mesh = new THREE.Mesh(createRainbowSphere(), material);
      scene.add(mesh);

      // 动画循环
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        pointLight.position.copy(camera.position);
        renderer.render(scene, camera);
      }

      // 窗口大小调整
      window.addEventListener("resize", onWindowResize, false);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // 清理函数
      window.addEventListener("beforeunload", () => {
        scene.remove(mesh);
        mesh.geometry.dispose();
        material.dispose();
        renderer.dispose();
      });

      // 开始动画
      animate();
    </script>
  </body>
</html>
