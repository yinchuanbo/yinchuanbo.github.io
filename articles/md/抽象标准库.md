---
title: "抽象标准库"
tag: "现代 JavaScript 库开发"
time: 2025-02-06 14:17:48
---

本章将介绍开发库的过程中会用到的通用功能，并将这些功能抽象为基础库，这些库是为更好地开发库而编写的，使用这些库可以极大地提高库的开发效率。

## 类型判断

### 背景知识

对于数据为空的情况，经常要做防御式编程，误区之一是使用非运算符直接判断，这会把很多假值计算在内。常见的假值有 0、"(空字符串)、false、null、undefined 等。

```js
function double(x) {
  // 0 会被错误的计算
  if (!x) {
    return NaN;
  }
  return x * 2;
}
```

对于判空，另一种写法是直接与 null 和 undefined 进行比较。

```js
function double(x) {
  if (x === null || x === undefined) {
    return NaN;
  }
  return x * 2;
}
```

这种写法有一个比较严重的安全问题。在 JavaScript 中，undefined 并不是关键字而是 window 上的一个属性，在 ECMAScript5 之前这个属性是可写的，如果 undefined 被重新赋值，则在过时浏览器中执行如下代码，由于 undefined 属性被改写了，因此会导致判断不能生效。

```js
window.undefined = 1;

var x;
if (x === undefined) {
  // 永远不会执行
}
```

虽然在现代浏览器中不会有这个 Bug，但是如果函数的作用域中存在名字为 undefined 的变量，则还是会有问题，这被称作 undefined 变量覆盖。

```js
(function () {
  var undefined = 1;
  var x;
  if (x === undefined) {
    // 永远不会执行
  }
})();
```

对于判空，还有比较巧妙的方法。可以只和 null 判断相等，借助隐式转换达到同样的效果。由于 null 是 JavaScript 中的关键字，无法作为变量的名字，因此 null 没有 undefined 变量覆盖的问题。

```js
window.undefined = 1;
function double(x) {
  if (x == null) {
    return NaN;
  }
  return x * 2;
}
```

在**全等**操作符是最佳实践的背景下，这种做法并不被鼓励。还可以使用 `typeof` 操作符来判断 undefined，`typeof` 通过内部类型判断，不存在 undefined 变量覆盖的问题。

```js
window.undefined = 1;

function double(x) {
  if (x == null || typeof x === "undefined") {
    return NaN;
  }
  return x * 2;
}
```

下面来看 number 类型数据的判断问题。对于 number 类型数据，有个需要注意的地方，在 JavaScript 中有个特殊的值叫作 NaN，NaN 的类型也是 number，编码中很少直接使用 NaN，通常都是在计算失败时会得到这个值。

虽然 NaN 的类型也是 number，但是将 NaN 作为正常 number 类型数据使用时就会报错，如调用 NaN 上的 toFixed 方法就会报错。更好的做法是添加 isNaN 判断，**需要注意 number 类型数据要判断是否为 NaN 的特殊逻辑**。

```js
const x = Math.sqrt(-1); // NaN

// 注意这里的 isNaN 判断
if (typeof x === "number" && !isNaN(x)) {
  console.log(x.toFixed(2));
}
```

也可以使用 ECMAScript2015 中新增的 Number.isNaN 方法。和全局函数 isNaN 相比，Number.isNaN 方法不会自行将参数的类型转换成数字类型。Number.isNaN 方法等价于如下代码逻辑，使用 Number.isNaN 方法是更好的办法，但是需要注意兼性问题。

```js
Number.isNaN = function (value) {
  return typeof value === "number" && isNaN(value);
};
```

下面来看 typeof 操作符的问题。typeof 只能判断基本数据类型，对于引用数据类型，得到的值都是 object。

```js
typeof []; // 'object'
typeof {}; // 'object'
typeof null; // 'object'
```

可以使用 instanceof 操作符来检测引用数据类型，其原理是检测 `constructor.prototype` 是否存在于参数 object 的原型链上。

```js
[] instanceof Array; // true
{} instanceof Object; // true
/reg/ instanceof RegExp; // true
```

使用 instanceof 做类型判断时，存在的第一个问题是不够准确。例如，如下代码，数组类型对于 Array 和 Object 都返回 true，这是因为 Object.prototype 是所有对象的原型。

```js
[] instanceof Array; // true
[] instanceof Object; // true
```

使用 instanceof 做类型判断时，一定要注意顺序问题，如果顺序错误，则可能会得不到正确的结果

```js
function type(x) {
  if (x instanceof Object) {
    return "object";
  }
  // Array 永远得不到正确的类型
  if (x instanceof Array) {
    return "array";
  }
}
type([]); // 'object'
```

使用 instanceof 做类型判断时，存在的另一个冷门的问题是，当页面中存在多个 iframe 时，其判断可能会返回错误的结果，这个问题一般会在多窗口之间传递值时发生。

```js
[] instanceof window.frames[0].Array; // false
[] instanceof window.Array; // true
```

对于数组的判断，更好的办法是使用 ECMAScript5 带来的新方法 Array.isArray：这个方法在任何情况下都可以得到可靠的结果。

```js
Array.isArray([]); // true
Array.isArray({}); // false
```

另一种常用的判断类型的方式是使用可以获取数据的内部类型的方法，借助 `Object.prototype.toString` 方法可以获取数据的内部类型。

```js
Object.prototype.toString.call([]); // '[object Array]'
Object.prototype.toString.call({}); // '[object Object]'
Object.prototype.toString.call(null); // '[object Null]'
Object.prototype.toString.call(undefined); // '[object Undefined]'
Object.prototype.toString.call(/reg/); // '[object RegExp]'
```

ECMAScript 2015 引入了 `Symbol.toStringTag` 属性，可以修改内部类型的值，这会影响 `toString` 方法的返回值，使用 `Symbol.toStringTag` 属性需要注意兼容性问题。

```js
const toString = Object.prototype.toString;

const obj = {};

toString.call(obj); // '[object Object]'
// 修改内部类型的值
obj[Symbol.toStringTag] = "MyObject";
toString.call(obj); // '[object MyObject]'
```

[166]
