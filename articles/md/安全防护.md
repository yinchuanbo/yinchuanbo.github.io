---
title: "安全防护"
tag: "现代 JavaScript 库开发"
time: 2025-02-05 13:40:24
---

## 防护意外

开源库的使用环境存在太多未知性，因此不能想当然地认为会发生什么，正确的思路应该是防患未然，将可能发生的各种意外情况都考虑到。下面介绍几种常见的防护意外实践。

### 最小功能设计

开源库应该对外提供**最小功能**，尽可能隐藏内部实现细节。所有对外暴露的接口都是对外做的承诺，暴露的接口都要维护，后续迭代时永久向下兼容。所以，建议仅暴露有限的接口，不相关的功能不要对外暴露。

来看一个例子，guid 函数对外提供生成唯一 ID 的功能，其依一个内部计数要 count，在这里 count 就是不应该对外暴露的细节。示例代码如下:

```js
export let count = 1;
export function guid() {
  return count++;
}
```

另外一个常见的例子是类的属性。在 JavaScript 中，类的所有属性和方法都是公开的，但是这会造成类的细节被意外暴露。在如下的示例代码中，count 属性被意外暴露，count 被外部修改后，程将会发生错误。

```js
class Guid {
  count = 1;
  guid() {
    return this.count++;
  }
}
const g = new Guid();
g.count = "error"; // 直接修改了 count 属性
```

更好的做法是把私有属性放到函数作用域中，一般是放到构造函数 constructor 中，示例代码如下，外部无法访间内部函数作用域中的变量 count。

```js
class Guid {
  constructor() {
    let count = 1;
    this.guid = () => count++;
  }
}
const g = new Guid();
g.guid(); // 访问 ID
g.count; // 报错，访问不到
```

2022 年 6 月，ECMAScript 2022 正式发布，ECMAScript 2022 带来了原生私有属性。原生私有属性需要添加 **#** 前缀，外部无法访问原生私有属性。

```js
class Guid {
  #count = 1;
  constructor() {
    this.guid = () => this.#count++;
  }
}
const g = new Guid();
g.guid(); // 访问 ID
g.count; // 报错，访问不到
```

### 最小参数设计

函数要对外暴露最小的参数，参数应尽可能使用简单类型，因为简单类型更安全，如果是引用类型参数，那么函数不要直接修改传入的参数。

举个例子，fill 函数可以实现用指定值填充数组，但是其直接修改了传入的参数，这可能不是使用者希望的行为，调用 fill 函数，传入的 arr 数组被修改了。

```js
function fill(arr, value) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = value;
  }
  return arr;
}

const arr1 = Array(3);
const arr2 = fill(arr1, 1);
console.log(arr1); // [1, 1, 1]
```

如果要修改引用类型的传入参数，那么建议复制一份数据，在复制的数据上进行修改，切断和传入参数之间的关联

```js
function fill(arr, value) {
  const newArr = clone(arr);
  for (let i = 0; i < newArr.length; i++) {
    newArr[i] = value;
  }
  return newArr;
}

const arr1 = Array(3);
const arr2 = fill(arr1, 1);
console.log(arr1); // [empty × 3]
```

### 冻结对象

暴露给使用者的接口可能会被其他人有意或无意地更改，这会导致开发时运行良好的程序，在某些意外情况下出错。例如，我们引用了 jQuery 库后，可以修改其属性。

```js
import $ from "jquery";

$.version = undefined;
$.version.split("."); // 报错
```

想要解决上述问题，可以将对外的接口冻结，这就需要用到 ECMAScript5 引入的 3 个方法，这 3 个方法都可以改变对象的行为。

| 方法                       | 修改原型的指向 | 添加属性 | 修改属性配置 | 删除属性 | 修改属性 |
| :------------------------- | :------------: | -------: | -----------: | -------: | -------: |
| Object.preventExtensions() |       否       |       否 |           是 |       是 |       是 |
| Object.seal()              |       否       |       否 |           否 |       否 |       是 |
| Object.freeze()            |       否       |       否 |           否 |       否 |       否 |

Object.freeze 方法的效果更严格，冻结对象的属性无法修改，如果尝试修改，那在严格模式下会报错，在非严格模式下会静默失败，修改不会产生任何效果。

```js
import $ from "jquery";
Object.freeze($); // $ 对象的属性无法修改
$.version = undefined; // 外部无法修改 version
```

## 避免原型入侵

### 面向对象基础知识

大部分编程语言都提供了数据的抽象能力，如有序数据的数组、无序数据的对象等。将数据和对数据的操作封装到一起，被称作面向对象。这是一种更高维度的抽象工具，这种抽象工具可以对现实世界进行建模。

现实世界中的事物之间存在联系。以现实世界中的猫为例，猫中有布偶猫和狸花猫，显然狸花猫应该拥有猫的全部特性。在面向对象中这被称为继承，即细分的事物应该继承抽象事物的特点。

实现对象和继承有两种思路，分别是 CEOC 和 OLOO，下面简单介绍一下这两者

CEOC(Class Extend Other Class)是一套基于类和实例的实现方式，类作为对象的抽象描述，对象是类的实例。这种机制与其说是面向对象编程，不如说是面向类编程更准确。

OLOO(Object Link Other Object)是一套基于对象和关系的实现方式。例如有两个对象，如果能够直接让一个对象继承另一个对象，那么也能实现面向对象。在 OLOO 中，一般将父对象称为子对象的原型。在 OLOO 中没有类、只有对象，以及对象之间的关系。

### 原型之路

JavaScript 的面向对象是基于原型的。在 JavaScript 中，实现继承有多种方式。但是万变不离其宗，所有继承方式的背后，原理都是原型、下面介绍各种继承方式。

想要在 ECMAScript3 中实现继承，需要用到构造函数的方式，其原理也是基于原型的。例如，有两个构造函数 Parent 和 Child，通过修改 Child 函数的 prototype 属性，即可实现 Child 函数继承 Parent 的数的功能

```js
function Parent() {}

function Child() {}

function T() {}

T.prototype = Parent.prototype;
Child.prototype = new T();
```

构造函数的方式有些不伦不类，如同强行给原型套了一个很像类的壳子，这对熟悉类和熟悉原型的开发者都不友好。所以，后来的 ECMAScript 新版本对基于类和
基于原型方向都做了探索。

构造函数的方式对熟悉类的开发者并不友好，所以 ECMAScript2015 带来了基于类的新语法，但这个新语法只是一个语法糖，其背后的原理还是原型。下面用类改写上面的示例代码，改写后的示例代码如下:

```js
class Parent {}

class Child extends Parent {}
```

构造函数的方式对熟悉原型的开发者也不友好。ECMAScript 对基于原型的方向也做了探索，ECMAScript5 带来了 Object.create 方法，可以直接让对象继承对象，示例代码如下。最终 child 对象有两个属性，其中 a 属性是从 parent 对象继承的，b 属性是自己的

```js
const parent = {
  a: 1,
};

const child = Object.create(parent, {
  b: {
    value: 2,
    writable: true,
    enumerable: true,
    configurable: true,
  },
});
```

当使用 `Object.create` 方法创建子对象时，如果要定义子对象的属性，就需要用到上面的语法，没办法使用我们熟悉的对象字面量的方式了。

为了解决这个问题，ECMAScript 2015 又带来了 `__proto__` 属性，这个属性可以让对象继承对象，

```js
const parent = {
  a: 1,
};

const child = {
  __proto__: parent,
  b: 2,
};
```

上面的方式都要求新建子对象，如果子对象已经存在，就无法修改其继承的父对象了。针对这个问题，ECMAScript 2015 带来了直接操作原型的方式，使用 Object.setPrototypeOf 方法可以修改已经存在的对象的继承关系：

```js
const parent = {};
const child = {};
Object.setPrototypeOf(child, parent);
```

不过需要注意的是，直接操作原型的方式会有性能问题和兼容性问题。

### 原型入侵

【未完】
