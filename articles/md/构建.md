---
title: "构建"
tag: "现代 JavaScript 库开发"
time: 2025-01-26 10:06:36
---

## 模块化解析

ECMAScript 2015 带来了原生的模块规范，而在此之前，JavaScript 并没有统一的模块规范。对于大型项目来说，模块是必不可少的，于是 JavaScript 社区进行了很多探索，其中有一些影响力较大的模块规范(如 AMD 和 CommonJS)，目前还在被广泛使用。

### 什么是模块

随着程序规模的扩大，以及引入各种第三方库，共享全局作用域会带来很多问题。首先是命名冲突问题，为了解决命名冲突问题，主流编程语言都提供了语言层面的方案，举例如下:

- C 语言中的宏编译

- C++语言中的命名空间

- Python 语言中的模块

- Java 语言中的包

- PHP 语言中的命名空间

JavaScript 社区则选择了模块方案。一个合格的模块方案需要满足以下特性:

- 独立性 - 能够独立完成某个功能，隔绝外部环境的影响。

- 完整性 - 能够完成某个特定功能。

- 可依赖 - 可以依赖其他模块。

- 被依赖 - 可以被其他模块依赖。

> 简而言之，模块就是一个独立的空间，能引用其他模块，也能被其他模块引用。

### 原始模块

如果仅从定义层面来看，一个函数即可称为一个模块，而我们早就开始使用这种模块了。

```js
function add(a, b) {
  return a + b;
}
```

在 ECMAScript 2015 之前，只有函数能够创建作用域。

下面是 JavaScript 社区中原始模块的定义代码:

```js
(function (mod, $) {
  function clone(source) {
    // 此处省略
  }
})((window.clone = window.clone || {}), jQuery);
```

上面的 mod 模块不会被重复定义，依赖通过函数参数注入。这种实现其实并不完美，仍然需要手动维护依赖的顺序，典型的场景就是其中的 jQuery 必须先于代码被引用，否则会报告引用错误。随着模块数量的增加，这种问题很快会变得不可维护，这显然不是我们想要的。

一般的库都会提供对这种模块的支持，因为这种模块可以直接通过 script 标签引入，使用 script 标签引入库的方式依然存在使用场景，如古老的前端系统、简单的活动页面、简单的测试页面等。

### AMD

AMD 是一种异步模块加载规范，专为浏览器端设计，其全称是 AsynchronousModule Definition，中文名称是异步模块定义。

AMD 规范中定义模块的方式如下:

```js
define(id?, dependencies?, factory);
```

浏览器并不支持 AMD 模块，在浏览器端，需要借助 RequireJS 才能加载 AMD 模块。

RequireJS 是使用最广泛的 AMD 模块加载器，但目前的新系统基本不再使用 RequireJS，因为大部分库都会提供对 AMD 模块的支持

给深拷贝库添加对 AMD 模块的支持:

```js
define(function () {
  function clone(source) {
    // 此处省略
  }
  return clone;
});
```

上面的代码定义了一个匿名 AMD 模块，假设代码位于 clone.js 文件中，那么在 index.js 文件中可以像下面代码这样使用上面代码定义的模块:

```js
define(["clone"], function (clone) {
  const a = { a: 1 };
  const b = clone(a);
});
```

### CommonJS

CommonJs 是一种同步模块加载规范，目前主要用于 Node.js 环境中。CommonJs 规范中定义模块的方式如下：

```js
define(function (require, exports, module) {
  //...
});
```

在 Node.js 中，外面的 define 包裹函数是系统自动生成的，不需要开发者自己书写。下面是深拷贝库支持 CommonJS 模块的示例代码:

```js
function clone(source) {
  // 此处省略
}
module.exports = clone;
```

在 Nodejs 环境下，假设上面的代码位于 clone.js 文件中，那么在 index.js 文件中可以像下面代码这样使用上面代码定义的模块:

```js
const clone = require("./clone");
const a = { a: 1 };
const b = clone(a);
```

### UMD

UMD 是一种通用模块加载规范，其全称是 Universal Module Definition，中文名称是通用模块定义。

UMD 想要解决的问题和其名称所传递的意思是一致的，它并不是一种新的规范，而是对前面介绍的 3 种模块规范 (原始模块、AMD、CommonJS)的一种整合。支持 UMD 规范的库可以在任何模块环境中工作。

```js
(function (root, factory) {
  var clone = factory(root);
  if (typeof define === "function" && define.amd) {
    // AMD
    define("clone", function () {
      return clone;
    });
  } else if (typeof exports === "object") {
    // CommonJS
    module.exports = clone;
  } else {
    // 原始模块
    var _clone = root.clone;
    clone.noConflict = function () {
      if (root.clone === clone) {
        root.clone = _clone;
      }
      return clone;
    };
    root.clone = clone;
  }
})(this, function (root) {
  function clone(source) {
    // 此处省略
  }
  return clone;
});
```

由上述代码可以看到，UMD 规范只是对不同模块规范的简单整合，稍微不同的是，代码中给原始模块增加了 noConfict 方法，使用 noConfict 方法可以解决全局名称冲突的问题。

### ES Module

ECMAScript 2015 带来了原生的模块系统 ES Module。目前，部分浏览器已经支持直接使用 ES Module，而不兼容的浏览器则可以通过构建工具来使用。

```js
export function clone(source) {
  // 此处省略
}
```

假设上面的代码位于 clone.js 文件中，那么在 index.js 文件中可以像下面代码这样引用 clone.js 文件中的 clone 函数:

```js
import { clone } from "./clone";
const a = { a: 1 };
const b = clone(a);
```

介绍了多种前端模块，对于开源库来说，为了满足各种模块使用者的需求，需要对每种模块提供支持。开源库可以提供两个入口文件,

| 入口文件     | 支持的模块                                  |
| ------------ | ------------------------------------------- |
| index.js     | 原始模块、AMD 模块、CommonJS 模块、UMD 模块 |
| index.esm.js | ES Module                                   |

## 技术体系解析

在开始之前先来看一个场景：深拷贝库中有一个 type 函数，用来获取数据的类型，现在假设还有一个库也要用到这个函数，所以我们决定将其单独抽象为一个库，现在就有了两个库，其中 clone 库会依赖 type 库

一般一个 JavaScript 库都会依赖另外一些库，真实的 JavaScript 库的依赖关系会更复杂

### 传统体系

在传统体系中，一般通过在 HTML 文件中使用 script 标签来引入 JavaScript 文件，这种体系下的每个库都需要提供一个 js 格式的文件。

在传统体系下，如果想使用一个库，就必须在使用之前手动引入要用到的库及其依赖的库。例如，如果想使用 clone 库，就必须在引入 clone 库之前先引入 type 库否则就会报错

随着库规模的扩大，将依赖关系交给库的使用者手动维护，对库的使用者非常不友好，因为要提供包含全部代码的入口文件，所以在这种体系下，大部分库都不会依赖很多其他的库。

兼容传统体系的库，需要将所有代码及其依赖的库的代码合并成一个文件。但也存在例外情况，例如，jQuery 插件必须依赖 jQuery 才能运行，React 插件必须依赖 React 才能运行，这种情况下可以将 jQuery 或 React 的引入交给插件的使用者来实现。

### Node.js 体系

Nodejs 的模块系统遵守前面提到的 CommonJS 规范,Nodejs 有内置的依赖解析系统，如果要依赖一个模块，则可以像下面代码这样使用 require 系统函数直接引用文件:

```js
const clone = require("./clone");
```

在使用 require 函数引用文件时，被引用文件的路径需遵循一套复杂的规则，引用支持相对路径、绝对路径和第三方包，如果忽略后缀，则会被当作 Nodejs 的模块去解析。

Node.js 模块目录下需要有一个 package.json 文件，用于定义模块的一些属性。如果想要新建模块，则可以使用 Nodejs 提供的 npm 工具快速初始化。通过下面的命令可以在 lib 目录下新建并初始化 clone 模块:

```sh
mkdir clone
cd clone
npm init
```

npm 会提示填写模块的信息，这里不做修改，一直保持默认设置即可，执行后会生成一个 packagejson 文件，该文件包含的字段如下:

```json
{
  "name": "clone",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

这里主要关注 main 字段，其定义的是当前模块对应的逻辑入口文件，当该模块被其他模块引用时，Nodejs 会找到 main 字段对应的文件。

通过同样的操作完成对 type 模块的初始化。此时，项目的目录结构如下:

```sh
|- index.js
|- lib
  |- clone
    |- index.js
    |- package.json
  |- type
    |- index.js
    |- package.json
```

通过以下代码可以在 index.js 文件中直接引入 clone 模块，Node.js 会自动完成模块解析，并

```js
const clone = require("./lib/clone");
```

在 Node.js 体系下，库只需要提供对 CommonJS 模块或 UMD 模块的支持即可，对依赖的库不需要进行特殊处理。

### 工具化体系

随着前端工程化的发展，前端构建工具目前已经成为中大型项目的标配。构建工具的典型代表是 webpack，webpack 支持 CommonJs 规范。

如果想要使用 webpack，则需要先安装 webpack，安装命令如下:

```sh
npm i webpack webpack-cli -D
```

在项目的根目录下添加 webpack.config.js 文件，并在该文件中添加如下配置代码，其含义是将当前目录下的 index.js 文件打包输出为 `dist/index.js` 文件。

```js
const path = require("path");
module.exports = {
  entry: "./index.js",
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "index.js",
  },
};
```

然后执行命令：

```sh
npx webpack
```

接下来，添加一个 index.html 文件，引用打包输出的 dist/index.js 文件即可。

最开始，构建工具仅支持 CommonJS 规范，随着 ECMAScript 2015 的发布，rollup.js 最先支持 ES Module，现在主流的构建工具均已支持 ES Module。

打包工具在加载一个库时，需要知道这个库是支持 CommonJS 模块的还是支持 ES Module 的，构建工具给的方案是扩展一个新的入口字段，开源库可以通过设定这个字段来标识自己是否支持 ES Module。

由于历史原因，这个字段有两个命名，分别 module 和 jsnext，目前比较主流的是 module 字段，也可以两个都设置，只需要在库的 package.json 文件中增加字段名 module 和 jsnext，并设置为 ES Module 文件的路径即。

```json
{
  "main": "index.js",
  "module": "index.esm.js",
  "jsnext": "index.esm.js"
}
```

在 webpack 中，可以通过配置 mainFields 来支持优先使用 module 字段，只需要在 webpack.confg.js 文件中添加如下的配置代码即可:

```js
module.exports = {
  // 其他配置
  resolve: {
    mainFields: ["module"],
  },
};
```

index.js 文件提供对 CommonJS 模块的支持，

```js
function clone(source) {
  // 此处省略
}
module.exports = clone;
```

index.esm.js 文件提供对 ES Module 的支持，可以看到，支持 ES Module 的写法更加简洁。

```js
export function clone(source) {
  // 此处省略
}
```

对于库的使用者来说，不用关心 ES Module 规范和 CommonJS 规范之间的区别，只需要像下面代码这样引用即可：

```js
const clone = require("clone");
```

打包工具会优先查看依赖的库是否支持 ES Module，如果不支持，则会遵循 CommonJS 规范。

综上所述，在这种体系下，开源库需要同时提供对 ES Module 和 CommonJS 模块的支持，对其依赖的库不需要进行特殊处理。

## 打包方案

前面介绍了在不同的模块规范和不同的前端技术体系下，库的适配原理。这部分内容细致又琐碎，使用手动适配的方式会相当麻烦，那么有没有更好的办法呢?

目前，比较好的办法就是使用打包工具自动完成打包工作。

|            | 浏览器（script/AMD/CMD） | 打包工具（webpack/rollup.js） |  Node.js |
| ---------- | :----------------------: | ----------------------------: | -------: |
| 入口文件   |       index.aio.js       |                  index.esm.js | index.js |
| 模块规范   |           UMD            |                     ES Module | CommonJS |
| 自身依赖   |           打包           |                          打包 |     打包 |
| 第三方依赖 |           打包           |                        不打包 |   不打包 |

### 选择打包工具

既然已经确定了目标，那么接下来就需要选择一款合适的打包工具。社区大多选择 webpack 和 rollup.js 作为库的打包工具,

webpack 是现在非常流行打包工具，而 rollup.js 则被称作下一代打包工具，推荐使用 rollup.js 作为库的打包工具

为什么不使用我们更熟悉的 webpack 呢？我们通过具体示例来对比 webpack 和 rollup.js。假设有两个文件: index.is 和 bar.js。

bar.js 文件对外暴露一个 bar 函数，代码如下:

```js
export defualt function bar() {
  console.log("bar");
}
```

index.js 文件引用 bar.js 文件

```js
import bar from "./bar";
bar();
```

下面的代码是 webpack 打包输出的内容，index.js 和 bar.js 文件的内容在打包内容的最下面，起始处省略的 100 行代码其实是 webpack 生成的简易模块系统代码。webpack 方案的问题在于会生成很多冗余代码，这对于业务代码来说问题不大，但是对于库来说就不太友好了。

下面的代码是 rollup.js 打包输出的内容，可以看到模块完全消失了。那么 rollup.js 如何解决模块之间的依赖问题呢？对于打包的代码，rollup.js 巧妙地通过将被依赖的模块放在依赖模块前面的方法来解决模块依赖问题。对比 webpack 打包后的代码，rollup.js 的打包方案对于库的开发者来说是接近完美的方案。

### 打包步骤

首先安装 rollup.js，命令如下:

```sh
npm i --save-dev rollup@0.57.1
```

由于只在开发时才会用到 rollup.js，因此我们通过上面的参数 `--save-dev` 将其安装为开发时依赖，这样会将依赖添加到 package.json 文件的 devDependencies 字段中代码如下:

rollup.js 的使用方式和 webpack 的使用方式类似，需要通过配置文件告诉 rollup 如何打包。

[未完待续]