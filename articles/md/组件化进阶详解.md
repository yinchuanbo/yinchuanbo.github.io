---
title: "组件化进阶详解"
tag: "Vue"
time: 2025-01-16 10:21:59
---

## 动态组件

先看案例需求：单击按钮实现切换显示不同的组件

该案例可以通过下面两种不用的思路实现：

1. v-if 指令，

2. 动态组件

**1. v-if 指令的实现**

- Home.vue

```html
<template>
  <div>Home 组件</div>
</template>
<script>
  export default {
    name: "home",
  };
</script>
```

- About.vue

```html
<template>
  <div>About 组件</div>
</template>
<script>
  export default {
    name: "about",
  };
</script>
```

- Category.vue

```html
<template>
  <div>Category 组件</div>
</template>
<script>
  export default {
    name: "category",
  };
</script>
```

- App.vue

```html
<template>
  <div>
    <button
      v-for="item in tabs"
      :key="item"
      @click="itemClick(item)"
      :class="{ active: currentTab === item }"
    >
      {{ item }}
    </button>
    <template v-if="currentTab === 'home'">
      <home></home>
    </template>
    <template v-if="currentTab === 'about'">
      <about></about>
    </template>
    <template v-if="currentTab === 'category'">
      <category></category>
    </template>
  </div>
</template>
<script>
  import Home from "./Home.vue";
  import About from "./About.vue";
  import Category from "./Category.vue";
  export default {
    components: {
      Home,
      About,
      Category,
    },
    data() {
      return {
        tabs: ["home", "about", "category"],
        currentTab: "home",
      };
    },
    methods: {
      itemClick(item) {
        this.currentTab = item;
      },
    },
  };
</script>
```

**2. 动态组件的实现**

- App.vue

```html
<template>
  <div>
    <button
      v-for="item in tabs"
      :key="item"
      @click="itemClick(item)"
      :class="{ active: currentTab === item }"
    >
      {{ item }}
    </button>
    <!-- 动态组件的用法 -->
    <component :is="currentTab"></component>
  </div>
</template>
```

### 动态组件的传参

- App.vue

```html
<template>
  <div>
    <button
      v-for="item in tabs"
      :key="item"
      @click="itemClick(item)"
      :class="{ active: currentTab === item }"
    >
      {{ item }}
    </button>
    <!-- 动态组件的用法 -->
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </div>
</template>
<script>
  export default {
    //...
    methods: {
      //...
      pageClick(value) {
        console.log(value);
      },
    },
  };
</script>
```

- Home.vue

```html
<template>
  <div @click="divClick">Home 组件: {{ name }} - {{ age }}</div>
</template>
<script>
  export default {
    name: "home",
    emits: ["pageClick"],
    props: {
      name: {
        type: String,
        default: "",
      },
      age: {
        type: Number,
        default: 0,
      },
    },
    methods: {
      divClick() {
        this.$emit("pageClick", "Home 组件触发的单击");
      },
    },
  };
</script>
```

### keep-alive 的使用

作用：保留组件状态，不会被销毁

1. keep-alive 的使用

- App.vue

```html
<template>
  <div>
    <!-- ... -->
    <!-- keep-alive 保留动态组件的状态，同时会保留其对应的子孙组件的状态 -->
    <keep-alive>
      <component
        :is="currentTab"
        name="coderwhy"
        :age="18"
        @pageClick="pageClick"
      ></component>
    </keep-alive>
  </div>
</template>
```

2. keep-alive 的属性

- include: 支持 `string`、`RegExp`、`Array` 类型，只有名称匹配的组件会被缓存。

- exclude: 支持 `string`、`RegExp`、`Array` 类型，任何名称匹配的组件都不会被缓存。

- max: 支持 `number`、`string` 类型，最多可以缓存多少个组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的组件会被销毁。

> 其中 include 和 exclude 属性允许组件有条件的缓存，二者都可以表示为用逗号分隔的字符串、正则表达式或一个数组。匹配时会首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册的名称。

如果仅想缓存 Home.vue 和 About.vue 组件的状态，那么有三种写法：

```html
<!-- 1. 逗号分隔字符串 -->
<template>
  <keep-alive include="home, about">
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </keep-alive>
</template>
```

```html
<!-- 2. RegExp -->
<template>
  <keep-alive :include="/home|about/">
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </keep-alive>
</template>
```

```html
<!-- 3. Array -->
<template>
  <keep-alive :include="['home', 'about']">
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </keep-alive>
</template>
```

3. 缓存组件实例的生命周期

对于缓存组件来说，再次进入时不会再次执行 `created` 或 `mounted` 等生命周期函数，但在有些情况下，我们需要监听组件的重新进入和离开的时机，这时候可以使用 `activated` 和 `deactivated` 这两个生命周期钩子。

修改 About.vue 组件，添加 `activated` 和 `deactivated` 这两个生命周期钩子

```html
<template>
  <div>
    About 组件
    <button @click="counter++">单击递增：{{ counter }}</button>
  </div>
</template>
<script>
  export default {
    name: "about",
    data() {
      return {
        counter: 0,
      };
    },
    created() {
      console.log("about created");
    },
    unmounted() {
      console.log("about unmounted");
    },
    activated() {
      // 组件显示时回调
      console.log("about activated");
    },
    deactivated() {
      // 组件隐藏时回调
      console.log("about deactivated");
    },
  };
</script>
```

## 异步组件

有时候，我们可能异步加载某组件，这种异步加载的组件称为异步组件，在加载异步组件时，webpack 会对其进行分包处理。

### webpack 对代码分包

异步加载组件的好处是：当 webpack 加载异步组件时，为了更好的理解分包技术，先来看看 webpack 的打包过程，

(1) 默认情况下，在构建整个组件树的过程中，组件和组件之间是通过模块化直接依赖的

(2) webpack 在打包的时候会将组件模块打包到一起，比如打包到一个 app.js 文件中

(3) 随着项目不断增大，打包生成的 app.js 文件也会过大，从而导致首屏渲染速度过慢

为了解决打包生成的 app.js 文件过大的问题，我们可以在 webpack 打包时对代码进行分包，比如，对于一些不需要立即使用的组件，可以单独进行拆分，将他们拆分成一些小的代码块（如 chunk.js），这些 chunk.js 会在需要的时候从服务器中被加载下来，并执行代码，显示其对应的内容。

这种方式可以极大的提升 web 应用程序的性能。

举例：

```js
// utils/math.js
export function sum(num1, num2) {
  return num1 + num2;
}
```

```html
<!-- App.vue -->
<template>
  <div class="app">App 组件</div>
</template>
<script>
  // 可以省略扩展名
  import("./utils/math").then((res) => {
    console.log(res.num(10, 20));
  });
</script>
```

可以看到，使用 import 函数导入 math.js 模块时，会进行分包处理，math.js 模块已经被单独分到 chunk-2d0cfcbf.7b9b1398.js 文件中，其实，**webpack 底层就是通过 import 函数对代码进行分包的。**

### 在 Vue3 中实现异步组件

webpack 可以通过 import 函数对 math.js 模块进行分包处理，

如果想对 vue3 组件进行分包处理，那么可以使用 Vue3 提供的 `defineAsyncComponent` 函数实现异步加载组件，该函数支持两种类型的参数，

(1) 工厂函数：该工厂函数需要返回一个 Promise 对象。

(2) 对象类型：对异步函数进行配置。

**1. 工厂函数**

```html
<!-- Home.vue -->
<template>
  <div class="home">Home 组件</div>
</template>
```

> AsyncCategory.vue 组件，将作为异步组件使用，打包时会进行分包处理，

```html
<!-- AsyncCategory.vue -->
<template>
  <div class="async-category">
    <h4>{{ message }}</h4>
  </div>
</template>
<script>
  export default {
    data() {
      return {
        message: "AsyncCategory 异步组件",
      };
    },
  };
</script>
```

修改 App.vue 根组件：

```html
<template>
  <div class="app">
    App 组件
    <home></home>
    <async-category></async-category>
  </div>
</template>
<script>
  import { defineAsyncComponent } from "vue";
  import Home from "./Home.vue";
  // 使用 defineAsyncComponent 函数异步加载 AsyncCategory.vue 组件，会进行分包处理
  const AsyncCategory = defineAsyncComponent(() =>
    import("./AsyncCategory.vue")
  );
  export default {
    components: {
      Home,
      AsyncCategory,
    },
  };
</script>
```

**2. 对象类型**

```html
<template>
  <div class="app">
    App 组件
    <home></home>
    <async-category></async-category>
  </div>
</template>
<script>
  import { defineAsyncComponent } from "vue";
  import Home from "./Home.vue";
  // 1. 使用工行函数形式
  // const AsyncCategory = defineAsyncComponent(() =>
  //   import("./AsyncCategory.vue")
  // );

  // 2. 对象类型语法
  const AsyncCategory = defineAsyncComponent({
    // 需要异步加载的组件
    loader: () => import("./AsyncCategory.vue"),
    // 加载时显示 loading 组件
    loadingComponent: Loading,
    // 加载失败时显示 Error 组件
    errorComponent: Error,
    // 在显示 loadingComponent 之前的延迟，默认值是：200ms
    delay: 200,
    // 加载组件的时间超过设定值，将显示错误组件，默认值为: Infinity (永不超时，单位 ms)
    timeout: 3000,
    // 定义组件是否可挂起，默认 true
    suspensible: false, // false，代表异步组件可以退出 Suspense 控制，并始终控制自己的加载状态
    /**
     * 组件加载失败回调
     * @param {*} error 错误信息对象
     * @param {*} retry 一个函数，用于指定当 promise 加载器 reject 时，加载器是否应该重新
     * @param {*} fail 一个函数，指示加载程序结束并退出
     * @param {*} attempts 允许最大重试次数
     */
    onError: function (error, retry, fail, attempts) {
      if (error.message.match(/fetch/) && attempts <= 3) {
        // 请求发生错误时重试，最多可尝试 3 次
        retry();
      } else {
        fail();
      }
    },
  });
  export default {
    components: {
      Home,
      AsyncCategory,
    },
  };
</script>
```

### 异步组件和 Suspense

在一个组件树中，如果存在多个异步组件，那么每个异步组件都需要处理自己的加载、报错和完成状态。

为了统一这些异步组件，Vue3 提供了一个内置组件 Suspense，用于在组件树中协调对异步依赖的处理。

Suspense 可以让我们在组件树的上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态，防止在最坏情况下看到多个 Loading 加载状态，并在不同时间内显示内容。

如果异步组件的父组件链中存在一个 Suspense 组件，那么该异步组件将被视为该 Suspense 组件的异步依赖项。`在这种情况下，异步组件的加载状态由 Suspense 控制，异步组件自身的加载、错误、延迟和超时选项都会被忽略。`

如果想要异步组件退出 Suspense 控制，并始终控制自己的加载状态，那么可以在选项中指定 `suspensible: false`

**Suspense 组件包含两个插槽：**

(1) default: 如果 default 插槽可以显示，则会显示 default 插槽的内容

(2) fallback: 如果 default 插槽无法显示，则会显示 fallback 插槽的内容

```html
<!-- App.vue -->
<template>
  <div class="app">
    App 组件
    <home></home>
    <suspense>
      <template #default>
        <async-category></async-category>
      </template>
      <template #fallback>
        <loading></loading>
      </template>
    </suspense>
  </div>
</template>
<script>
  import { defineAsyncComponent } from "vue";
  import Home from "./Home.vue";
  import Loading from "./Loading.vue";
  const AsyncCategory = defineAsyncComponent(() =>
    import("./AsyncCategory.vue")
  );
  export default {
    components: {
      Home,
      Loading,
      AsyncCategory,
    },
  };
</script>
```

当正在加载异步组件时，显示 `<loading>` 组件，在异步组件加载完成后，显示 `<async-category />` 组件内容。

## 获取元素或组件的实例

### $refs

在某些情况下，我们需要在 Vue3 组件中获取元素对象或子组件实例，Vue3 不推荐直接进行 DOM 操作，相反，我们可以为元素或组件绑定一个 ref 属性。

ref 属性用于注册元素或子组件的引用，该引用最终会被注册在组件的 `this.$refs` 对象中，该对象包含所有注册了 ref 属性的 DOM 元素和组件实例的引用。

```html
<!-- NavBar.vue -->
<template>
  <div class="navbar">
    <h4>NavBar</h4>
  </div>
</template>
<script>
  export default {
    data() {
      return {
        message: "我是 NavBar 中的 message 变量",
      };
    },
    methods: {
      sayHello() {
        console.log("sayHello: Hello NavBar");
      },
    },
  };
</script>
```

```html
<!-- App.vue -->
<template>
  <div class="app">
    <h4 ref="title">App 中的 H4 元素</h4>
    <nav-bar ref="navBar"></nav-bar>
    <button @click="btnClick">获取 h4 元素对象和 NavBar 组件实例</button>
  </div>
</template>
<script>
  import NavBar from "./NavBar.vue";
  export default {
    components: {
      NavBar,
    },
    data() {
      return {
        names: ["coder", "why"],
      };
    },
  };
</script>
```

[188]