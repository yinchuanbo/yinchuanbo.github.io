---
title: "组件化进阶详解"
tag: "Vue"
time: 2025-01-16 10:21:59
---

## 动态组件

先看案例需求：单击按钮实现切换显示不同的组件

该案例可以通过下面两种不用的思路实现：

1. v-if 指令，

2. 动态组件

**1. v-if 指令的实现**

- Home.vue

```html
<template>
  <div>Home 组件</div>
</template>
<script>
  export default {
    name: "home",
  };
</script>
```

- About.vue

```html
<template>
  <div>About 组件</div>
</template>
<script>
  export default {
    name: "about",
  };
</script>
```

- Category.vue

```html
<template>
  <div>Category 组件</div>
</template>
<script>
  export default {
    name: "category",
  };
</script>
```

- App.vue

```html
<template>
  <div>
    <button
      v-for="item in tabs"
      :key="item"
      @click="itemClick(item)"
      :class="{ active: currentTab === item }"
    >
      {{ item }}
    </button>
    <template v-if="currentTab === 'home'">
      <home></home>
    </template>
    <template v-if="currentTab === 'about'">
      <about></about>
    </template>
    <template v-if="currentTab === 'category'">
      <category></category>
    </template>
  </div>
</template>
<script>
  import Home from "./Home.vue";
  import About from "./About.vue";
  import Category from "./Category.vue";
  export default {
    components: {
      Home,
      About,
      Category,
    },
    data() {
      return {
        tabs: ["home", "about", "category"],
        currentTab: "home",
      };
    },
    methods: {
      itemClick(item) {
        this.currentTab = item;
      },
    },
  };
</script>
```

**2. 动态组件的实现**

- App.vue

```html
<template>
  <div>
    <button
      v-for="item in tabs"
      :key="item"
      @click="itemClick(item)"
      :class="{ active: currentTab === item }"
    >
      {{ item }}
    </button>
    <!-- 动态组件的用法 -->
    <component :is="currentTab"></component>
  </div>
</template>
```

### 动态组件的传参

- App.vue

```html
<template>
  <div>
    <button
      v-for="item in tabs"
      :key="item"
      @click="itemClick(item)"
      :class="{ active: currentTab === item }"
    >
      {{ item }}
    </button>
    <!-- 动态组件的用法 -->
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </div>
</template>
<script>
  export default {
    //...
    methods: {
      //...
      pageClick(value) {
        console.log(value);
      },
    },
  };
</script>
```

- Home.vue

```html
<template>
  <div @click="divClick">Home 组件: {{ name }} - {{ age }}</div>
</template>
<script>
  export default {
    name: "home",
    emits: ["pageClick"],
    props: {
      name: {
        type: String,
        default: "",
      },
      age: {
        type: Number,
        default: 0,
      },
    },
    methods: {
      divClick() {
        this.$emit("pageClick", "Home 组件触发的单击");
      },
    },
  };
</script>
```

### keep-alive 的使用

作用：保留组件状态，不会被销毁

1. keep-alive 的使用

- App.vue

```html
<template>
  <div>
    <!-- ... -->
    <!-- keep-alive 保留动态组件的状态，同时会保留其对应的子孙组件的状态 -->
    <keep-alive>
      <component
        :is="currentTab"
        name="coderwhy"
        :age="18"
        @pageClick="pageClick"
      ></component>
    </keep-alive>
  </div>
</template>
```

2. keep-alive 的属性

- include: 支持 `string`、`RegExp`、`Array` 类型，只有名称匹配的组件会被缓存。

- exclude: 支持 `string`、`RegExp`、`Array` 类型，任何名称匹配的组件都不会被缓存。

- max: 支持 `number`、`string` 类型，最多可以缓存多少个组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的组件会被销毁。

> 其中 include 和 exclude 属性允许组件有条件的缓存，二者都可以表示为用逗号分隔的字符串、正则表达式或一个数组。匹配时会首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册的名称。

如果仅想缓存 Home.vue 和 About.vue 组件的状态，那么有三种写法：

```html
<!-- 1. 逗号分隔字符串 -->
<template>
  <keep-alive include="home, about">
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </keep-alive>
</template>
```

```html
<!-- 2. RegExp -->
<template>
  <keep-alive :include="/home|about/">
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </keep-alive>
</template>
```

```html
<!-- 3. Array -->
<template>
  <keep-alive :include="['home', 'about']">
    <component
      :is="currentTab"
      name="coderwhy"
      :age="18"
      @pageClick="pageClick"
    ></component>
  </keep-alive>
</template>
```

3. 缓存组件实例的生命周期

对于缓存组件来说，再次进入时不会再次执行 `created` 或 `mounted` 等生命周期函数，但在有些情况下，我们需要监听组件的重新进入和离开的时机，这时候可以使用 `activated` 和 `deactivated` 这两个生命周期钩子。

修改 About.vue 组件，添加 `activated` 和 `deactivated` 这两个生命周期钩子

```html
<template>
  <div>
    About 组件
    <button @click="counter++">单击递增：{{ counter }}</button>
  </div>
</template>
<script>
  export default {
    name: "about",
    data() {
      return {
        counter: 0,
      };
    },
    created() {
      console.log("about created");
    },
    unmounted() {
      console.log("about unmounted");
    },
    activated() {
      // 组件显示时回调
      console.log("about activated");
    },
    deactivated() {
      // 组件隐藏时回调
      console.log("about deactivated");
    },
  };
</script>
```

## 异步组件

有时候，我们可能异步加载某组件，这种异步加载的组件称为异步组件，在加载异步组件时，webpack 会对其进行分包处理。

### webpack 对代码分包

异步加载组件的好处是：当 webpack 加载异步组件时，为了更好的理解分包技术，先来看看 webpack 的打包过程，

(1) 默认情况下，在构建整个组件树的过程中，组件和组件之间是通过模块化直接依赖的

(2) webpack 在打包的时候会将组件模块打包到一起，比如打包到一个 app.js 文件中

(3) 随着项目不断增大，打包生成的 app.js 文件也会过大，从而导致首屏渲染速度过慢

为了解决打包生成的 app.js 文件过大的问题，我们可以在 webpack 打包时对代码进行分包，比如，对于一些不需要立即使用的组件，可以单独进行拆分，将他们拆分成一些小的代码块（如 chunk.js），这些 chunk.js 会在需要的时候从服务器中被加载下来，并执行代码，显示其对应的内容。

这种方式可以极大的提升 web 应用程序的性能。

举例：

```js
// utils/math.js
export function sum(num1, num2) {
  return num1 + num2;
}
```

```html
<!-- App.vue -->
<template>
  <div class="app">App 组件</div>
</template>
<script>
  // 可以省略扩展名
  import("./utils/math").then((res) => {
    console.log(res.num(10, 20));
  });
</script>
```

可以看到，使用 import 函数导入 math.js 模块时，会进行分包处理，math.js 模块已经被单独分到 chunk-2d0cfcbf.7b9b1398.js 文件中，其实，**webpack 底层就是通过 import 函数对代码进行分包的。**

### 在 Vue3 中实现异步组件

webpack 可以通过 import 函数对 math.js 模块进行分包处理，

如果想对 vue3 组件进行分包处理，那么可以使用 Vue3 提供的 `defineAsyncComponent` 函数实现异步加载组件，该函数支持两种类型的参数，

(1) 工厂函数：该工厂函数需要返回一个 Promise 对象。

(2) 对象类型：对异步函数进行配置。

**1. 工厂函数**

```html
<!-- Home.vue -->
<template>
  <div class="home">Home 组件</div>
</template>
```

> AsyncCategory.vue 组件，将作为异步组件使用，打包时会进行分包处理，

```html
<!-- AsyncCategory.vue -->
<template>
  <div class="async-category">
    <h4>{{ message }}</h4>
  </div>
</template>
<script>
  export default {
    data() {
      return {
        message: "AsyncCategory 异步组件",
      };
    },
  };
</script>
```

修改 App.vue 根组件：

```html
<template>
  <div class="app">
    App 组件
    <home></home>
    <async-category></async-category>
  </div>
</template>
<script>
  import { defineAsyncComponent } from "vue";
  import Home from "./Home.vue";
  // 使用 defineAsyncComponent 函数异步加载 AsyncCategory.vue 组件，会进行分包处理
  const AsyncCategory = defineAsyncComponent(() =>
    import("./AsyncCategory.vue")
  );
  export default {
    components: {
      Home,
      AsyncCategory,
    },
  };
</script>
```

[183]
